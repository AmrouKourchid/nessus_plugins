#TRUSTED 44b3a9146e37c956eb2eb3c7ad33f5474899e48f7fd68eca7437bd08ea2211f0b355b78b474876b26d68e1c51b118afb7283c844329c9cf38d703ab0b3122dfe96e515cc2d9765f459586ae1fa1cd8cc8a14f854ffafbfde3c73726fcd9e1f4a052f283d8740fbf2fc1dda4da6311faf5df6d63132cb1e3ecb555920820dfa59cd3f4352dbd967c812dec177ceaa7326e78188cbc5ee3fbfc28382ee4d90d8f99d496f8b83818f1145d9546d237bdffe78fabbbf786a62cbef6a366065fec09f4614e8ca002df621e480b317eb7b66069f0a47f51f4f90905fd23e11127fda2da68412e996bcca5f55d6d012df7c5494e0f0c277068de8964b8de7acc340a826c6455c9470b48bde0c8de3ab061d1342507737f9d4abd071ddc83b789ec6f36d2f58b2012d627b1438a60a3b274a4f8c9c8fb9ef97e1f7572bcc974c1e74d819bde2fb84340a84ae52c7e526f1dde065b80ff78aba7406fc1611fc4aac0ee0c3ff7363c4030b274af83f71691b1a2ad9c4044ee9c174864a7a952da41caba13715920686c293a2bc870d94dc1537d17fb6d432decbef195a3138dbc066cce6f9e0aeaf28de753e0b3732a255a98fcee324edaed613e5d17da11e12f7fb53153dec27e81ae61f5520bdaf09487961b99da09cbd07ffa0044d2c7845f989a9493622ba752f3a456c9430e014ac217f10caa734f8a39d8442ca69108c882759bd84
#
# (C) Tenable Network Security, Inc.
#
# This script is released under one of the Tenable Script Licenses and may not
# be used from within scripts released under another license without the
# authorization from Tenable Network Security, Inc.
#
#
# @NOGPL@
#
# http_network.inc
#
# Revision: 1.56

global_var __ka_socket, __ka_port, __ka_enabled, __ka_last_request, __ka_transport, __ka_pid;
global_var __http_read_timeout, __http_incr_timeout_on_err, __http_sent_request;
global_var _basic_auth_URLs, __http_error_port, __http_error_op, __http_error_code;
global_var __http_use_async_sock, _in__http_set_error;
global_var __redirect_with_get; # 0: RFC compliant / 1: broken but common
global_var __ka_client_cert, __ka_client_private_key, __ka_client_private_key_password;
global_var __os, _http_max_req_sz;

__os = NULL;
__ka_socket = NULL;
__ka_port   = 0;
__ka_enabled = -1;
__ka_last_request = "";
__ka_pid = NULL;
__ka_client_cert = NULL;
__ka_client_private_key = NULL;
__ka_client_private_key_password = NULL;

_in__http_set_error = 0;
__http_read_timeout = NULL;
__http_incr_timeout_on_err = 1;
__http_sent_request = NULL;
__redirect_with_get = 1;
_http_max_req_sz = 1048576;

##
# the main connection function. This is accessed through
# other functions to init the connection to server
#
# @param [target:string] IP address of non standard system
# @param [port:int] port of target
# @param [transport:string] transport type, default ENCAPS_IP
# @param [client_cert:string] path to client cert
# @param [client_private_key:string] path to client private_key
# @param [client_private_key_password:string] password to client private key
# @return [socket object] socket to return for query
##
function http_open_sock_err(target, port, transport, client_cert, client_private_key, client_private_key_password)
{
  local_var s, e, now, t1, t2, to, dt, rto;

  t1 = gettimeofday();
  if (target)
  {
    s = open_sock2(host:target, port:port, timeout:__http_read_timeout, transport:ENCAPS_IP);

    if (s && !isnull(transport) && transport != ENCAPS_IP && !isnull(client_cert) && !isnull(client_private_key))
    {
      s = socket_negotiate_ssl_ex(socket:s, async:false,
        cert:client_cert,
        key:client_private_key,
        password:client_private_key_password,
        transport:transport);
    }
    else if ( s && !isnull(transport) && transport != ENCAPS_IP)
    {
      s = socket_negotiate_ssl(socket:s, transport:transport);
    }
  }
  else
  {
    s = open_sock_tcp(port, transport: transport, timeout: __http_read_timeout);
  }

  if (s)
  {
    # http_clear_error(port: port);
    return s;
  }

  # Error
  t2 = gettimeofday();
  now = split(t2, sep: '.', keep: 0);
  now = int(now[0]);
  to = http_get_read_timeout();
  dt = difftime(t1: t1, t2: t2);
  if (dt < to *1000000 - 500000)
  {
    if (defined_func("socket_get_error") && __http_use_async_sock)
    {
      if (target)
      {
        s = open_sock2(host:target, port:port, timeout:__http_read_timeout, transport:ENCAPS_IP);

        if (s && !isnull(transport) && transport != ENCAPS_IP && !isnull(client_cert) && !isnull(client_private_key))
        {
          s = socket_negotiate_ssl_ex(socket:s, async:false,
            cert:client_cert,
            key:client_private_key,
            password:client_private_key_password,
            transport:transport);
        }
        else if ( s && !isnull(transport) && transport != ENCAPS_IP )
        {
          s = socket_negotiate_ssl(socket:s, transport:transport);
        }
      }
      else
      {
        s = open_sock_tcp(port, transport: transport, nonblocking:TRUE, timeout: __http_read_timeout);
      }
      while (1)
      {
        if (socket_ready(s))
        {
          e = socket_get_error(s);
          if (e == 0)
          {
            debug_print('http_open_sock_err: connection to TCP port ', port, ' succeeded on 2nd attempt.');
            # http_clear_error(port: port);
            return s;
          }
          else
          {
            close(s);
            now = unixtime();
            break;
          }
       }
        sleep(1);
      }
      #NOTREACHED
    }
    else
    {
       e = ECONNREFUSED;
    }
  }
  else
  {
    e = ETIMEDOUT;
  }

  debug_print('http_open_sock_err: connection to TCP port ', port, ' failed - errno=', e);
  http_set_error(target: target, port: port, errno: e, op: 'connecting to server');
  return NULL;
}

##
# clear error handlers for globals
#
# @param [port:int] port to clear with target
# @return [NULL]
##
function http_clear_error(port)
{
  __http_error_code = NULL;
  __http_error_op = NULL;
  __http_error_port = NULL;
  rm_kb_item(name:'www/'+port+'/unresponsive/time');
  rm_kb_item(name:'www/'+port+'/unresponsive/nb');
 _in__http_set_error = 0;
}

##
# error report handling for HTTP type sockets
#
# @param [port:int] port with error status
# @param [socket:object] socket object with error
# @param [op:string] details of what happened while error
# @param [errno:string] error information
# @param [now:string] current time of error
# @return [NULL]
##
function http_set_error(target, port, socket, op, errno, now)
{
  local_var dead_time, dead_nb, v, to, to2;

  if (_in__http_set_error)
  {
    debug_print('http_set_error: recursive call aborted!\n');
    return;
  }
  _in__http_set_error = 1;

  if (isnull(port))
  {
    if (isnull(socket))
    {
      err_print('http_set_error: port or socket argument missing.\n');
      _in__http_set_error = 0;
      return;
    }

    if ( socket_ready(socket) > 0 )
      v = get_peer_name(socket);
    else
      v = NULL;

    if (isnull(v))
    {
      debug_print('http_set_error: get_sock_name(', socket, ')=NULL\n');
      _in__http_set_error = 0;
      return;
    }
    port = v[1];
  }
  if (isnull(errno) && ! isnull(socket))
    errno = socket_get_error(socket);

  debug_print('http_set_error: port=', port, ' errno=', errno, ' (', http_strerror(errno), '), op=', op, '\n');
  __http_error_code = errno;
  __http_error_op = op;
  __http_error_port = port;

  if (__http_incr_timeout_on_err && errno == ETIMEDOUT)
  {
    to = http_get_read_timeout();
    if (to < 30)
    {
      to ++;
      to2 = get_kb_item('www/'+port+'/read_timeout');
      if (to > to2)
      {
        http_set_read_timeout(to);
        debug_print(level: 1, 'http_set_error: increasing network timeout to ', to, ' s after ETIMEDOUT\n');
        if (port > 0) replace_kb_item(name: 'www/'+port+'/read_timeout', value: to);
      }
      else
      {
        http_set_read_timeout(to2);
      }
    }
  }

  if (isnull(now)) now = unixtime();
  dead_time = get_kb_item('www/'+port+'/unresponsive/time');
  dead_nb = get_kb_item('www/'+port+'/unresponsive/nb');
  dead_nb ++;
  replace_kb_item(name: 'www/'+port+'/unresponsive/nb', value: dead_nb);

  if (dead_time > 0)
  {
    if (now - dead_time >= 300 && dead_nb >= 20)
    {
      rm_kb_item(name:'www/'+port+'/unresponsive/time');
      rm_kb_item(name:'www/'+port+'/unresponsive/nb');
      if (http_is_dead(target:target, port:port))
        declare_broken_web_server(port: port, reason:
        'The web server failed to respond at least ' + dead_nb + ' times for ' + (now - dead_time) + ' s.');
    }
  }
  else
  {
    replace_kb_item(name: 'www/'+port+'/unresponsive/time', value: now);
  }
  _in__http_set_error = 0;
}

##
# return the error message in string format
#
# @return [string] error message information
##
function http_error_msg()
{
  if (isnull(__http_error_code) || isnull(__http_error_op))
    return NULL;

  return __http_error_op + ': errno=' + __http_error_code + ' (' +
         http_strerror(__http_error_code) + ')';
}

##
# error status types
#
# @param [_FCT_ANON_ARGS[0]:int] report info?
# @return [string] error type details
##
function http_strerror()
{
  local_var e;

  e = int(_FCT_ANON_ARGS[0]);

  if (e == NOERR) return "no error";
  if (e == ETIMEDOUT) return "operation timed out";
  if (e == ECONNRESET) return "connection reset by peer";
  if (e == EUNREACH) return "host unreachable";
  if (e == EUNKNOWN) return "unknown error";
  if (e == ESSL) return "SSL error";
  if (e == EINPROGRESS) return "operation in progress";
  if (e == ECONNREFUSED) return "connection refused";
  if (e == ENOBUFS) return "no buffer space available";
  return "error #"+e;
}

##
# writer please write a brief intent of this function
#
# @return [int]
##
function http_transient_error()
{
  if ( __http_error_code == EINPROGRESS ||
       __http_error_code == ETIMEDOUT ||
       __http_error_code == ENOBUFS )
    return 1;
  if (__http_error_code == ECONNREFUSED)
  {
    if (get_kb_item('Port/tcp/'+__http_error_port))
    {
      if (isnull(__os)) __os = get_kb_item("Host/OS");
      if (!isnull(__os) && "Windows" >< __os)
        return 1;
    }
  }
  return 0;
}

##
# recv the header from aN HTTP socket
# this function will also parse the cookie
#
# @param [socket:string] socket to recv the header from
# @return [string]
##
function http_recv_headers3(target, socket)
{
  local_var buf, line, counter;

  buf = NULL;
  while ( TRUE )
  {
    counter ++;
    line = recv_line(socket:socket, length:4096, timeout: __http_read_timeout);
    if (strlen(line) == 0) break;
    buf += line;
    if (line =~ '^Set-Cookie2?:') parse_setcookie_header(header: line);
    if ( line == '\r\n' || line == '\n') break;
    if ( counter > 1024 ) break;
  }
  if (isnull(buf))
  {
    debug_print('http_recv_headers3: cannot read HTTP headers\n');
    http_set_error(target: target, socket: socket, op: 'reading HTTP headers');
  }
  return buf;
}

##
# Compatibility function
#
# @return [socket object]
##
function http_recv_headers2(target, socket)
{
  return http_recv_headers3(target: target, socket: socket);
}

##
# disable the keep alive status on http messages
# and disable and sockets with keep alive status
#
# @return [NULL]
##
function http_disable_keep_alive()
{
  __ka_enabled = 0;
  if (__ka_socket > 0)
  {
    http_close_socket(__ka_socket);
    __ka_socket = NULL;
  }
}

##
# enable keep alive global var
#
# @return [NULL]
##
function http_enable_keep_alive()
{
  if (!__ka_enabled) __ka_enabled = -1;
}

##
# force the keep alive status to stay active
#
# @param [port:int]
# @return [NULL]
##
function http_force_keep_alive(port)
{
  if (__ka_socket > 0 && __ka_port != port)
  {
    http_close_socket(__ka_socket);
    __ka_socket = NULL;
    __ka_pid = NULL;
  }
  __ka_enabled = 1;
  __ka_port = port;
}

##
# Initialize a socket or reopen a keep alive socket
#
# @param [target:string] ip address of non standard system
# @param [socket:object] socket to reopen if exists
# @param [port:int] port of the socket to open
# @param [keepalive:BOOL] turn on keep alive status or NULL
# @param [transport:string] transport type, default ENCAPS_IP
# @param [client_cert:string] path to client cert
# @param [client_private_key:string] path to client private_key
# @param [client_private_key_password:string] password to client private key
# @return [socket object]
##
function http_reopen_socket(target, socket, port, keepalive, transport, client_cert, client_private_key, client_private_key_password)
{
  if (socket)
  {
    if (socket == __ka_socket)
    {
      __ka_socket = NULL;
    }

    __ka_pid = NULL;
    http_close_socket(socket);
  }

  socket = http_open_sock_err(target: target, port: port, transport: transport,
    client_cert: client_cert,
    client_private_key: client_private_key,
    client_private_key_password: client_private_key_password);

  if (keepalive)
  {
    __ka_socket = socket; __ka_port = port; __ka_transport = transport;
    __ka_client_cert = client_cert;
    __ka_client_private_key = client_private_key;
    __ka_client_private_key_password = client_private_key_password;

    if ( defined_func("getpid") ) __ka_pid = getpid();
  }
  return socket;
}

##
# maintain the keep alive socket checking the params of
# the global vars to confirm they are valid
#
# @param [target:string] ip address of non standard system
# @param [port:int] port of the socket to open
# @param [keepalive:BOOL] turn on keep alive status or NULL
# @param [transport:string] transport type, default ENCAPS_IP
# @param [client_cert:string] path to client cert
# @param [client_private_key:string] path to client private_key
# @param [client_private_key_password:string] password to client private key
#
# @return [socket object]
##
function http_open_socket_ka(target, port, keepalive, transport, client_cert, client_private_key, client_private_key_password)
{
  if (__ka_socket && keepalive && __ka_port == port && __ka_transport == transport)
  {
    if ( !defined_func("getpid") || __ka_pid == getpid() )
    {
      return __ka_socket;
    }
  }

  return http_reopen_socket(target: target, socket: __ka_socket, port: port,
    keepalive: keepalive, transport: transport, client_cert: client_cert,
    client_private_key: client_private_key, client_private_key_password: client_private_key_password);
}

##
# close a socket and return the keep alive globals
# to NULL status
#
# @param [_FCT_ANON_ARGS[0]:object] keep alive socket object to close
# @return [NULL]
##
function http_close_socket_ka()
{
  local_var s;
  s = _FCT_ANON_ARGS[0];
  http_close_socket(s);
  if (s == __ka_socket)
  {
    __ka_socket = NULL;
    __ka_port = NULL;
    __ka_pid = NULL;
  }
}

##
# disable the keep alive status from globals
#
# @param [_FCT_ANON_ARGS[0]:object] keep alive socket object to disable
# @return [NULL]
##
function disable_socket_ka()
{
  local_var s;
  s = _FCT_ANON_ARGS[0];
  if (s == __ka_socket) __ka_socket = NULL;
}

##
# only close the socket if it is a keep alive socket and
# return the keep alive globals to NULL
#
# @param [_FCT_ANON_ARGS[0]:object] keep alive socket object to close
# @return [NULL]
##
function _http_close_socket_ka_only()
{
  local_var    s;
  s = _FCT_ANON_ARGS[0];
  if (s != __ka_socket) return;
  http_close_socket(s);
  __ka_socket = NULL;
  __ka_port = NULL;
  __ka_transport = NULL;
  __ka_client_cert = NULL;
  __ka_client_private_key = NULL;
  __ka_client_private_key_password = NULL;
}

##
# check the header if it has connection close status
# and if it does reopen socket
#
# @param [header:string] packet header
# @return [NULL]
##
function http_keepalive_check_connection(headers)
{
  local_var tmp;
  tmp = egrep(pattern:"^Connection: *Close", string:headers, icase: 1);
  if(tmp)
  {
     if ( __ka_socket )
     {
       http_close_socket(__ka_socket);
     }

     if (__ka_client_cert && __ka_client_private_key)
     {
       __ka_socket = http_open_sock_err(port: __ka_port,
         client_cert:__ka_client_cert,
         client_private_key:__ka_client_private_key,
         client_private_key_password:__ka_client_private_key_password);
     }
     else
     {
       __ka_socket = http_open_sock_err(port: __ka_port);
     }
  }
}

##
# enable the global keep alive variable and
# open a socket with the keep alive socket object
# set to the global variable __ka_socket
#
# @param [port:int] port to open
# @param [transport:string] transport type, default ENCAPS_IP
# @param [client_cert:string] path to client cert
# @param [client_private_key:string] path to client private_key
# @param [client_private_key_password:string] password to client private key
# @return [NULL]
##
function enable_keepalive(target, port, transport, client_cert, client_private_key, client_private_key_password)
{
  __ka_enabled = 1;
  __ka_port    = port;
  __ka_socket  = http_open_sock_err(target: target, port: port,
    transport: transport,
    client_cert:client_cert,
    client_private_key:client_private_key,
    client_private_key_password:client_private_key_password);

  if ( defined_func("getpid") ) __ka_pid = getpid();
  __ka_transport = transport;
  __ka_client_cert = client_cert;
  __ka_client_private_key = client_private_key;
  __ka_client_private_key_password = client_private_key_password;
  if ( defined_func("getpid") ) __ka_pid	= getpid();
}

##
# set keep alive status to true for port and test. If tests
# are positive response then
# replace_kb_item(name:strcat("www/", port, "/keepalive"), value:"yes");
#
# @param [target:string] ip address of non standard system
# @param [port:int] port to test and set status for keep alive
# @param [exit_on_fail:BOOL] exit if failures, defause FALSE
# @param [transport:string] transport type, default ENCAPS_IP
# @param [client_cert:string] path to client cert
# @param [client_private_key:string] path to client private_key
# @param [client_private_key_password:string] password to client private key
# @return [int] 0 ka no || 1 success || -2 fail
#
# @note keep-Alive is necessary for NTLM authentication, so we
#   try to have it even on a LAN.
##
function http_keepalive_enabled(target, port, exit_on_fail, transport, client_cert, client_private_key, client_private_key_password)
{
  local_var rq, buf, soc, r, b, kb, host;

  if ( !isnull(target) )
  {
  kb = get_kb_item("www/" + port + "/keepalive");

  if ( !isnull(target) )
  {
    enable_keepalive(target:target, port: port, transport: transport,
      client_cert:client_cert,
      client_private_key:client_private_key,
      client_private_key_password:client_private_key_password);

    return 1;
  }

  if (kb == "yes")
  {
    enable_keepalive(target:target, port: port, transport: transport,
      client_cert:client_cert,
      client_private_key:client_private_key,
      client_private_key_password:client_private_key_password);

    return 1;
  }
  else if (kb == "no") return(0);
  }

  # keep-Alive is necessary for NTLM authentication, so we try to have it
  # even on a LAN.

  host = get_preference('sc.hostname.' + get_host_ip()); # SC3

  if (strlen(host) == 0) host = get_host_name();

  rq = http_mk_get_req( port: port, host: host, item: "/",
                        version: 11);
  rq['Pragma'] = 'no-cache';
  rq['Connection'] = 'Keep-Alive';
  if (target) rq['Host'] = target;

  soc = http_open_sock_err(target: target, port: port, transport: transport,
    client_cert:client_cert, client_private_key:client_private_key,
    client_private_key_password:client_private_key_password);

  if(!soc)
    if (exit_on_fail) exit(1, "Cannot connect to TCP port "+port+".");
    else  return -2;

  buf = http_mk_buffer_from_req(req: rq, transport: transport);
  send(socket:soc, data: buf);
  r = http_recv_headers3(target: target, socket: soc);

  if (isnull(r))
  {
    http_close_socket(soc);
    if (exit_on_fail) exit(1, "Cannot read HTTP headers on port "+port+".");
    return -2;
  }
  b = http_recv_body(target: target, socket: soc, headers: r);

  # Apache
  if(egrep(pattern:"^Keep-Alive:.*", string:r))
  {
    http_close_socket(soc);
    if ( isnull(target) ) replace_kb_item(name: 'www/' + port + '/keepalive', value:"yes");

    enable_keepalive(target: target, port:port, transport: transport);
    return 1;
  }
  else if ( egrep(pattern: "^Server: *Microsoft-IIS", string: r) ||
            egrep(pattern:"^Connection: *Keep-Alive", string:r, icase: 1))
  {
    # IIS
    if (send(socket:soc, data: buf) == strlen(buf))
    {
      r = _http_recv(target: target, socket:soc);
      http_close_socket(soc);
      if (strlen(r) > 0)
      {
        if ( isnull(target) ) replace_kb_item(name:"www/" + port + "/keepalive", value:"yes");

        enable_keepalive(target: target, port:port, transport: transport);
        return 1;
      }
    }
  }

  if ( isnull(target) ) replace_kb_item(name:"www/" + port + "/keepalive", value:"no");
  return 0;
}

##
# encode none standard characters with URL encode
#
# @param [str:string] string to encode
# @param [unreserved:string] standard string items to not encode
# @return [string]
##
function redir_urlencode(str, unreserved)
{
  local_var ch, estr, len, i;

  estr = "";
  len = strlen(str);
  if (isnull(unreserved)) unreserved = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_.!~*'()-]";

  for (i=0; i<len; i+=1)
  {
    ch = str[i];

    if (ch >< unreserved) estr += ch;
    # the rest are escaped.
    else
    {
      ch = hexstr(ch);
      ch = toupper(ch);
      estr += "%" + ch;
    }
  }

  return estr;
}

##
# parse the string URL sent in and encode it
# with URL encoding if needed
#
# @param [item:string] URL to encode
# @return [string]
##
function fix_rel_location(item)
{
  local_var i, path, qs, prev;

  i = stridx(item, '?');
  if (i < 0)
  {
    path = item;
    qs = NULL;
  }
  else if (i == 0)
  {
    path = "";
    qs = substr(item, 1);
  }
  else
  {
    path = substr(item, 0, i - 1);
    qs = substr(item, i + 1);
  }

  # Remove sharp, we do not need it, it is interpreted by the browsers only
  if (qs)
  {
    i = stridx(qs, '#');
    if (i >= 0) qs = substr(qs, 0, i - 1);
  }

  if (! preg(string: path, pattern: "^([/a-zA-Z0-9_.!~*'()-]|(%[0-9a-fA-F]{2}))*$"))
    path = redir_urlencode(str: path, unreserved:"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_.!~*'()-/");

  # Mind the + & = [ ]
  if (! isnull(qs) &&
      ! preg(string: qs, pattern: "^([/a-zA-Z0-9_.!~*'()&+=\[\]-]|(%[0-9a-fA-F]{2}))*$"))
    qs = redir_urlencode(str: qs, unreserved:"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_.!~*'()-[]/&+=");


  prev = item;
  if (isnull(qs)) item = path;
  else item = path + '?' + qs;
  debug_print(level:2, 'fix_rel_location: ', prev, ' -> ', item, '\n');
  return item;
}

##
# Sends and recv an HTTP response. This should be called from higher
# level functions and not directly
#
# @param [port:int] port to connect to
# @param [only_content:BOOL] This is mainly used by webmirror.nasl
# @param [no_body:BOOL] false if body is empty
# @param [exit_on_fail:BOOL] exit if fails default false
# @param [transport:string] transport type, default ENCAPS_IP
# @param [client_cert:string] path to client cert
# @param [client_private_key:string] path to client private_key
# @param [client_private_key_password:string] password to client private key
# @return [list] {code, header, body}
##
function _http_send_recv_once(target, port, buf, req, ka, fetch404, only_content, no_body, exit_on_fail, transport, client_cert, client_private_key, client_private_key_password)
{
  local_var s, r, status_line, headers, body, ct, head;
  local_var no403, v, e;

  s = http_open_socket_ka(target:target, port: port, keepalive: ka,
    transport: transport,
    client_cert: client_cert,
    client_private_key:client_private_key,
    client_private_key_password:client_private_key_password);

  if (! s)
  {
    debug_print('_http_send_recv_once(port: ', port, '): http_open_socket_ka failed\n');
    if (exit_on_fail)
      exit(1, "Can't connect to web server on port "+port+".");
    else
      return NULL;
  }

  head = 0;
  if (isnull(buf))
  {
    if (isnull(req))
    {
      err_print('_http_send_recv_once: buf and req parameters cannot both be NULL\n');
      if (exit_on_fail)
        exit(1, "Invalid parameters for _http_send_recv_once(port=", port, ").");
      return NULL;
    }
    else
    {
      if (ka)
        req['Connection'] = 'Keep-Alive';
      else if (req['$version'] != 9)
        req['Connection'] = 'Close';
      if (req['$method'] == 'HEAD') head = 1;
      buf = http_mk_buffer_from_req(req: req, transport: transport);
    }
  }
  else
  {
    if (! isnull(req))
    {
      err_print('_http_send_recv_once: buf and req parameters cannot both be set. req ignored.\n');
    }
    if (match(string: buf, pattern: "HEAD *")) head = 1;
  }

  r = send(socket: s, data: buf);
  if (r > 0)
  {
    __http_sent_request = buf;

    # status lines and headers do not exist in HTTP 0.9
    if (req['$version'] == 9)
    {
      v = make_list();
      v[0] = NULL;  # no status line
      v[1] = NULL;  # no headers
      v[2] = NULL;  # body

      repeat
      {
        body = recv_line(socket: s, length: 4096, timeout: __http_read_timeout);
        v[2] += body;
      } until isnull(body);

      http_close_socket_ka(s);
      return v;
      # never reached
    }

    status_line = recv_line(socket: s, length: 4096, timeout: __http_read_timeout);
    if (strlen(status_line) == 0)
    {
      e = socket_get_error(s);
      debug_print('_http_send_recv_once(port: ', port, '): cannot read status line - errno=', e, '\n');
      http_set_error(target: target, port: port, errno: e, op: 'reading the HTTP status line');
    }
  }
  else
  {
    debug_print('_http_send_recv_once(port: ', port, '): send failed\n');
    if (! ka)
    {
      e = socket_get_error(s);
      http_set_error(target: target, port: port, errno: e, op: 'sending the request');
    }
    status_line = NULL;
  }

  if (! status_line && ka)
  {
    s = http_reopen_socket(target: target, socket: s, port: port, keepalive: 1, transport: transport,
      client_cert:client_cert,
      client_private_key:client_private_key,
      client_private_key_password:client_private_key_password);

    if (! s)
    {
      debug_print('_http_send_recv_once(port: ', port, '): http_reopen_socket failed\n');
      if (exit_on_fail)
        exit(1, "Can't connect to web server on port "+port+".");
      else
        return NULL;
    }
    debug_print(level: 2, '_http_send_recv_once: socket to port ', port, ' reopen\n');
    r  = send(socket: s, data: buf);
    if (r > 0)
    {
      __http_sent_request = buf;
      status_line = recv_line(socket: s, length: 4096, timeout: __http_read_timeout);
      if (strlen(status_line) == 0)
      {
        e = socket_get_error(s);
        debug_print('_http_send_recv_once(port: ', port, '): cannot read status line - errno=', e, '\n');
        http_set_error(target: target, port: port, errno: e, op: 'reading the status line');
      }
    }
    else
    {
      status_line = NULL;
      debug_print('_http_send_recv_once(port: ', port, '): send failed\n');
      e = socket_get_error(s);
      http_set_error(target: target, port: port, errno: e, op: 'sending the request');
    }
  }

  if (strlen(status_line) == 0)
  {
    http_close_socket_ka(s);
    if (exit_on_fail)
      exit(1, "Can't read line from web server on port "+port+".");
    return NULL;
  }
  headers = http_recv_headers3(target: target, socket: s);

  # MA 2009-07-23: we cannot do anything very smart if we get a code and no
  # headers. The connection was probably broken. Let's return an error now.
  if (isnull(headers))
  {
    debug_print('_http_send_recv_once(port: ', port, '): cannot read headers\n');
    http_close_socket_ka(s);
    if (exit_on_fail)
      exit(1, "Can't read HTTP headers from web server on port "+port+".");
    return NULL;
  }

  #### Fix for very broken servers

  if (status_line =~ "<h[1-9]> *Bad Request.*</h[1-9]>")
  {
    debug_print('Broken server sent an invalid code : ', chomp(status_line));
    status_line = 'HTTP/1.0 400 Bad Request (broken server)\r\n';
  }
  # Add more error messages here
  ####

  #### 100 Continue ####
  if (status_line =~ '^HTTP/1\\.[01] +100 ')
  {
    # Keep last answer in case something fails...
    v = make_list(status_line, headers);

    status_line = recv_line(socket: s, length: 4096, timeout: __http_read_timeout);
    if (! status_line)
    {
      debug_print(level: 1, '_http_send_recv_once(port=', port, '): Cannot read status line after 100 Continue\n');
      http_set_error(target: target, port: port, socket: s, op: 'reading the status line');
      return v;
    }
    v = NULL;
    headers = http_recv_headers3(target: target, socket: s);
    if (isnull(headers))
    {
      debug_print(level: 1, '_http_send_recv_once(port=', port, '): Cannot read HTTP headers after 100 Continue\n');
      return make_list(status_line);
    }
  }

  no403 = get_kb_item('www/no403header/'+port);
  if ( strlen(no403) > 0 &&
       egrep(string: headers, pattern: no403, icase: 1))
  {
    status_line = ereg_replace(string: status_line, pattern: "^HTTP/(1\.[01]) +([1-3][0-9][0-9]) ",
     replace: "HTTP/\1 403 ");
  }

  if (no_body)
  {
    if (! head) http_close_socket_ka(s);
    http_clear_error(port: port);
    if ( ! isnull(headers) ) return make_list(status_line, headers);
    else return make_list(status_line);
  }
  if (only_content) # This is mainly used by webmirror.nasl
  {
    ct = egrep(pattern: "^Content-Type:", icase: 1, string: headers);
    if (strlen(ct) > 0 &&
        ! egrep(pattern: '^Content-Type:[ \t]*' + only_content, icase: 1, string: ct))
    {
      http_close_socket_ka(s);
      http_clear_error(port: port);
      return make_list(status_line, headers);
    }
  }

  if (egrep(pattern:"^Connection: *Close", string: headers, icase: 1))
  {
    ka = 0;
    disable_socket_ka(s); # Avoid a double close
  }

  body = NULL;
  if (fetch404 || status_line !~ '^HTTP/1\\.[01] +404 ')
  {
    body = http_recv_body(target: target, socket: s, headers: headers);
    if (isnull(body) && status_line =~ '^HTTP/1\\.[01] +200 ' && "GET " >< req['$request'])
    {
      debug_print('_http_send_recv_once: ', req['$request'], ' could not download HTTP body (port=', port, ')\n');
    }
  }

  if (ka && __ka_socket && ! head && isnull(body))
    ka = 0; # Body was not read, we don't want the next request to read it.
  if (! ka) http_close_socket_ka(s);

  http_clear_error(port: port);
  if (isnull(body))
    return make_list(status_line, headers);
  else
  {
    no403 = get_kb_item('www/no403body/'+port);
    if ( strlen(no403) > 0 &&
         egrep(string: body, pattern: no403, icase: 1))
    {
      status_line = ereg_replace(string: status_line, pattern: "^HTTP/(1\.[01]) +([1-3][0-9][0-9]) ",
       replace: "HTTP/\1 403 ");
    }

    if ( http_get_gzip_enabled() && egrep(pattern:"^Content-Encoding: gzip", string:headers, icase:TRUE) )
    {
	body = gunzip(body);
	if ( isnull(body) ) return NULL;
    }
    return make_list(status_line, headers, body);
  }
}

##
# base call for HTTP request that will
# branch into the working calls.
#
# @param [port:int] port to connect to
# @param [host:string] HTTP host header status
# @param [method:string] HTTP method (ie: GET|POST)
# @param [item:string] url in header
# @param [data:string] data to send in the body
# @param [version:int] http version number (ie:11|10)
# @param [add_header:array] items to add to header request
# @param [username:string] auth username for example HTTP auth
# @param [password:string] auth password ^
# @param [fetch404:BOOL] Return 404 pages
# @param [only_content:BOOL] This is mainly used by webmirror.nasl
# @param [no_body:BOOL] false if body is empty
# @param [follow_redirect:int] maximum number of redirects to follow
# @param [content_type:string] http "Content-Type" value
# @param [exit_on_fail:BOOL] exit if fails default false
# @param [transport:string] transport type, default ENCAPS_IP
# @param [client_cert:string] path to client cert
# @param [client_private_key:string] path to client private_key
# @param [client_private_key_password:string] password to client private key
# @param [unrestricted_redirect:BOOL] This allows redirects to other targets and ports.
#                                     Shouldn't be used for checks against the target/port
#                                     to avoid reporting results on the wrong target/port.
# @return [list] {code, header, body}
##
function http_send_recv3(target, port, host, method, item, data, version, add_headers, username, password, fetch404, only_content, no_body, follow_redirect, content_type, exit_on_fail, transport, client_cert, client_private_key, client_private_key_password, unrestricted_redirect)
{
  local_var rq, prx, w;

  if (strlen(item) == 0)
  {
    err_print('http_send_recv3: empty item\n');
    return NULL;
  }

  rq = http_mk_req( port: port, host: host, method: method, item: item,
                    content_type: content_type,
                    data: data, version: version, add_headers: add_headers);
  if (isnull(rq))
  {
    debug_print('http_send_recv3(port: ', port, ') : http_mk_req failed\n');
    return NULL;
  }
  if (target) rq['Host'] = target;

  w = http_send_recv_req(target: target, port: port, req: rq,
                         username: username, password: password,
                         fetch404: fetch404,
                         follow_redirect: follow_redirect,
                         unrestricted_redirect: unrestricted_redirect,
                         exit_on_fail: exit_on_fail, transport: transport,
                         only_content: only_content, no_body: no_body,
                         client_cert: client_cert,
                         client_private_key: client_private_key,
                         client_private_key_password: client_private_key_password);

  if (isnull(w))
    debug_print('http_send_recv3(port: ', port, ', host: ', host, ', transport: ', transport, ', method: ', method, ', item: ', item, ', data=', data, ', version: ', version, ', follow_redirect: ', follow_redirect, '): http_send_recv_req failed\n');
  return w;
}

##
# init request to HTTP server
#
# @param [port:int] port to connect to
# @param [req:array] http header content
# @param [username:string] auth username for example http auth
# @param [password:string] auth password ^
# @param [fetch404:BOOL] Return 404 pages
# @param [only_content:BOOL] This is mainly used by webmirror.nasl
# @param [no_body:BOOL] false if body is empty
# @param [follow_redirect:int] maximum number of redirects to follow
# @param [exit_on_fail:BOOL] exit if fails default false
# @param [transport:string] transport type, default ENCAPS_IP
# @param [client_cert:string] path to client cert
# @param [client_private_key:string] path to client private_key
# @param [client_private_key_password:string] password to client private key
# @param [unrestricted_redirect:BOOL] This allows redirects to other targets and ports.
#                                     Shouldn't be used for checks against the target/port
#                                     to avoid reporting results on the wrong target/port.
# @return [list] {code, header, body}
##
function http_send_recv_req(target, port, req, username, password,
                            fetch404, only_content, no_body, follow_redirect,
                            exit_on_fail, transport,
                            client_cert, client_private_key, client_private_key_password, unrestricted_redirect)
{
  local_var ka, buf, v, z;
  local_var line, w, newuri, auth, newreqline, newport, ver, req2, new_transport_match;

  if(__ka_enabled < 0)
  {
    __ka_enabled = http_keepalive_enabled(target: target, port:port, exit_on_fail: exit_on_fail,
      client_cert: client_cert,
      client_private_key: client_private_key,
      client_private_key_password: client_private_key_password,
      transport: transport);

    if(__ka_enabled == -2)
    {
      debug_print('http_send_recv_req(port: ', port, '): http_keepalive_enabled failed\n');
      return NULL;
    }
  }

  if (isnull(req))
  {
    err_print('http_send_recv_req(port: ', port, '): missing req parameter\n');
    return NULL;
  }

  if (_basic_auth_URLs[req['$uri']])
  {
    req2 = http_add_auth_to_req( req: req, username: username, password: password);
    if (! isnull(req2))
    {
      req = req2;
     debug_print(level: 2, 'Opportunistic Basic authentication on URL ', req['$uri'], '\n');
    }
    req2 = NULL;
  }

  ka = __ka_enabled;
  if (ka)
  {
    req['Connection'] = 'Keep-Alive';
  }

  if (isnull(unrestricted_redirect)) unrestricted_redirect = FALSE;

  if (unrestricted_redirect)
  {
    debug_print('Unrestricted redirections enabled.');
  }

  v = _http_send_recv_once( target: target, port: port, req: req, ka: ka, fetch404: fetch404,
                            only_content: only_content, no_body: no_body,
                            transport: transport,
                            client_cert: client_cert,
                            client_private_key: client_private_key,
                            client_private_key_password: client_private_key_password,
                            exit_on_fail: exit_on_fail);
  if (isnull(v))
  {
    debug_print('http_send_recv_req(port: ', port, '): _http_send_recv_once failed - method=', req['$method'], ' item=', req['$uri'], ' port=', req['$port'], ' version=', req['$version'], '\n');
    return NULL;
  }

  # Follow redirection - this block can hardly be put into a separate function
  # as it may update the authentication credentials.
  while (v[0] =~ '^HTTP/1\\.[01] +30[1237] ' && follow_redirect > 0)
  {
    follow_redirect --;
    line = egrep(string: v[1], pattern: '^Location:', icase: 1);
    # 30x without Location header cannot be processed further
    if (strlen(line) == 0) return v;
    # 307 force redirection with the same method; 303 redirects with GET
    # According to RFCs, 301/302 should behave like 307 but many browsers
    # implemented them like 303.
    if (v[0] =~ '^HTTP/1\\.[01] +303 ' ||
        (v[0] =~ '^HTTP/1\\.[01] +30[12] ' && __redirect_with_get))
    {
      req['$method'] = "GET";
      req['$data'] = NULL; req['Content-Length'] = NULL; req['Content-Type'] = NULL;
    }
    # Set the Referer, this might be important
    req['Referer'] = build_url(port: port, qs: req['$uri']);
    w = pregmatch(string: chomp(line), pattern: '^Location:[ \t]*([^ \t].*)', icase: TRUE);
    if (isnull(w))
    {
      debug_print("Invalid Location field: ", line);
      newuri = '';
    }
    else
      newuri = chomp(w[1]);

    ver = ' HTTP/1.1';
    if (req['$version'] == 9) ver = '';
    else if (req['$version'] == 10) ver = ' HTTP/1.0';

    if (newuri !~ "^https?://")
    {
      debug_print(level: 2, "Redirection to relative URI is not RFC-compliant. Trying to fix it: ", newuri);
      newuri = fix_rel_location(item: newuri);
      # The RFC are clear but too many sites are broken
      if (req['$method'] == 'POST')
      {
        debug_print(level: 2, 'Switching from POST to GET to follow non RFC compliant redirection\n');
        req['$method'] = 'GET';
        req['$data'] = NULL; req['Content-Length'] = NULL; req['Content-Type'] = NULL;
      }
      if (strlen(newuri) == 0 || newuri[0] != '/')
      {
        z = pregmatch(string: req['$uri'], pattern: "^(.*/)[^/]*$");
        if (isnull(z))
          debug_print("Cannot extract base directory from original URI: ", req['$uri']);
        else
          newuri = z[1] + newuri;
      }
      req['$uri'] = newuri;
      newreqline = req['$method'] + ' ' + newuri + ver;
      req['Cookie'] = mk_cookie_header(item: newuri);
    }
    else
    {
      req['$uri'] = newuri; # Informative only
      debug_print(level: 3, 'Location=', w[1], '\n');
      w = pregmatch(string: newuri, pattern: 'https?://(([^/]+)@)?([^/:]+)?(:[0-9]+)?(/.*)', icase: TRUE);
      if (isnull(w))
      {
        debug_print("Cannot parse Location: ", chomp(newuri));
        return v;    # Cannot parse Location, won't go further
      }
      else
      {
        debug_print(level: 4, 'w=', w, '\n');
      }

      req['Host'] = w[3];
      # For an unrestricted redirect allow the target host to change
      # otherwise limit it to the existing target.
      if (unrestricted_redirect)
      {
        target = req['Host'];
      }
      else
      {
        if (target) req['Host'] = target;
      }

      if (strlen(req['$scheme']) > 0) # This is a proxy request
      {
        newreqline = req['$method'] + ' ' + newuri + ver;
        req['Cookie'] = mk_cookie_header(item: newuri);
      }
      else
      {
        if (w[2]!= '')
        {
          auth = split(w[2], sep: ':', keep: 0);
          username = auth[0];
          if (auth[1] != '') password = auth[1];
        }
        newport = NULL;
        if (strlen(w[4]) > 0)
        {
          newport = int(substr(w[4], 1));
          # Only connect to new port if unrestricted redirects are allowed.
          # Otherwise we won't connect to the new port, this would lead to bogus reports
          if (unrestricted_redirect)
          {
            debug_print('Redirecting from port ' + port + ' to ' + newport + '.');
            port = newport;
          }
          else
          {
            if (newport != port) return v;
          }
        }
        else
        {
          if(unrestricted_redirect && isnull(newport))
          {
            # No specific port specified so redirect to standard ports
            if (newuri =~ "^http://")
            {
              port = 80;
              debug_print('Set new port based on http default ' + port + '.');
            }
            else if(newuri =~ "^https://")
            {
              port = 443;
              debug_print('Set new port based on https default ' + port + '.');
            }
          }
        }

        # Set transport to new match location
        if (unrestricted_redirect)
        {
          new_transport_match = pregmatch(string: newuri, pattern: '(https?)://', icase: TRUE);
          if(!isnull(new_transport_match))
          {
            transport = new_transport_match[1];
            debug_print('Setting transport to ' + transport + '.');
          }
        }
        newreqline = req['$method'] + ' ' + w[5] + ver;
        req['Cookie'] = mk_cookie_header(item: w[5]);
      }
    }
    req['$request'] = newreqline;
    debug_print(level: 3, 'newreqline=', newreqline, '\n');
    v = _http_send_recv_once( target: target, port: port, req: req, ka: ka, fetch404: fetch404,
                              only_content: only_content, no_body: no_body,
                              transport: transport,
                              client_cert: client_cert,
                              client_private_key: client_private_key,
                              client_private_key_password: client_private_key_password,
                              exit_on_fail: exit_on_fail );

    if (isnull(v))
    {
      debug_print('http_send_recv_req(port: ', port, '): _http_send_recv_once failed - method=', req['$method'], ' item=', req['$uri'], ' port=', req['$port'], ' version=', req['$version'], '\n');
      return NULL;
    }
    debug_print(level: 3, 'v=', v, '\n');
  }
  # End of redirection
  if (v[0] !~ '^HTTP/1\\.[01] +40[17] ') return v;

  req = http_add_auth_to_req( req: req, headers: v[1],
                              username: username, password: password);
  if (isnull(req))
  {
    debug_print(level:2, 'http_send_recv_req(port: ', port, '): http_add_auth_to_req failed\n');
    return v;
  }

  v = _http_send_recv_once(target: target,port: port, req: req, ka: ka,
                           fetch404: fetch404, exit_on_fail: exit_on_fail,
                           client_cert: client_cert,
                           client_private_key: client_private_key,
                           client_private_key_password: client_private_key_password,
                           transport: transport);

  if (isnull(v))
  {
    debug_print('http_send_recv_req(port: ', port, '): _http_send_recv_once failed\n');
    return NULL;
  }

  if ( v[0] =~ '^HTTP/1\\.[01] +40[17] ' &&
       egrep(string: v[1], pattern: '^(WWW|Proxy)-Authenticate: NTLM'))
  {
    req = http_add_auth_to_req( req: req, headers: v[1],
                                username: username, password: password);
    if (isnull(req))
    {
      debug_print(level:2, 'http_send_recv_req(port: ', port, '): http_add_auth_to_req failed\n');
      return v;
    }

    v = _http_send_recv_once(target: target, port: port, req: req, ka: ka,
      fetch404: fetch404, exit_on_fail: exit_on_fail, transport: transport,
      client_cert: client_cert,
      client_private_key: client_private_key,
      client_private_key_password: client_private_key_password);

    if (isnull(v))
    {
      debug_print('http_send_recv_req(port: ', port, '): _http_send_recv_once failed\n');
      return NULL;
    }
  }

  if ( v[0] =~ "^HTTP/1\.[01] +20[0-9] " &&
       match(string: req['Authorization'], pattern: "Basic *"))
  {
    _basic_auth_URLs[req['$uri']] = 1;
  }
  return v;
}

##
# This is a compatibility function.
# It works like the old http_send_recv(),
# but manages keep-alive and authentication.
# It opens a socket to the web server,
# sends it to the web server and reads the result.
#
# @param [port:int] port to connect to
# @param [data:string] the message body
# @param [username:string] auth username for example HTTP auth
# @param [password:string] auth password ^
# @param [fetch404:BOOL] Return 404 pages
# @param [only_content:BOOL] This is mainly used by webmirror.nasl
# @param [no_body:BOOL] false if body is empty
# @param [exit_on_fail:BOOL] exit if fails default false
# @param [transport:string] transport type, default ENCAPS_IP
# @param [client_cert:string] path to client cert
# @param [client_private_key:string] path to client private_key
# @param [client_private_key_password:string] password to client private key
# @return [string] request response
##
function http_send_recv_buf(port, data, username, password, fetch404, only_content, no_body, exit_on_fail, transport, client_cert, client_private_key, client_private_key_password)
{
  local_var ka, cnx_line, buf, v, payload_idx, headers, rq, a;

  if (isnull(data))
  {
    err_print('http_send_recv_buf(port: ', port, '): missing data parameter\n');
    return NULL;
  }

  payload_idx = stridx(data, '\r\n\r\n');
  if (payload_idx < 0)
    headers = data;
  else
  {
    headers = substr(data, 0, payload_idx + 1);
    payload_idx += 4;
  }
  cnx_line = egrep(string: headers, pattern: "^Connection *:", icase: 1);
  ka = NULL;
  if (strlen(cnx_line) > 0)
    if ("Keep-Alive" >< cnx_line) ka = 1;
    else if ("Close" >< cnx_line) ka = 0;

  if (isnull(ka))
  {
    if(__ka_enabled < 0)
    {
      __ka_enabled = http_keepalive_enabled(port:port, exit_on_fail: exit_on_fail,
      transport: transport,
      client_cert: client_cert,
      client_private_key: client_private_key,
      client_private_key_password: client_private_key_password);
    }

    if(__ka_enabled == -2)
    {
      debug_print('http_send_recv_buf(port: ', port, '): http_keepalive_enabled failed\n');
      return NULL;
    }
    if (__ka_enabled > 0) ka = 1; else ka =0;
  }

  if (cnx_line)
    if (ka)
      headers += 'Connection: Keep-Alive\r\n';
    else
      headers += 'Connection: Close\r\n';

  if (payload_idx < 0)
    buf = headers;
  else
    buf = headers + '\r\n' + substr(data, payload_idx);

  v = _http_send_recv_once( port: port, buf: buf, ka: ka, fetch404: fetch404,
                            only_content: only_content, no_body: no_body,
                            transport: transport,
                            exit_on_fail: exit_on_fail,
                            client_cert: client_cert,
                            client_private_key: client_private_key,
                            client_private_key_password: client_private_key_password);
  if (isnull(v))
  {
    debug_print('http_send_recv_buf(port: ', port, '): _http_send_recv_once failed\n');
    return NULL;
  }

  if (v[0] !~ '^HTTP/1\\.[01] +40[17] ') return v;

  rq = http_add_auth_to_req( req: make_array(), headers: v[1],
                             username: username, password: password);
  if (isnull(rq))
  {
    debug_print(level: 2, 'http_send_recv_buf(port: ', port, '): http_add_auth_to_req failed\n');
    return v;
  }

  while (1)
  {
    a = egrep(string: headers, pattern: "^Authorization *:", icase: 1);
    if (strlen(a) > 0) headers -= a;
    else
    {
      a = egrep(string: headers, pattern: "^Proxy-Authorization *:", icase: 1);
      if (strlen(a) > 0)
        headers -= a;
      else
        break;
    }
  }
  if (strlen(rq["Authorization"]) > 0)
    headers += 'Authorization: ' + rq["Authorization"] + '\r\n';
  if (strlen(rq["Proxy-Authorization"]) > 0)
    headers += 'Proxy-Authorization: ' + rq["Authorization"] + '\r\n';

  if (payload_idx < 0)
    buf = headers;
  else
    buf = headers + '\r\n' + substr(data, payload_idx);

  v = _http_send_recv_once( port: port, buf: buf, ka: ka, fetch404: fetch404,
                            transport: transport,
                            exit_on_fail: exit_on_fail,
                            client_cert: client_cert,
                            client_private_key: client_private_key,
                            client_private_key_password: client_private_key_password);
  if (isnull(v))
    debug_print('http_send_recv_buf(port: ', port, '): _http_send_recv_once failed\n');

  return v;
}

##
# exit keep alive global sockets
# This function is called when library loads
#
# @return [NULL]
##
function on_exit()
{
  if(__ka_socket)
  {
    http_close_socket(__ka_socket);
    __ka_socket = NULL;
  }
}
# init the keep alive status when this inc
# is added to a nasl. This will release any global
# keep alive sockets and set them to NULL
if ( 0 ) on_exit();


##
# set the global for max request size
#
# @param [_FCT_ANON_ARGS[0]:int] size of max in bytes
# @return [NULL]
##
function http_set_max_req_sz()
{
  local_var sz;
  sz = int(_FCT_ANON_ARGS[0]);
  if (sz <= 0)
  {
    err_print("http_set_max_req_sz: invalid (or missing) argument: ", sz);
    return;
  }
  _http_max_req_sz = sz;
}

##
# recv a socket http request body without
# the http header
#
# @param [socket:object] socket to recv on
# @param [headers:string] headers, if null recv header
# @param [length:int] length minus the header
# @return [NULL] on fail | [string] on success
##
function http_recv_body(target, socket, headers, length)
{
  local_var h, cl, l, min, max, x, n, to, dobrk;
  local_var    incomplete_read;

  if (isnull(headers))
  {
    h = http_recv_headers3(target: target, socket:socket);
    if (isnull(h)) return NULL;
  }
  else
  {
    h = headers;
  }

  l = -1;
  cl = pregmatch(pattern: '(^|\r\n)Content-length:[ \t]*([0-9]+)', string: h, icase: TRUE);
  if(! isnull(cl)) l = int(cl[2]);
  # "l" = Content-Length or -1 now
  max = -1;
  min = -1;

  if(egrep(pattern:"^transfer-encoding: *chunked", string:h, icase:TRUE))
  {
    local_var tmp, body;
    body = "";

    dobrk = 0;
    while(1)
    {
      tmp = recv_line(socket:socket, length:4096, timeout: __http_read_timeout);
      l = hex2dec(xvalue:tmp);
      if ( l + strlen(body) >= _http_max_req_sz )
      {
         l = _http_max_req_sz - strlen(body);
         dobrk = 1;
         debug_print('http_recv_body: read stopped after ', _http_max_req_sz / 1024, 'KB\n');
      }
      if (l > 0)
        body += recv(socket:socket, length:l, min:l, timeout: __http_read_timeout);

      recv (socket:socket, length:2, min:2);
      if (dobrk)
        _http_close_socket_ka_only(socket);
      if (l == 0 || dobrk)
      {
        return(body); # This is expected - don't put this line before the previous
      }
    }
  }

  if (length) max = length;
  if (l >= 0) min = int(l);
  if (l >= max || min >= max ) max = l;
  if ( max < 0)
  {
    debug_print(level: 3, 'http_recv_body: bogus or no Content-length field, and no \'length\' parameter set! Defaulting to ', _http_max_req_sz, '\n');
    max = _http_max_req_sz;
    incomplete_read = 1;
  }
  if ( max > _http_max_req_sz ) { max = _http_max_req_sz; incomplete_read = 1; }
  if ( min > _http_max_req_sz ) { min = _http_max_req_sz; incomplete_read = 1; }

  debug_print(level: 3, "http_recv_body: min=", min, "; max=", max, "\n");
  if (min > 0)
  {
    x = recv(socket: socket, length: max, min: min, timeout: __http_read_timeout);
    if (strlen(x) < max) incomplete_read = 1;
  }
  else
  {
    n = recv(socket: socket, min:max, length: max, timeout: __http_read_timeout);
    x = n;
    while ( strlen(n) >= max && max != 0 )
    {
      n = recv(socket: socket, length: max, timeout: __http_read_timeout);
      x += n;
      if( strlen(x) > _http_max_req_sz)
      {
        debug_print('http_recv_body: read stopped after ', _http_max_req_sz / 1024, 'KB\n');
        incomplete_read = 1;
        break;
      }
    }
  }
  if (incomplete_read)
    _http_close_socket_ka_only(socket);
  return(x);
}

##
# recv a HTTP response
#
# @param [socket:object] socket to recv on
# @param [code:BOOL] if true recv till \r\n or null line
# @return [string] HTTP response
##
function _http_recv(target, socket, code)
{
  local_var h, b, l;
  if (code)
  {
    h = string(code); # Convert to string, just in case
    repeat
    {
      l = recv_line(socket: socket, length: 2048, timeout: __http_read_timeout);
      h = h + l;
    }
    until (! l || l =~ '^[\r\n]+$'); # EOF or empty line
    if (!l) return h;
  }
  else
  {
    h = http_recv_headers3(target: target, socket:socket);
    if (isnull(h))
    {
      return(NULL);
    }
    else if ( ! preg(pattern:"^HTTP/.* [0-9]*", string:h) ) return h;
    h += '\r\n';
  }
  b = http_recv_body(target: target, socket: socket, headers: h, length:0);
  return h + b;
}

##
# This function reads everything
# Note that body length will be ignored if the Content-length field is set
#
# @param [socket:object] socket object to recv on
# @param [code:BOOL] if true recv till \r\n or null line
# @return [list] {code, header, body}
##
function http_recv3(target, socket, code)
{
  local_var h, b, l;
  if (code)
  {
    repeat
    {
      l = recv_line(socket: socket, length: 2048, timeout: __http_read_timeout);
      h = h + l;
    }
    until (! l || l =~ '^[\r\n]+$'); # EOF or empty line
    if (!l) return h;
  }
  else
  {
    code = recv_line(socket: socket, length: 2048, timeout: __http_read_timeout);
    if (! code) return NULL;
    h = http_recv_headers3(target: target, socket: socket);
    if (isnull(h))
    {
      return make_list(code);
    }
    if (code !~ "^HTTP/.* [0-9]+ ") make_list(code, h);
  }
  b = http_recv_body(target: target, socket: socket, headers: h, length:0);
  if ( ! isnull(b) )
    return make_list(code, h, b);
  else
    return make_list(code, h);
}

##
# Test if HTTP server is not responding
#
# @param [port:int] port to retrieve on
# @param [retry:int] number of times to attempt
# @return [int] 1 server error|0 OK
##
function http_is_dead(target, port, retry)
{
  local_var soc, url, req, rq, code, h, h2, b, i;

  if (retry <= 0) retry = 1; # or 0?

  i = 0;
  i = 0;

  soc = http_open_sock_err(target:target, port: port);
  while (!soc && i++ < retry)
  {
    sleep(1); # Should we use sleep(i) ?
    soc = http_open_sock_err(target: target, port: port);
  }
  if (! soc) return 1;

  # NB: http_head does not work against SWAT & VNC (& probably others...)
  url = "/" + rand_str(length: 8, charset: "abcdefghijklmnopqrstuvwxyz");
  rq = http_mk_get_req(port: port, item: url);
  if (target) rq['Host'] = target;
  req = http_mk_buffer_from_req(req: rq);
  send(socket:soc, data:req);
  for (i = 0; i <= retry; i ++)
  {
   code = recv_line(socket:soc, length: 1024, timeout: __http_read_timeout);
   if (strlen(code) > 0)
   {
     h = http_recv_headers3(target: target, socket:soc);
     # MA 2009-07-23: if we cannot read the headers, the server is not dead as
     # it answered with a code
     if (! isnull(h))
     {
       h2 = code + h;
       b = http_recv_body(target: target, socket: soc, headers: h2);
     }
     break;
   }
   else
     sleep(1);
  }
  http_close_socket(soc);
  if (!code) return (1);
  # 500: internal server error
  # 501: not implemented = unsupported method...
  # 502: Bad gateway = upstream server sends an invalid response
  # 503: service unavailable = temporary overloading...
  # 504: gateway timeout = no timely response from upstream server
  if (preg(pattern: "^HTTP/1\.[01] +50[234]", string: code)) return(1);
  return (0);
}

##
# get the timeout set for HTTP sockets
#
# @return [string] timeout in seconds
##
function http_get_read_timeout()
{
  if (isnull(__http_read_timeout))
    return get_read_timeout();
  else
    return __http_read_timeout;
}

##
# set the timeout on a recv call
#
# @param [_FCT_ANON_ARGS[0]:int] timeout in seconds
# @return [int]
##
function http_set_read_timeout()
{
  local_var to;
  local_var old;

  to = _FCT_ANON_ARGS[0];
  old = __http_read_timeout;
  if (isnull(to))
  {
    __http_read_timeout = NULL;
  }
  else if (to <= 0)
  {
    err_print('http_set_read_timeout: invalid timeout ', to, ' - ignored');
  }
  else
  {
    __http_read_timeout = to;
  }
  return old;
}

##
# retrieve the most recent sent
#
# @return [string] previous request string
##
function http_last_sent_request()
{
  return __http_sent_request;
}

##
# set if HTTP will redirect get
#
# @param [_FCT_ANON_ARGS[0]:BOOL] sets __redirect_with_get
# @return [BOOL] the old __redirect_with_get value
##
function http_redirect_with_get()
{
  local_var old;

  old = __redirect_with_get;
  __redirect_with_get = _FCT_ANON_ARGS[0];
  return old;
}

##
# set the global http_incr_timeout_on_err
#
# @param [_FCT_ANON_ARGS[0]:int] value to set to http_incr_timeout_on_err
# @return [int] old value
##
function http_incr_timeout_on_err()
{
  local_var old;

  old = __http_incr_timeout_on_err;
  __http_incr_timeout_on_err = _FCT_ANON_ARGS[0];
  return old;
}

##
# set the global __http_use_async_sock
#
# @param [_FCT_ANON_ARGS[0]:int] value to set __http_use_async_sock
# @return [int] the old value
##
function http_set_async_sock()
{
  local_var old;
  old = __http_use_async_sock;
  __http_use_async_sock = int(_FCT_ANON_ARGS[0]);
  return old;
}
