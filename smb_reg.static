#TRUSTED 8c16ee3994ea94216fe1c47259c9923b2c9abd6ad00fc8f42ee3041f634366ef742848138eff6cd5220ee3c2ad479678cd50b0d0400980a9dd85bdafac9f1961d1daf54120c9ae1f4fc5101f2a9c05ef3853d507433b1b436e32098efdedfdfebdd229b81902b4e3abdb79026631a8c3ee11d430fc99521ec2e584e2c6b9738530dcea7c9af3940590d60bf04a0982d429e404ac8a0d34740ace91912e8b6e774ca94006c51df597e4c990c605e969a09747a0d4497541dca52d95a9c28e8145152bd5d749bb84f38526c8afcba0c4f2548e8fdd7d5811985e9fc0404421b5fb55a5ad1ab14d08619731bc25dc2bb6e78eaa8755fceb93c87299a9993fb0fcdd3366020fdb7f80b87472a876c9401a9040fec74d58d85828aeee071f103507572c14c1721d34c3c1562aeaed1efdd7b0ec1a3e2fc2b4c703cb22ebf11f4568f239a8da3b80546cf8c6e26dc00100e1e7275da37bd39879b4d3a39cee36c43d19a3857317e3f786d402b5b42ae7361320a25ea5b336147af5c896e4a211049f540f46c2399fe236930b35b463eec44e4e7a134ae31994bf0f83cdf682dcb08ad427c6e322d8569aaac5d4abc8ca410008f4dd086009affe285d4c2693399e24c6e2d89681153a254b8bd3d220a91846651d3c27d13af31d1eb7b65d877ed3d82ab91224b2793bd109166d01d917326c6abc24b5fc94dc712c9cea10e12c385af4
#TRUST-RSA-SHA256 1499b8d878c22db150cf92ef20f4478b0720980a9728a0363fd8bf3591d79c767c5d27ef2d8953ca745f883a69c35b2f864794704cdd6e7e39a66af6fb2de6106dee8f3681690b0d028e439ef34495263a7417bb2be3afa0d3d8fa55c36172017a86587436c6385b7ce0640a5a63d7d9161c8d645f7d52e819f5844089708550791b213cb80636641c518c13f6e4eae17505a2959cb5d6a89f7d0ca3ec1ec3958b0782114d0e3f61eb0ab0f20e56342bce2015ece74d0c40f71e329cec666af7cd7ce1357ed58ca77182dd36e75924c4f1024b3208c3d821092dfcb1d1afae9ec06b87f7b306540435a9d89989077328b96bfb5ce8618f9561ad322798e2b7c68897049fd8c60bb1e08ec977a6ec098d1f3a479d9dc0feb17f80c2135d7bbaa9fd5655c41776d2b5793214a8682675039e5391b7d41136173b7f8155d86895a4125f2dbda34cb6c839316e410624cdab7f42f5da742071e0bc856af6075e13ff6038ab019785802f421557f2a344466325a933d288ddf2710141bca2bd41bb2a19a23291a83c970099af709672571a894a63481f51c125b1c051d79e30f5842611b65cb22ee07db3088081ea5dd29c543b71dd1ebdcf8cf5d3a8665912616d8ff65f8819bd074b9287d71ba6e5c7bbf590b144d737e8e6a172728f8e09e66e1bfcfb211821e10b926ecd84f57e3a35db402c8e0df6fa6406df58b27543d59f98
#------------------------------------------------------------------------------
#
# (C) Tenable Network Security, Inc.
#
# This script is released under one of the Tenable Script Licenses and may not
# be used from within scripts released under another license without the
# authorization from Tenable Network Security, Inc.
#
# @NOGPL@
#
# smb_reg.inc
# Revision: 1.21
#

#==================================================================#
# Section 7. Registry API                                          #
#==================================================================#

#---------------------------------------------------------#
# Function    : RegConnectRegistry                        #
# Description : Starts registry service if not already    #
#               started.                                  #
#---------------------------------------------------------#
function startRegistrySVC()
{
  var handle, shandle, status, ret;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Starting registry service');
  handle = OpenSCManager(access_mode:SC_MANAGER_ALL_ACCESS);
  if(isnull(handle))
  {
    dbg::detailed_log(lvl:1, family:'SMB', src:FUNCTION_NAME, msg:
      'Unable to run OpenSCManager successfully');
    return FALSE;
  }

  shandle = OpenService(handle:handle, service:"RemoteRegistry", access_mode:MAXIMUM_ALLOWED);
  if(isnull(shandle))
  {
    dbg::detailed_log(lvl:1, family:'SMB', src:FUNCTION_NAME, msg:
      'Unable to run OpenService successfully');
    return FALSE;
  }
  status = QueryServiceStatus(handle:shandle);
  if(isnull(status))
  {
    dbg::detailed_log(lvl:1, family:'SMB', src:FUNCTION_NAME, msg:
      'Unable to QueryServiceStatus successfully');
    return FALSE;
  }

  if(status[1] == SERVICE_STOPPED)
  {
    ret = StartService(handle:shandle);
    dbg::detailed_log(lvl:1, family:'SMB', src:FUNCTION_NAME, msg:
      'Tried starting service');
    return ret;
  }

  if(status[1] == SERVICE_RUNNING)
  {
    dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
      'Service already running');
    return TRUE;
  }
  else
  {
    dbg::detailed_log(lvl:1, family:'SMB', src:FUNCTION_NAME, msg:
      'Service not running, status is ' + status[1]);
    return FALSE;
  }
}

#---------------------------------------------------------#
# Function    : RegConnectRegistry                        #
# Description : Connects to the remote registry.          #
#               if not hkey connects to HKLM              #
# Return      : ret[0] : registry handle                  #
#               ret[1] : registry pipe                    #
#               ret[2] : 1 (Pipe handle)                  #
#---------------------------------------------------------#

function direct_RegConnectRegistry (hkey)
{
  var fid, ret, data, type, resp, rep, la, delta, vers, rr_opt, name;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Connecting to registry');

  la = get_kb_item("SMB/remote_registry_last_access");
  vers = get_kb_item('SMB/WindowsVersion');
  rr_opt = get_preference("SMB Registry : Start the Registry Service during the scan[checkbox]:Start the registry service during the scan");

  # Remote registry service on Windows 8 / Server 2012 and above
  # shuts down after 10 minutes of inactivity, so we may need to
  # restart it
  if(!isnull(la) && !isnull(vers) && rr_opt == "yes")
  {
    vers = split(vers, sep:".", keep:FALSE);
    if( int(vers[0]) > 6 ||
       (int(vers[0]) == 6 && int(vers[1]) >= 2))
    {
      delta = unixtime() - la;
      if((delta / 60) >= 10)
      {
        if(!startRegistrySVC())
        {
          _debug_smb_null_return(fname:FUNCTION_NAME, label:'startRegistrySVC()');
          return NULL;
        }
      }
    }
  }

  if (isnull (hkey))
    type = HKEY_LOCAL_MACHINE;
  else
    type = hkey;

  fid = bind_pipe (pipe:"winreg", uuid:"338cd001-2244-31f1-aaaa-900038001003", vers:1);
  if (isnull(fid))
  {
    # A service trigger may exist for Remote Registry when a bind call for
    # winreg is made so we'll try binding twice if the first attempt fails
    if (!get_kb_item("SMB/registry_access") && !get_kb_item("SMB/registry_not_accessible"))
    {
      sleep(2);
      fid = bind_pipe (pipe:"winreg", uuid:"338cd001-2244-31f1-aaaa-900038001003", vers:1);
      if (isnull (fid))
      {
        _debug_smb_null_return(fname:FUNCTION_NAME, label:'bind_pipe() (1)');
        return NULL;
      }
    }
    else
    {
      _debug_smb_null_return(fname:FUNCTION_NAME, label:'bind_pipe() (2)');
      return NULL;
    }
  }

  data = raw_dword (d:0x00020000) +
         raw_word (w:0x75A0) +
         raw_word (w:0x0000) +
         raw_dword (d:0x02000000) ; # FULL_ACCESS

  data = dce_rpc_pipe_request(fid:fid, code:type, data:data);
  if (!data)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'dce_rpc_pipe_request()');
    return NULL;
  }

  # response structure :
  # Policy handle (20 bytes)
  # return code (dword)

  rep = dce_rpc_parse_response(fid:fid, data:data);
  if (!rep || (strlen (rep) != 24))
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:24, operator:'is not');
    return NULL;
  }

  resp = get_dword (blob:rep, pos:20);
  if (resp != STATUS_SUCCESS)
  {
    if (resp == ERROR_ACCESS_DENIED)
    {
      name = "the '" + smb_make_registry_hive_text(hivenum:type) + "' hive";
      smb_set_kb_auth_problem(desc:smb_get_problem_description(text:name, op_desc:"connect"));
    }
    _debug_smb_status_not_success(fname:FUNCTION_NAME);
    return NULL;
  }

  replace_kb_item(name:"SMB/remote_registry_last_access", value:unixtime());

  ret = NULL;
  ret[0] = substr (rep, 0, 19);
  ret[1] = fid;
  ret[2] = 1;
  ret[3] = type;

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Connected to registry');
  return ret;
}



#---------------------------------------------------------#
# Function    : _RegOpenKey                               #
# Description : Open the given key                        #
# Return      : ret[0] Key handle                         #
#               ret[1] FID                                #
#               ret[2] reserved                           #
#---------------------------------------------------------#

function _RegOpenKey (handle, key, mode)
{
  var data, resp, rep, name, ret, len;

  session_set_errorcode(code:STATUS_SUCCESS);

  name = cstring (string:key);
  len = strlen(name);

  data = handle[0]                                         + # Handle
  class_parameter (ref_id:0x00020000, name:key, size:TRUE) + # Key Name
  raw_dword (d:0)                                          + # Unknown
  raw_dword (d:mode);                                        # Mask

  data = dce_rpc_pipe_request(fid:handle[1], code:OPNUM_OPENKEY, data:data);
  if (!data)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'dce_rpc_pipe_request()');
    return NULL;
  }

  # response structure :
  # Policy handle (20 bytes)
  # return code (dword)

  rep = dce_rpc_parse_response(fid:handle[1], data:data);
  if (!rep || (strlen (rep) != 24))
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:24, operator:'is not');
    return NULL;
  }

  smb_set_open_reg_name(handle:handle, key:key);

  resp = get_dword (blob:rep, pos:20);
  if (resp != STATUS_SUCCESS)
  {
    if (resp == ERROR_ACCESS_DENIED)
      smb_set_kb_auth_problem(desc:smb_get_problem_description(handle:handle, op_desc:"open"));

    session_set_errorcode(code:resp);
    _debug_smb_status_not_success(fname:FUNCTION_NAME);
    return NULL;
  }

  ret = NULL;
  ret[0] = substr (rep, 0, 19);
  ret[1] = handle[1];
  ret[2] = 0;

  return ret;
}


#---------------------------------------------------------#
# Function    : RegOpenKey                               #
# Description : Open the given key                        #
# Return      : ret[0] Key handle                         #
#               ret[1] FID                                #
#               ret[2] reserved                           #
#---------------------------------------------------------#

function direct_RegOpenKey (handle, key, mode, wow)
{
  var retry, ret;

  retry = 0;

  if (handle[3] == HKEY_LOCAL_MACHINE && get_kb_item("SMB/WoW"))
    retry = 1;

  ret = _RegOpenKey(handle:handle, key:key, mode:mode);

  if (retry && isnull(ret) && isnull(wow))
  {
    var pgrep_match = pgrep(pattern:"^SOFTWARE\\.*", string:key, icase:TRUE);
    # not empty or null
    if (!(isnull(pgrep_match) || strlen(pgrep_match) == 0))
    {
      key = ereg_replace(pattern:"^SOFTWARE\\(.*)", string:key, replace:"SOFTWARE\\Wow6432Node\\\1", icase:TRUE);
      ret = _RegOpenKey(handle:handle, key:key, mode:mode);
    }
  }

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Success');
  return ret;
}


#---------------------------------------------------------#
# Function    : RegQueryInfoKey                           #
# Description : Retrieve key information                  #
# Return      : returns number of values and sub keys     #
#               ret[0] values                             #
#               ret[1] subkeys                            #
#---------------------------------------------------------#

function direct_RegQueryInfoKey (handle)
{
  var data, resp, rep, ret;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Querying key info for handle');

  data = handle[0]          +  # Handle
         raw_word (w:0)     +  # Length
         raw_word (w:0)     +  # Size
         raw_dword (d:0);      # NULL

  data = dce_rpc_pipe_request(fid:handle[1], code:OPNUM_QUERYINFOKEY, data:data);
  if (!data)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'dce_rpc_pipe_request()');
    return NULL;
  }

  # response structure :
  # Class (bad parsed here)
  # num subkeys
  # max subkey len
  # reserved
  # num value
  # max value len
  # max valbuf size
  # secdesc len
  # mod time

  rep = dce_rpc_parse_response(fid:handle[1], data:data);
  if (!rep || (strlen (rep) != 48))
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:48, operator:'is not');
    return NULL;
  }

  resp = get_dword (blob:rep, pos:44);
  if (resp != STATUS_SUCCESS)
  {
    if (resp == ERROR_ACCESS_DENIED)
      smb_set_kb_auth_problem(desc:smb_get_problem_description(handle:handle, op_desc:"query"));
    _debug_smb_status_not_success(fname:FUNCTION_NAME);
    return NULL;
  }

  ret = NULL;
  ret[0] = get_dword (blob:rep, pos:20);
  ret[1] = get_dword (blob:rep, pos:8);
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Success');
  return ret;
}



#---------------------------------------------------------#
# Function    : RegQueryValue                             #
# Description : Retrieve value about key's item           #
# Return      : returns item value                        #
#               ret[0] type                               #
#               ret[1] value                              #
#---------------------------------------------------------#
function direct_RegQueryValue (handle, item)
{
  var data, resp, rep, ret, name, len;
  var ref_id, key_type, key_data, code, max_count, offset, actual_count, pos;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Querying key info for ' + item);

  session_set_errorcode(code:STATUS_SUCCESS);

  if (strlen(item) > 0)
    name = class_parameter (ref_id:0x00020000, name:item, size:TRUE);
  else
    name = raw_word(w:2) + raw_word (w:0) + raw_dword (d:0);  # (default) value does not work with RegQueryValueEx

  data = handle[0] +                                         # Handle
         name +                                              # Class
         buffer_parameter (ref_id:0x00020004, size:0) +      # Reserved
         buffer_parameter (ref_id:0x00020008, size:0xFFFF) + # Offered
         raw_dword (d:0) +                                   # unknown
         raw_dword (d:0) +                                   # unknown
         buffer_parameter (ref_id:0x0002000C, size:0xFFFF) + # Offered
         buffer_parameter (ref_id:0x00020010, size:0);       # Returned

  data = dce_rpc_pipe_request(fid:handle[1], code:OPNUM_QUERYVALUE, data:data);
  if (!data)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'dce_rpc_pipe_request()');
    return NULL;
  }

  rep = dce_rpc_parse_response (fid:handle[1], data:data);
  if (!rep || (strlen (rep) < 16))
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:16, operator:'is not');
    return NULL;
  }

  # Return code
  code = get_dword (blob:rep, pos:strlen(rep)-4);
  if (code != STATUS_SUCCESS)
  {
    session_set_errorcode(code:code);
    if (code == ERROR_ACCESS_DENIED)
      smb_set_kb_auth_problem(desc:smb_get_problem_description(handle:handle, op_desc:"read"));
    _debug_smb_status_not_success(fname:FUNCTION_NAME);
    return NULL;
  }

  # Key Type
  ref_id = get_dword (blob:rep, pos:0);
  key_type = get_dword (blob:rep, pos:4);

  # Key Data
  ref_id = get_dword (blob:rep, pos:8);
  max_count = get_dword (blob:rep, pos:12);
  offset = get_dword (blob:rep, pos:16);
  actual_count = get_dword (blob:rep, pos:20);
  if (strlen(rep) < 24+actual_count+20)
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:24+actual_count+20);
    return NULL;
  }

  pos = 0;

  if ((key_type == REG_SZ) || (key_type == REG_EXPAND_SZ) || (key_type == REG_MULTI_SZ))
  {
    key_data = get_string2 (blob:rep, pos:24, len:actual_count, _type:UNICODE_STRING);
    while ((actual_count % 4) != 0)
    {
      actual_count++;
      pos++;
    }
  }
  else if (key_type == REG_DWORD)
  {
    key_data = get_dword (blob:rep, pos:24);
  }
  else if (key_type == REG_QWORD)
  {
    # These are 64-bit values; we don't fully support this type yet
    # If the QWORD value is over 32 bits, return NULL
    if (get_dword (blob:rep, pos:28) != 0)
    {
      dbg::detailed_log(lvl:1, family:'SMB', src:FUNCTION_NAME, msg:
        'DWORD at blob pos 28 is not 0!');
      return NULL;
    }

    # Otherwise, use get_dword to return least significant 32 bits
    key_data = get_dword (blob:rep, pos:24);
  }
  else
    key_data = substr (rep, 24, 24+actual_count-1);


  ret = NULL;
  ret[0] = key_type;
  ret[1] = key_data;  # we must convert type here

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Retrieved');
  return ret;
}



#---------------------------------------------------------#
# Function    : RegEnumValue                              #
# Description : Retrieve index type and value             #
# Return      : returns key value                         #
#               ret[0] type                               #
#               ret[1] value                              #
#---------------------------------------------------------#

function direct_RegEnumValue (handle, index)
{
  var data, resp, rep, ret, name, len, pos;
  var unknown1, unknown2, ref_id, key_type, key_name, reserved, val, code, len_2;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Enumerating value');
  data = handle[0]  +  # Handle
    raw_dword (d:index)          +  # num
    raw_dword (d:0x20000000)     +  # unknown
    raw_dword (d:0x20000)        +  # Referent ID
    raw_dword (d:0x1000)         +  # unknown
    raw_dword (d:0)              +  # unknown
    raw_dword (d:0)              +  # unknown
    raw_dword (d:0x20004)        +  # Referent ID
    raw_dword (d:0)              +  # Pointer
    raw_dword (d:0)              +  # reserved
    buffer_parameter (ref_id:0x00020008, size:0) +
    buffer_parameter (ref_id:0x0002000C, size:0);

  data = dce_rpc_pipe_request(fid:handle[1], code:OPNUM_ENUMVALUE, data:data);
  if (!data)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'dce_rpc_pipe_request()');
    return NULL;
  }

  rep = dce_rpc_parse_response (fid:handle[1], data:data);
  if (!rep || (strlen (rep) < 24))
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:24);
    return NULL;
  }

  # Key name
  len = get_word (blob:rep, pos:0);
  unknown1 = get_word (blob:rep, pos:2); # 0x200 ?
  ref_id = get_dword (blob:rep, pos:4);
  unknown2 = get_dword (blob:rep, pos:8);
  reserved = get_dword (blob:rep, pos:12);
  len_2 = get_dword (blob:rep, pos:16);

  pos = 20 + len;
  # Extra 2 bytes pad if len_2 odd
  if ((len_2 % 2) == 1)
    pos += 2;

  if (strlen (rep) < pos+32)
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:pos+32);
    return NULL;
  }

  key_name = get_string (blob:rep, pos:20);

  # Key type
  ref_id = get_dword (blob:rep, pos:pos);
  key_type = get_dword (blob:rep, pos:pos+4);
  reserved = get_dword (blob:rep, pos:pos+8);

  # Offered
  ref_id = get_dword (blob:rep, pos:pos+12);
  val = get_dword (blob:rep, pos:pos+16);

  # Returned
  ref_id = get_dword (blob:rep, pos:pos+20);
  val = get_dword (blob:rep, pos:pos+24);

  # Return code
  code = get_dword (blob:rep, pos:pos+28);
  if (code != STATUS_SUCCESS)
  {
    if (code == ERROR_ACCESS_DENIED)
      smb_set_kb_auth_problem(desc:smb_get_problem_description(handle:handle, op_desc:"enumerate"));
    _debug_smb_status_not_success(fname:FUNCTION_NAME);
    return NULL;
  }

  ret = NULL;
  ret[0] = key_type;
  ret[1] = key_name;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Enumerated');
  return ret;
}


#---------------------------------------------------------#
# Function    : RegEnumKey                                #
# Description : Returns key's index name                  #
#---------------------------------------------------------#

function direct_RegEnumKey (handle, index)
{
  var data, resp, rep, ret, name, len, len_2;
  var unknown1, unknown2, ref_id, key_type, key_name, reserved, code, pos;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Enumerating key');
  data = handle[0]  +  # Handle
    raw_dword (d:index)          +  # num
    raw_dword (d:0x20000000)     +  # unknown

    raw_dword (d:0x20000)        +  # Referent ID
    raw_dword (d:0x1000)         +  # unknown
    raw_dword (d:0)              +  # unknown
    raw_dword (d:0)              +  # unknown
    raw_dword (d:0x20004)        +  # Referent ID
    raw_dword (d:0)              +  # Pointer
    raw_dword (d:0)              +  # reserved
    raw_dword (d:0) ;               # reserved

  data = dce_rpc_pipe_request (fid:handle[1], code:OPNUM_ENUMKEY, data:data);
  if (!data)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'dce_rpc_pipe_request()');
    return NULL;
  }

  rep = dce_rpc_parse_response (fid:handle[1], data:data);
  if (!rep || (strlen (rep) < 24))
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:24);
    return NULL;
  }

  # Key name
  len = get_word (blob:rep, pos:0);
  unknown1 = get_word (blob:rep, pos:2); # 0x200 ?
  ref_id = get_dword (blob:rep, pos:4);
  unknown2 = get_dword (blob:rep, pos:8);
  reserved = get_dword (blob:rep, pos:12);
  len_2 = get_dword (blob:rep, pos:16);

  pos = 20 + len;
  # Extra 2 bytes pad if len_2 odd
  if ((len_2 % 2) == 1)
    pos += 2;

  if (strlen (rep) < pos+20)
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:pos+20);
    return NULL;
  }

  key_name = get_string (blob:rep, pos:20);

  #Returned
  ref_id = get_dword (blob:rep, pos:pos);
  reserved = get_dword (blob:rep, pos:pos+4);
  reserved = get_dword (blob:rep, pos:pos+8);
  reserved = get_dword (blob:rep, pos:pos+12);

  # Return code
  code = get_dword (blob:rep, pos:pos+16);
  if (code != STATUS_SUCCESS)
  {
    if (code == ERROR_ACCESS_DENIED)
      smb_set_kb_auth_problem(desc:smb_get_problem_description(handle:handle, op_desc:"enumerate"));

    _debug_smb_status_not_success(fname:FUNCTION_NAME);
    return NULL;
  }

  ret = key_name;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Enumerated key: ' + ret);
  return ret;
}



#---------------------------------------------------------#
# Function    : RegCloseKey                               #
# Description : Close key handle                          #
# Return      : 1 on success                              #
#---------------------------------------------------------#

function direct_RegCloseKey (handle)
{
  var data, rep, code, ret;

  code = NULL;

  data = dce_rpc_pipe_request (fid:handle[1], code:OPNUM_CLOSEKEY, data:handle[0]);
  if (data)
  {
    rep = dce_rpc_parse_response (fid:handle[1], data:data);
    if (rep && (strlen (rep) == 24))
    {
      # NULL handle (useless) + code
      # Return code
      code = get_dword (blob:rep, pos:20);
    }
  }

  if (handle[2] == 1)
    ret = smb_close (fid:handle[1]);

  if (isnull (code) || (code != STATUS_SUCCESS) || (ret != 1))
  {
    if (code == ERROR_ACCESS_DENIED)
      smb_set_kb_auth_problem(desc:smb_get_problem_description(handle:handle, op_desc:"close"));
    _debug_smb_status_not_success(fname:FUNCTION_NAME);
    return NULL;
  }

  smb_set_open_reg_name(handle:handle, key:NULL);
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Closed key');
  return 1;
}



#---------------------------------------------------------#
# Function    : RegGetKeySecurity                         #
# Description : Return Key Security Descriptor            #
# Type        : xxx_SECURITY_INFORMATION                  #
#               xxx = DACL, SACL, GROUP, OWNER            #
#               | to use multiple level                   #
#---------------------------------------------------------#

function direct_RegGetKeySecurity (handle, type)
{
  var data, rep, ret, len, code, ref_id, offset, size, unknown, sec_desc, size2;
  var length, max_count, actual_count;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Getting key security descriptor');

  data = handle[0] +
    raw_dword (d:type) +
    raw_dword (d:0)    + # Referent ID;
    raw_dword (d:0)    + # Length
    raw_dword (d:0)    + # Offset
    raw_dword (d:0xFFFFFFFF) ;    # Size

  data = dce_rpc_pipe_request (fid:handle[1], code:OPNUM_GETKEYSECURITY, data:data);
  if (!data)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'dce_rpc_pipe_request()');
    return NULL;
  }

  rep = dce_rpc_parse_response (fid:handle[1], data:data);
  if (!rep || (strlen (rep) < 16))
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:16);
    return NULL;
  }

  # Referent ID
  # length
  # offset
  # return code

  ref_id = get_dword (blob:rep, pos:0);
  len = get_dword (blob:rep, pos:4);
  offset = get_dword (blob:rep, pos:8);
  code = get_dword (blob:rep, pos:strlen(rep)-4);
  if (code != ERROR_INSUFFICIENT_BUFFER)
  {
    _debug_smb_status_not_success(fname:FUNCTION_NAME, status:'error insufficient buffer');
    return NULL;
  }

  # Now we do the same request but with the length of our allowed buffer (useless in fact with nasl)

  data = handle[0]           +
    raw_dword (d:type)       +
    raw_dword (d:0x20000)    + # Referent ID;
    raw_dword (d:len)        + # Length
    raw_dword (d:0)          + # Offset
    raw_dword (d:len)        + # Size
    raw_dword (d:0)          + # reserved
    raw_dword (d:0) ;          # reserved

  data = dce_rpc_pipe_request (fid:handle[1], code:OPNUM_GETKEYSECURITY, data:data);
  if (!data)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'dce_rpc_pipe_request()');
    return NULL;
  }

  rep = dce_rpc_parse_response (fid:handle[1], data:data);
  if (!rep || (strlen (rep) < 24))
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:24);
    return NULL;
  }

  # Referent ID
  # length
  # offset
  # return code

  ref_id = get_dword (blob:rep, pos:0);
  len = get_dword (blob:rep, pos:4);
  size = get_dword (blob:rep, pos:8);
  actual_count = get_dword (blob:rep, pos:12);
  offset = get_dword (blob:rep, pos:16);
  max_count = get_dword (blob:rep, pos:20);

  if (strlen (rep) < 24+len+4)
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:24+len+4);
    return NULL;
  }

  sec_desc = substr (rep, 24, 24+len-1);
  sec_desc = parse_security_descriptor (blob:sec_desc);

  code = get_dword (blob:rep, pos:24+len);
  if (code != STATUS_SUCCESS)
  {
    if (code == ERROR_ACCESS_DENIED)
      smb_set_kb_auth_problem(desc:smb_get_problem_description(handle:handle, op_desc:"security"));
    _debug_smb_status_not_success(fname:FUNCTION_NAME);
    return NULL;
  }

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Success');
  return sec_desc;
}


#---------------------------------------------------------#
# Function    : RegCreateKey                              #
# Description : Create key / subkeys                      #
# Return      : ret[0] Key handle                         #
#               ret[1] FID                                #
#               ret[2] reserved                           #
#                                                         #
#               NULL if error                             #
#---------------------------------------------------------#

function direct_RegCreateKey (handle, key, mode)
{
  var data, resp, rep, ret, name, len, code;

  session_set_errorcode(code:STATUS_SUCCESS);

  name = class_parameter (ref_id:0x00020000, name:key, size:TRUE);

  data = handle[0] +           # Handle
         name +                # Subkey
         raw_dword (d:0) +     # Class
         raw_dword (d:0) +     # Options
         raw_dword (d:0) +     # unknown
         raw_dword (d:mode) +  # Mask
         raw_dword (d:0) +     # Secdesc
         buffer_parameter (ref_id:0x00020004, size:0); # Action taken

  data = dce_rpc_pipe_request (fid:handle[1], code:OPNUM_CREATEKEY, data:data);
  if (!data)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'dce_rpc_pipe_request()');
    return NULL;
  }

  # Handle is returned
  rep = dce_rpc_parse_response (fid:handle[1], data:data);
  if (!rep || (strlen (rep) < 24))
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:24);
    return NULL;
  }

  # Return code
  code = get_dword (blob:rep, pos:strlen(rep)-4);
  if (code != STATUS_SUCCESS)
  {
   if (code == ERROR_ACCESS_DENIED)
     smb_set_kb_auth_problem(desc:smb_get_problem_description(handle:handle, op_desc:"create"));

    session_set_errorcode(code:code);
    _debug_smb_status_not_success(fname:FUNCTION_NAME);
    return NULL;
  }

  ret = NULL;
  ret[0] = substr (rep, 0, 19);
  ret[1] = handle[1];
  ret[2] = 0;

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Created');
  return ret;
}


#---------------------------------------------------------#
# Function    : RegSetValue                               #
# Description : Create value and its associated data      #
# Return      : TRUE if successful                        #
#               NULL if an error occurred                 #
#---------------------------------------------------------#

function direct_RegSetValue (handle, value, type, value_data)
{
  var data, rep, value_encoded, value_data_encoded, value_data_len, code;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Trying to set registry value of ' + value + ' to ' + value_data);
  session_set_errorcode(code:STATUS_SUCCESS);

  value_encoded = class_parameter (ref_id:0x00020000, name:value, size:TRUE);
  value_data_encoded = cstring(string:value_data);
  value_data_len = strlen(value_data_encoded);

  data = handle[0] +                    # Handle
         value_encoded +                # Value
         raw_dword (d:type) +           # Type
         raw_dword (d:value_data_len) + # Max Count
         value_data_encoded +           # Data
         raw_byte (b:0) +               # unknown
         raw_byte (b:0) +               # unknown
         raw_dword (d:value_data_len);  # Size

  data = dce_rpc_pipe_request (fid:handle[1], code:OPNUM_SETVALUE, data:data);
  if (!data)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'dce_rpc_pipe_request()');
    return NULL;
  }

  rep = dce_rpc_parse_response (fid:handle[1], data:data);
  if (!rep)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'dce_rpc_parse_response()');
    return NULL;
  }

  # Return code
  code = get_dword (blob:rep, pos:strlen(rep)-4);
  if (code != STATUS_SUCCESS)
  {
   if (code == ERROR_ACCESS_DENIED)
     smb_set_kb_auth_problem(desc:smb_get_problem_description(handle:handle, op_desc:"set"));

    session_set_errorcode(code:code);
    _debug_smb_status_not_success(fname:FUNCTION_NAME);
    return NULL;
  }

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Set successfully');
  return TRUE;
}


##
# hive_int2str
#
# converts the integer representation of a registry hive to its string
# equivalent. e.g. hive_int2str(HKEY_LOCAL_MACHINE) returns the string
# 'HKEY_LOCAL_MACHINE'
#
# @param  int  int constant representing the desired hive
# @return the string name of the registry hive if 'int' is valid, or
#         NULL otherwise
##
function hive_int2str()
{
  var int, str;
  int = _FCT_ANON_ARGS[0];

  if (int == HKEY_LOCAL_MACHINE)
    str = 'HKEY_LOCAL_MACHINE';
  else if (int == HKEY_CURRENT_USER)
    str = 'HKEY_CURRENT_USER';
  else if (int == HKEY_USERS)
    str = 'HKEY_USERS';
  else if (int == HKEY_CLASS_ROOT)
    str = 'HKEY_CLASS_ROOT';
  else
    str = NULL;

  return str;
}

function reg_opnum_to_hkey()
{
  var opnum;

  opnum = _FCT_ANON_ARGS[0];

  if (opnum == HKEY_CLASS_ROOT)         # opnum 0
    return 0x80000000;
  else if (opnum == HKEY_CURRENT_USER)  # opnum 1
    return 0x80000001;
  if(opnum == HKEY_LOCAL_MACHINE)       # opnum 2
    return 0x80000002;
  else if (opnum == 3)                  # OpenPerformanceData
    return 0x80000004;
  else if (opnum == HKEY_USERS)         # opnum 4
    return 0x80000003;
  else if (opnum == 27)                 # OpenCurrentConfig
    return 0x80000005;
  else if (opnum == 32)                 # OpenPerformanceText
    return 0x80000050;
  else if (opnum == 33)                 # OpenPerformanceNlsText
    return 0x80000060;
  else
  {
    dbg::detailed_log(lvl:1, family:'SMB', src:FUNCTION_NAME, msg:
      'opcode not recognized!');
    return NULL;
  }
}
