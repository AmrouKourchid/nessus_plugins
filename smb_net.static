#TRUSTED 1425d0fd7ceefcec301dd6bc8071745b155dc1606ced112c78d6398ca8ad7c0ed07577febeda1ad63351344883acd3466cc58b79fedf7f7a5c784c5d83e105c383f1393d7ed817f3a995968e9290935ba61dc9f7198748aa404b41426636f0c883c8a99c8f1c900ca1beb7276fe02e44675b0e851c9e8cb1952d65008925d16d27a6ebdc5d0f35226bc441f0e23361be5b4a5927c5723c5404fff52dd66348af4563453ec212932e711b0abe0810820f3f5996f2a674966033ea1de8406f4cb08b383c416fbb048d24710ed92dc45b3c0534be6b6399ad214011c4df04c940290bbb064af9cfebe117b62564041e9f68f30543f583c1ad8debe1cc5aad087d504286b8061c4d3b9b83678e66a632e645ba8baad60488cea3bd4e590dd1968c6919aaa4e281325871b66ae1e22c889ec5194b5853f714ec00f42823af87c0e74fbd2d580dfeaeb22ea9351aa736269a7266586d0d5c4c2b0702588530161ee9a337cd8f8f699fdcbbbfa8d9850738639d6effc8b702b8928d524c25e4920d74742dfe98c633651321985fa2dc853167d1f838b85cb9b8e5396a80c427604364ef4caa216a10742af4dbe4bc468138b8dfeb45ecfaa3a6682ee11252bf903381e4cd8a5ba2f144e02dc82acc348067fee01eabc9c707c5533fec48d250fbd4b12abd47f4659b1b7c45d7d528c456d047d6880e41f42eb840ce0ef4ef76d07c695c
#TRUST-RSA-SHA256 87ad2dc7608f816def01f49102d1e2fabe0fb45645bf63e7011bd6dc8eb271394728708f8d33fb6cb30f7ba3a3defcf89cd22dcd274b45690557dff8fd64a8895abdd8ead7171b90f33e3307d8b4329a9cff9569249b967a22a95428d10f72226f014e319fd75c177f733b246ce0236cd555d4f22f50e266c3a4b9f6c22a67727f5042e15200477a494efd7d92c89f661c816067119b52664d121c23a5e6922542bde3a1b715ed88d86fe55d1d32085781b5623830e330720e32c3bef68b4affba09f1dc42516fbfce7958bcb35f6e4c8d4fb61bc5d5cfb592913a9c8e33c5a01175108e6463544ac943b09c2c6acd45da2ff50591f8e187c5951894f5625548c3c91bd13accafd4b146b56057c10513f5186512800b8c16491f5dc53ce9717a204b9f53a0499f39cbe1b570ceba63fbe3b17c4ad58a9d1a3c1f2a26bfc331d4f6f86e98f30a6d40a485ea62bb5e1357f2f115fcb3023d093d6728fd0c56f0e4441de2ecbc00464f194be799ab6fcdca81e63b4b937bc6402d3efcf3cd41e7dde80efa7ec9689f1b3c977ddba80beb70e8d92482f04b291a425e8a489e55157ba11bb7eee4b6859feec6d73a4eb64fb21878e6de59415b64dc519dcc0af9b27283d0c9246f95ca38daa165c23ce945bdbf1e9dbe43f4ffef5c33c3d5792c51b916a6ef5b3ba4daa5b0d71e0f7fefb9c492a1e09a7850ea110a6de556a171f8cd
#------------------------------------------------------------------------------
#
# (C) Tenable Network Security, Inc.
#
# This script is released under one of the Tenable Script Licenses and may not
# be used from within scripts released under another license without the
# authorization from Tenable Network Security, Inc.
#
# @NOGPL@
#
# smb_net.inc
# Revision: 1.20
#

#==================================================================#
# Section 6b. Network Management API                               #
#==================================================================#



function NetGetInfo (pipe, uuid, vers, level, opnum)
{
  var fid, data, rep, resp, info_level, info_struct, ret;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Running NetGetInfo');

  fid = bind_pipe (pipe:pipe, uuid:uuid, vers:vers);
  if(isnull(fid))
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'bind_pipe()');
    return NULL;
  }

  data = class_parameter (ref_id:0x00020000, name:"\\" + session_get_hostname ()) +
    raw_dword (d:level) ;      # Info level

  data = dce_rpc_pipe_request(fid:fid, code:opnum, data:data);
  if (!data)
  {
    smb_close (fid:fid);
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'dce_rpc_pipe_request()');
    return NULL;
  }

  # response structure :
  # Policy handle (20 bytes)
  # return code (dword)

  rep = dce_rpc_parse_response(fid:fid, data:data);
  if (!rep || (strlen (rep) < 8))
  {
    smb_close (fid:fid);
    _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:8);
    return NULL;
  }

  info_level = get_dword (blob:rep, pos:0);
  info_struct = substr (rep, 4, strlen(rep) - 5);

  resp = get_dword (blob:rep, pos:strlen(rep) - 4);
  if (resp != STATUS_SUCCESS)
  {
    smb_close (fid:fid);
    _debug_smb_status_not_success(fname:FUNCTION_NAME);
    return NULL;
  }

  ret = NULL;
  ret[0] = info_level;
  ret[1] = info_struct;

  smb_close (fid:fid);

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Returning NetGetInfo');
  return ret;
}



function NetEnum (pipe, level, uuid, vers, opnum)
{
  var fid, name, len, data, rep, resp, ret;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Running NetEnum');

  fid = bind_pipe (pipe:pipe, uuid:uuid, vers:vers);
  if(isnull(fid))
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'bind_pipe()');
    return NULL;
  }

  data = class_parameter (ref_id:0x00020000, name:"\"+session_get_hostname()) +
    raw_dword (d:level)      + # Info level
    # share info container
    raw_dword (d:level)      + # Share Info level (multi share request with different level ?)
    raw_dword (d:0x00020004) + # Referent ID
    raw_dword (d:0)          + # number of entries
    raw_dword (d:0)          + # share info array (NULL)
    raw_dword (d:0xFFFFFFFF) + # preferred length
    # Enum handle
    buffer_parameter (ref_id:0x00020008, size:0);

  data = dce_rpc_pipe_request (fid:fid, code:opnum, data:data);
  if (!data)
  {
    smb_close (fid:fid);
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'dce_rpc_pipe_request()');
    return NULL;
  }

  # response structure :
  # Policy handle (20 bytes)
  # return code (dword)

  rep = dce_rpc_parse_response (fid:fid, data:data);
  if (!rep || (strlen (rep) < 24))
  {
    smb_close (fid:fid);
    _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:24);
    return NULL;
  }

  resp = get_dword (blob:rep, pos:strlen(rep) - 4);
  if (resp != STATUS_SUCCESS)
  {
    smb_close (fid:fid);
    _debug_smb_status_not_success(fname:FUNCTION_NAME);
    return NULL;
  }

  ret = substr (rep, 0, strlen(rep)-4-1);

  smb_close (fid:fid);

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Returning NetEnum');
  return ret;
}




#---------------------------------------------------------#
# Function    : NetUseAdd                                 #
# Description : Connects to the remote share.             #
#               If no share is specified authenticates    #
#               for future use (anonymous if no login)    #
# Return      : Return 1 on success                       #
#                     -1 if login failed                  #
#                      0 if share connection failed       #
#---------------------------------------------------------#

function direct_NetUseAdd (login,password,domain,share,lm_hash,ntlm_hash)
{
  var ret, p_type;
  var pref;

  p_type = get_kb_item("SMB/password_type");

  if (password &&  p_type > 0)
  {
    if (password == get_kb_item("SMB/password"))
    {
      if (p_type == 1)
      {
        lm_hash = hex2raw2(s:tolower(password));
        ntlm_hash = password = NULL;
      }
      else
      {
        ntlm_hash = hex2raw2(s:tolower(password));
        lm_hash = password = NULL;
      }
    }
  }

  if (!session_is_authenticated ())
  {
    if (netbios_session_request () != TRUE)
    {
      smb_set_auth_failure(login:login, desc:'netbios_session_request() failed.');
      return -1;
    }

    if (smb_login (login:login, password:password, domain:domain, lm_hash:lm_hash, ntlm_hash:ntlm_hash) != 1)
      return -1;
    else
      session_set_authenticated();
  }

  if (!isnull (share))
  {
    #
    # Allow a user to rename the C$ to something else,
    # depending on their environment. Use with care.
    #
    if ( share == "C$" )
    {
      pref = get_preference("smb_c_share");
      if ( strlen(pref) > 0 )
      {
        ret = smb_tree_connect_and_x (share:pref);
        if ( ret ) return 1;
      }
    }
    ret = smb_tree_connect_and_x (share:share);
    if (!ret)
    {
      dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
        'NetUseAdd failure');
      return 0;
    }
  }

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'NetUseAdd success');
  return 1;
}



#---------------------------------------------------------#
# Function    : NetUseDel                                 #
# Description : Delete connection to the remote share.    #
# Optional    : close. If close == TRUE or not specified  #
#                      logoff and close socket            #
#---------------------------------------------------------#

function direct_NetUseDel (close)
{
  var soc;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Trying NetUseDel');

  if (smb_tree_disconnect () != 1)
  {
    # smb_tree_disconnect() failed - close the socket anyways
    if ( isnull(close) || ( close == TRUE ) )
    {
      soc = session_get_socket();
      if(soc) close(soc);
    }
    return -1;
  }

  if (isnull(close) || (close == TRUE))
  {
    if (session_is_authenticated ())
    {
      smb_logoff_andx ();
    }
    soc = session_get_socket();
    if(soc) close(soc);
  }

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'NetUseDel success');
  return 1;
}

function msrpc_unmarshal_ustring(blob, pos)
{
  var actual_count, blen, ret, ustr;

  blen = strlen(blob);

  # 4-byte alignment
  if(pos % 4) pos += (4 - pos % 4);

  if(pos + 12 > blen)
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'blen', length:pos+12);
    return NULL;
  }

  actual_count = get_dword (blob:blob, pos: pos + 8) * 2;
  if (pos + 12 + actual_count > blen)
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'blen', length:pos + 12 + actual_count);
    return NULL;
  }

  # C706 says string must be NULL-terminated
  if(actual_count == 2)
    ustr = '';
  else
    ustr = get_string2 (blob:blob, pos:pos+12, len:actual_count, _type:UNICODE_STRING);
  pos += 12 + actual_count;

  ret = NULL;
  ret['ustr'] = ustr;
  ret['next'] = pos;

  return ret;
}

#-----------------------------------------------------------#
# Function    : NetServerGetInfo                            #
# Description : Return host information                     #
# Return      : array of level info                         #
#               [0] = platform_id (DWORD)                   #
#               [1] = hostname (STRING)                     #
#               [2] = major version(DWORD) - level 101-102  #
#               [3] = minor version(DWORD) - level 101-102  #
#               [4] = type (DWORD)         - level 101-102  #
#               [5] = comment (STRING)     - level 101-102  #
#               [6] = users (DWORD)        - level 102      #
#               [7] = disc (LONG)          - level 102      #
#               [8] = hidden (DWORD)       - level 102      #
#               [9] = announce (DWORD)     - level 102      #
#               [10] = anndelta (DWORD)    - level 102      #
#               [11] = licenses (DWORD)    - level 102      #
#               [12] = userpath (STRING)   - level 102      #
#-----------------------------------------------------------#

function direct_NetServerGetInfo (level)
{
  var actual_count, ret, rep, ref_id, pos;
  var announce, anndelta, comment, disc, hidden, hostname, licenses;
  var major, minor, platform_id, type, users, userpath;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Trying NetServerGetInfo');

  # Check level
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Level is ' + level);
  if ((level != 100) && (level != 101) && (level != 102))
  {
    dbg::detailed_log(lvl:1, family:'SMB', src:FUNCTION_NAME, msg:
      'Level is not 100-102!');
    return NULL;
  }

  ret = NetGetInfo(pipe:"srvsvc", uuid:"4b324fc8-1670-01d3-1278-5a47bf6ee188", vers:3, level:level, opnum:OPNUM_SERVERGETINFO);

  if(isnull(ret))
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'NetGetInfo()');
    return NULL;
  }
  rep = ret[1];

  if (strlen(rep) < 24)
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'NetGetInfo() return', length:24);
    return NULL;
  }

  pos = 0;
  pos += 4; # skip ref_id for the struct
  platform_id = get_dword (blob:rep, pos: pos); pos += 4;

  pos += 4; # skip ref_id for hostname
  if (level >= 101)
  {
    if(pos + 16 > strlen(rep))
    {
      _debug_smb_length(fname:FUNCTION_NAME, varname:'NetGetInfo() return', length:pos+16);
      return NULL;
    }
    major = get_dword (blob:rep, pos: pos); pos += 4;
    minor = get_dword (blob:rep, pos: pos); pos += 4;
    type  = get_dword (blob:rep, pos: pos); pos += 4;
    pos += 4; # skip ref_id for comment
  }
  if (level == 102)
  {
    if(pos + 28 > strlen(rep))
    {
      _debug_smb_length(fname:FUNCTION_NAME, varname:'NetGetInfo() return', length:pos+28);
      return NULL;
    }
    users   = get_dword (blob:rep, pos: pos); pos += 4;
    disc    = get_dword (blob:rep, pos: pos); pos += 4;
    hidden  = get_dword (blob:rep, pos: pos); pos += 4;
    announce = get_dword (blob:rep, pos: pos); pos += 4;
    anndelta = get_dword (blob:rep, pos: pos); pos += 4;
    licenses = get_dword (blob:rep, pos: pos); pos += 4;

    pos += 4; # skip ref_id for userpath
  }

  # Get hostname
  ret = msrpc_unmarshal_ustring(blob: rep, pos: pos);
  if(isnull(ret))
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'msrpc_unmarshal_ustring()');
    return NULL;
  }
  hostname = ret['ustr'];
  pos = ret['next'];

  # Get comment
  if(level >= 101)
  {
    ret = msrpc_unmarshal_ustring(blob: rep, pos: pos);
    if(isnull(ret))
    {
      _debug_smb_null_return(fname:FUNCTION_NAME, label:'msrpc_unmarshal_ustring() (2)');
      return NULL;
    }
    comment = ret['ustr'];
    pos = ret['next'];
  }

  # Get userpath
  if(level == 102)
  {
    ret = msrpc_unmarshal_ustring(blob: rep, pos: pos);
    if(isnull(ret))
    {
      _debug_smb_null_return(fname:FUNCTION_NAME, label:'msrpc_unmarshal_ustring() (3)');
      return NULL;
    }
    userpath = ret['ustr'];
    pos = ret['next'];
  }

  ret = NULL;
  ret[0] = platform_id;
  ret[1] = hostname;
  if(level >= 101)
  {
    ret[2] = major;
    ret[3] = minor;
    ret[4] = type;
    ret[5] = comment;
  }
  if (level == 102)
  {
    ret[6]  = users;
    ret[7]  = disc;
    ret[8]  = hidden;
    ret[9]  = announce;
    ret[10] = anndelta;
    ret[11] = licenses;
    ret[12] = userpath;
  }

  dbg::detailed_log(
    lvl:3,
    family:'SMB',
    src:FUNCTION_NAME,
    msg:'NetServerGetInfo response',
    msg_details:{
      "Return":{"lvl":3, "value":obj_rep(ret)}
    });
  return ret;
}



#---------------------------------------------------------#
# Function    : NetWkstaGetInfo                           #
# Description : Return workstation information            #
# Return      : array of level info                       #
#               [0] = platform_id (DWORD)                 #
#               [1] = hostname (STRING)                   #
#               [2] = domainname (STRING)                 #
#               [3] = major (DWORD)                       #
#               [4] = minor (DWORD)                       #
#               [5] = lanroot (STRING) - level 101-102    #
#               [6] = logged users (DWORD) - level 102    #
#---------------------------------------------------------#

function direct_NetWkstaGetInfo (level)
{
  var ret, ref_id, rep, platform_id, major, minor, pos, logged, hostname, domainname, lanrootname, actual_count;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Trying NetWkstaGetInfo');

  ret = NetGetInfo(pipe:"wkssvc", uuid:"6bffd098-a112-3610-9833-46c3f87e345a", vers:1, level:level, opnum:OPNUM_WKSTAGETINFO);
  if (isnull(ret))
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'NetGetInfo()');
    return NULL;
  }

  level = ret[0];
  rep = ret[1];

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Level is ' + level);
  if ((level != 100) && (level != 101) && (level != 102))
  {
    dbg::detailed_log(lvl:1, family:'SMB', src:FUNCTION_NAME, msg:
      'Level is not 100-102!');
    return NULL;
  }

  if (strlen(rep) < 24)
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'NetGetInfo() return', length:24);
    return NULL;
  }

  ref_id = get_dword (blob:rep, pos:0);
  platform_id = get_dword (blob:rep, pos:4);
  # server_id = get_dword (blob:rep, pos:8);
  # host_id = get_dword (blob:rep, pos:12);
  major = get_dword (blob:rep, pos:16);
  minor = get_dword (blob:rep, pos:20);
  pos = 24;
  if (level >= 101)
  {
    # lan_id = get_dword (blob:rep, pos:pos);
    pos += 4;
  }
  if (level == 102)
  {
    if (strlen(rep) < 36)
    {
      _debug_smb_length(fname:FUNCTION_NAME, varname:'NetGetInfo() return', length:36);
      return NULL;
    }
    logged = get_dword (blob:rep, pos:pos);
    pos += 4;
  }

  # Wksta is unicode

  # hostname
  if (strlen(rep) < pos + 12 + 4)
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'NetGetInfo() return', length:pos + 16);
    return NULL;
  }
  actual_count = get_dword(blob:rep, pos:pos+8) * 2;
  if (strlen(rep) < pos + actual_count + 4)
  {
   _debug_smb_length(fname:FUNCTION_NAME, varname:'NetGetInfo() return', length:pos + actual_count + 4);
    return NULL;
  }
  hostname = get_string2 (blob:rep, pos:pos+12, len:actual_count, _type:UNICODE_STRING);
  pos += actual_count + 12;
  if (actual_count%4)
    pos += 2;

  # Domain name
  if (strlen(rep) < pos + 12 + 4)
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'NetGetInfo() return', length:pos + 16);
    return NULL;
  }
  actual_count = get_dword(blob:rep, pos:pos+8) * 2;
  if (strlen(rep) < pos + actual_count + 4)
  {
   _debug_smb_length(fname:FUNCTION_NAME, varname:'NetGetInfo() return', length:pos + actual_count + 4);
    return NULL;
  }
  domainname = get_string2 (blob:rep, pos:pos+12, len:actual_count, _type:UNICODE_STRING);
  pos += actual_count + 12;
  if (actual_count%4)
    pos += 2;

  if (level >= 101)
  {
    # Lan root
    if (strlen(rep) < pos + 12 + 4)
    {
      _debug_smb_length(fname:FUNCTION_NAME, varname:'NetGetInfo() return', length:pos + 16);
      return NULL;
    }
    actual_count = get_dword(blob:rep, pos:pos+8) * 2;
    if (strlen(rep) < pos + actual_count + 4)
    {
     _debug_smb_length(fname:FUNCTION_NAME, varname:'NetGetInfo() return', length:pos + actual_count + 4);
      return NULL;
    }
    lanrootname = get_string2 (blob:rep, pos:pos+12, len:actual_count, _type:UNICODE_STRING);
    pos += actual_count + 12;
    if (actual_count%4)
      pos += 2;
  }

  ret = NULL;
  ret[0] = platform_id;
  ret[1] = hostname;
  ret[2] = domainname;
  ret[3] = major;
  ret[4] = minor;
  if (level >= 101)
    ret[5] = lanrootname;
  if (level == 102)
    ret[6] = logged;

  dbg::detailed_log(
    lvl:3,
    family:'SMB',
    src:FUNCTION_NAME,
    msg:'NetWkstaGetInfo response',
    msg_details:{
      "Return":{"lvl":3, "value":obj_rep(ret)}
    });
  return ret;
}


#---------------------------------------------------------#
# Function    : NetSessionEnum                            #
# Description : Return session information                #
#---------------------------------------------------------#

function direct_NetSessionEnum (level, computer, user)
{
  var fid, name, len, data, rep, resp, ret, comp, _user;
  var entries, i, lev, sess_list,  max_count, pos, sess_info, tlist;
  var cname, username, cltype_name, total_entries, transport;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Trying NetSessionEnum');

  if (!isnull(computer))
    comp = class_parameter (ref_id:0x00020004, name:computer);
  else
    comp = raw_dword (d:0);

  if (!isnull(user))
    _user = class_parameter (ref_id:0x00020008, name:user);
  else
    _user = raw_dword (d:0);

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Level is ' + level);
  if(level != 0 && level !=1 && level != 2 && level != 10 && level != 502)
  {
    dbg::detailed_log(lvl:1, family:'SMB', src:FUNCTION_NAME, msg:
      'Level is not 0, 1, 2, 10, or 502');
    return NULL;
  }

  fid = bind_pipe(pipe:"srvsvc", uuid:"4b324fc8-1670-01d3-1278-5a47bf6ee188", vers:3);

  if(isnull(fid))
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'bind_pipe()');
    return NULL;
  }

  data = class_parameter (ref_id:0x00020000, name:"\"+session_get_hostname()) +
         comp                     + # computer name
         _user                    + # user name
         raw_dword (d:level)      + # Info level
         # share info container
         raw_dword (d:level)      + # Share Info level (multi share request with different level ?)
         raw_dword (d:0x00020004) + # Referent ID
         raw_dword (d:0)          + # number of entries
         raw_dword (d:0)          + # share info array (NULL)
         raw_dword (d:0xFFFFFFFF) + # preferred length
         # Enum handle
         buffer_parameter (ref_id:0x00020008, size:0);

  data = dce_rpc_pipe_request(fid:fid, code:OPNUM_NETSESSENUM, data:data);
  if (!data)
  {
    smb_close (fid:fid);
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'dce_rpc_pipe_request()');
    return NULL;
  }

  # response structure :
  # Policy handle (20 bytes)
  # return code (dword)

  rep = dce_rpc_parse_response(fid:fid, data:data);
  if (!rep || (strlen (rep) < 24))
  {
    smb_close (fid:fid);
    _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:24);
    return NULL;
  }

  resp = get_dword (blob:rep, pos:strlen(rep) - 4);
  if (resp != STATUS_SUCCESS)
  {
    smb_close (fid:fid);
    _debug_smb_status_not_success(fname:FUNCTION_NAME);
    return NULL;
  }

  data = substr (rep, 0, strlen(rep)-4-1);

  smb_close (fid:fid);

  # Parse return data
  pos = 0;
  lev = get_dword (blob:data, pos:pos); pos += 4;

  if(lev != level)
  {
    dbg::detailed_log(lvl:1, family:'SMB', src:FUNCTION_NAME, msg:
      'Level is ' + lev + ' and not expected level ' + level + '!');
    return NULL;
  }
  pos +=4; # Skip switch_is(level);
  pos += 4; # Skip ref_id for SESSION_INFO_XXX_CONTAINER

  # Number of entires read
  entries = get_dword (blob:data, pos:pos); pos += 4;

  pos += 4; # Skip ref_id for SESSION_INFO_XXX

  max_count = get_dword (blob:data, pos:pos); pos += 4;
  if(max_count != entries)
  {
    dbg::detailed_log(lvl:1, family:'SMB', src:FUNCTION_NAME, msg:
      'Max Count ' + max_count + ' is not the number of entries, ' + entries + '!');
    return NULL;
  }

  for (i = 0; i < entries; i++)
  {
    pos += 4; # Skip ref_id for cname

    # levels 1, 2, 10, 502
    if(level > 0)
    {
      pos += 4; # Skip ref_id for username
      sess_info[2] =  get_dword (blob:data, pos:pos); pos += 4;
      sess_info[3] =  get_dword (blob:data, pos:pos); pos += 4;

      # levels 1, 2, 502
      if(level != 10)
      {
        sess_info[4] =  get_dword (blob:data, pos:pos); pos += 4;
        sess_info[5] =  get_dword (blob:data, pos:pos); pos += 4;

        # levels 2, 502
        if(level != 1)
        {
          pos += 4; # Skip ref_id for cltype_name
          if(level == 502)
            pos += 4; # Skip ref_id for transport
        }
      }
    }
    sess_list[i] = sess_info;
  }

  for (i = 0; i < entries; i++)
  {
    sess_info = sess_list[i];

    # cname
    ret = msrpc_unmarshal_ustring(blob: data, pos: pos);
    if(isnull(ret))
    {
      _debug_smb_null_return(fname:FUNCTION_NAME, label:'msrpc_unmarshal_ustring()');
      return NULL;
    }
    cname = ret['ustr'];
    pos = ret['next'];
    sess_info[0] = cname;

    # levels 1, 2, 10, 502
    if(level > 0)
    {
      # username
      ret = msrpc_unmarshal_ustring(blob: data, pos: pos);
      if(isnull(ret))
      {
        _debug_smb_null_return(fname:FUNCTION_NAME, label:'msrpc_unmarshal_ustring() (2)');
        return NULL;
      }
      username = ret['ustr'];
      pos = ret['next'];
      sess_info[1] = username;

      if(level == 2 || level == 502)
      {
        # cltype_name
        ret = msrpc_unmarshal_ustring(blob: data, pos: pos);
        if(isnull(ret))
        {
          _debug_smb_null_return(fname:FUNCTION_NAME, label:'msrpc_unmarshal_ustring() (3)');
          return NULL;
        }
        cltype_name = ret['ustr'];
        pos = ret['next'];
        sess_info[6] = cltype_name;

        if(level == 502)
        {
          # transport
          ret = msrpc_unmarshal_ustring(blob: data, pos: pos);
          if(isnull(ret))
          {
            _debug_smb_null_return(fname:FUNCTION_NAME, label:'msrpc_unmarshal_ustring() (4)');
            return NULL;
          }
          transport = ret['ustr'];
          pos = ret['next'];
          sess_info[7] = transport;
        }
      }
    }

    sess_list[i] = sess_info;
  }

  # Total entries available
  if(pos % 4) pos += (4 - pos % 4);
  total_entries = get_dword (blob:data, pos:pos); pos += 4;

  # Currently doesn't support resumption
  #if(entries < total_entries)
  #{
  #  # Enum again with resumption handle
  #}

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'NetSessionEnum success');
  return sess_list;
}


#---------------------------------------------------------#
# Function    : NetShareEnum                              #
# Description : Return host's shares information          #
# level       : SHARE_INFO_x (x = 0, 1, 2, 502)           #
#---------------------------------------------------------#

function direct_NetShareEnum (level)
{
  var rep, info_level, ref_id, num, max_count, actual_count, name, pos, shares, i, offset, comment;
  var curr_share, name_ref_id, comment_ref_id, path_ref_id, pw_ref_id, sd_ref_id, share_strings, data_offset, str;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Trying NetShareEnum');

  rep = NetEnum(pipe:"srvsvc", uuid:"4b324fc8-1670-01d3-1278-5a47bf6ee188", vers:3, level:level, opnum:OPNUM_SHAREENUM);
  if (!rep || (strlen (rep) < 24))
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'NetEnum() return', length:24);
    return NULL;
  }
  shares = NULL;

  info_level = get_dword (blob:rep, pos:0);

  if (info_level == SHARE_INFO_0)
  {
    info_level = get_dword (blob:rep, pos:4);
    ref_id = get_dword (blob:rep, pos:8);
    num = get_dword (blob:rep, pos:12);

    #SHARE_INFO_0 Array
    ref_id = get_dword (blob:rep, pos:16);
    max_count = get_dword (blob:rep, pos:20);

    # don't parse each share ref_id
    pos = 24 + max_count*4;

    for (i = 0; i<num; i++)
    {
      if (strlen (rep) < pos + 12)
      {
        _debug_smb_length(fname:FUNCTION_NAME, varname:'NetEnum() return', length:pos+12);
        return NULL;
      }

      max_count = get_dword (blob:rep, pos:pos);
      offset = get_dword (blob:rep, pos:pos+4);
      actual_count = get_dword (blob:rep, pos:pos+8);

      if (session_is_unicode () == 1)
        actual_count = actual_count * 2;

      if (strlen (rep) < pos + 12 + actual_count)
      {
        _debug_smb_length(fname:FUNCTION_NAME, varname:'NetEnum() return', length:pos+12+actual_count);
        return NULL;
      }

      name = get_string2 (blob:rep, pos:pos + 12, len:actual_count);

      pos += actual_count + 12;

      while ((actual_count % 4) != 0)
      {
        actual_count ++;
        pos ++;
      }

      shares[i] = name;
    }
  }
  else if (info_level == SHARE_INFO_1)
  {
    info_level = get_dword (blob:rep, pos:4);
    ref_id = get_dword (blob:rep, pos:8);
    num = get_dword (blob:rep, pos:12);

    #SHARE_INFO_1 Array
    ref_id = get_dword (blob:rep, pos:16);
    max_count = get_dword (blob:rep, pos:20);

    # don't parse each share ref_id
    pos = 24 + max_count*(4*3);

    for (i = 0; i<num; i++)
    {
      if (strlen (rep) < pos + 12)
      {
        _debug_smb_length(fname:FUNCTION_NAME, varname:'NetEnum() return', length:pos+12);
        return NULL;
      }

      max_count = get_dword (blob:rep, pos:pos);
      offset = get_dword (blob:rep, pos:pos+4);
      actual_count = get_dword (blob:rep, pos:pos+8);

      if (session_is_unicode () == 1)
        actual_count = actual_count * 2;

      if (strlen (rep) < pos + 12 + actual_count)
      {
        _debug_smb_length(fname:FUNCTION_NAME, varname:'NetEnum() return', length:pos+12+actual_count);
        return NULL;
      }

      name = get_string2 (blob:rep, pos:pos + 12, len:actual_count);

      pos += actual_count + 12;
      while ((actual_count % 4) != 0)
      {
        actual_count ++;
        pos ++;
      }

      actual_count = get_dword (blob:rep, pos:pos);
      if (session_is_unicode () == 1)
        actual_count = actual_count * 2;
      pos += actual_count + 12;

      while ((actual_count % 4) != 0)
      {
        actual_count ++;
        pos ++;
      }

      shares[i] = name;
    }
  }
  else if (info_level == SHARE_INFO_502)
  {
    # SHARE_INFO_502 structure
    # http://msdn.microsoft.com/en-us/library/windows/desktop/bb525410(v=vs.85).aspx

    info_level = get_dword (blob:rep, pos:4);
    ref_id = get_dword (blob:rep, pos:8);
    num = get_dword (blob:rep, pos:12);

    #SHARE_INFO_502 Array
    ref_id = get_dword (blob:rep, pos:16);
    max_count = get_dword (blob:rep, pos:20);

    pos = 24;
    data_offset = pos + max_count * 4 * 10;

    for (i = 0; i<num; i++)
    {
      if (strlen (rep) < pos + 40)
      {
        _debug_smb_length(fname:FUNCTION_NAME, varname:'NetEnum() return', length:pos+40);
        return NULL;
      }

      curr_share = make_list();
      name_ref_id = get_dword (blob:rep, pos:pos);
      curr_share[0] = NULL;
      curr_share[1] = get_dword (blob:rep, pos:pos+4);     # type
      comment_ref_id = get_dword (blob:rep, pos:pos+8);    # remark
      curr_share[2] = NULL;
      curr_share[3] = get_dword (blob:rep, pos:pos+12);    # permissions
      curr_share[4] = get_dword (blob:rep, pos:pos+16);    # max_uses
      curr_share[5] = get_dword (blob:rep, pos:pos+20);    # current_uses
      path_ref_id = get_dword (blob:rep, pos:pos+24);      # path
      curr_share[6] = NULL;
      pw_ref_id = get_dword (blob:rep, pos:pos+28);        # passwd
      curr_share[7] = NULL;
      curr_share[8] = get_dword (blob:rep, pos:pos+32);    # reserved
      sd_ref_id = get_dword (blob:rep, pos:pos+36);        # security_descriptor
      curr_share[9] = NULL;
      pos += 40;

      share_strings = make_list();

      if (name_ref_id != 0)
        share_strings = make_list(share_strings, 0);
      else
        continue;

      if (comment_ref_id != 0)
        share_strings = make_list(share_strings, 2);
      if (path_ref_id != 0)
        share_strings = make_list(share_strings, 6);
      if (pw_ref_id != 0)
        share_strings = make_list(share_strings, 7);
      if (sd_ref_id != 0)
        share_strings = make_list(share_strings, 9);

      if (max_index(share_strings) == 0)
        continue;

      foreach str (share_strings)
      {
        if (str == 9)  # security_descriptor
        {
          actual_count = get_dword (blob:rep, pos:data_offset);
          data_offset += 4;
        }
        else
        {
          max_count = get_dword (blob:rep, pos:data_offset);
          offset = get_dword (blob:rep, pos:data_offset+4);
          actual_count = get_dword (blob:rep, pos:data_offset+8);

          # All string fields are of WCHAR in SHARE_INFO_502_I
          actual_count = actual_count * 2;
          data_offset += 12;
        }

        if (strlen (rep) < data_offset + actual_count)
        {
          _debug_smb_length(fname:FUNCTION_NAME, varname:'NetEnum() return', length:data_offset + actual_count);
          return NULL;
        }

        if (str == 9) # security_descriptor
          curr_share[str] = substr(rep, data_offset, data_offset + actual_count - 1);
        else
        {
          # MSRPC strings are NULL-terminated
          if(actual_count == 2)
            curr_share[str] ='';
          else
            curr_share[str] = get_string2(blob:rep, pos:data_offset, len:actual_count, _type:UNICODE_STRING);
        }
        data_offset += actual_count;
        while ((actual_count % 4) != 0)
        {
          actual_count ++;
          data_offset ++;
        }
      }

      if (isnull(shares))
        shares = make_list();

      # Parse SD
      if(curr_share[9])
        curr_share[9] =  parse_security_descriptor(blob:curr_share[9]);

      shares[max_index(shares)] = curr_share;
    }
  }
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'NetShareEnum results: ' + obj_rep(shares));
  return shares;
}



#---------------------------------------------------------#
# Function    : NetWkstaUserEnum                          #
# Description : Return logged users                       #
# level       : WKSTA_USER_INFO_x (x = 0, 1)              #
#---------------------------------------------------------#

function direct_NetWkstaUserEnum (level)
{
  var data, entries, i, lev, max_count, ret, pos;
  var username, logon_domain, oth_domains, logon_server;
  var user_info, user_list, total_entries;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Trying NetWkstaUserEnum');

  data = NetEnum(pipe:"wkssvc", uuid:"6bffd098-a112-3610-9833-46c3f87e345a", vers:1, level:level, opnum:OPNUM_WKSTAUSERENUM);

  if(isnull(data))
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'NetEnum()');
    return NULL;
  }


  pos = 0;
  lev =  get_word (blob:data, pos:pos); pos += 4;

  if(lev != level)
  {
    dbg::detailed_log(lvl:1, family:'SMB', src:FUNCTION_NAME, msg:
      'Level is ' + lev + ' and not expected level ' + level + '!');
    return NULL;
  }

  pos += 4; # skip switch_is(level)
  pos += 4; # skip ref_id for ptr to WKSTA_USER_INFO_X_CONTAINER

  # Number of entries returned
  entries =  get_word (blob:data, pos:pos); pos += 4;

  pos += 4; # skip ref_id for ptr to WKSTA_USER_INFO_X

  max_count =  get_word (blob:data, pos:pos); pos += 4;
  if(max_count != entries)
  {
    dbg::detailed_log(lvl:1, family:'SMB', src:FUNCTION_NAME, msg:
      'Max Count ' + max_count + ' is not the number of entries, ' + entries + '!');
    return NULL;
  }

  pos += (4 * entries); # skip ref_ids for ptr to username
  if(level == 1)
  {
    pos += (12 * entries); # skip ref_ids for ptr to logon_domain, oth_domains, logon_server;
  }

  for (i = 0; i < entries; i++)
  {
    # username
    ret = msrpc_unmarshal_ustring(blob: data, pos: pos);
    if(isnull(ret))
    {
      _debug_smb_null_return(fname:FUNCTION_NAME, label:'msrpc_unmarshal_ustring()');
      return NULL;
    }
    username = ret['ustr'];
    pos = ret['next'];
    user_info[0] = username;

    if(level == 1)
    {
      # logon_domain
      ret = msrpc_unmarshal_ustring(blob: data, pos: pos);
      if(isnull(ret))
      {
        _debug_smb_null_return(fname:FUNCTION_NAME, label:'msrpc_unmarshal_ustring() (2)');
        return NULL;
      }
      logon_domain = ret['ustr'];
      pos = ret['next'];
      user_info[1] = logon_domain;

      # oth_domains
      ret = msrpc_unmarshal_ustring(blob: data, pos: pos);
      if(isnull(ret))
      {
        _debug_smb_null_return(fname:FUNCTION_NAME, label:'msrpc_unmarshal_ustring() (3)');
        return NULL;
      }
      oth_domains = ret['ustr'];
      pos = ret['next'];
      user_info[2] = oth_domains;

      # logon_server
      ret = msrpc_unmarshal_ustring(blob: data, pos: pos);
      if(isnull(ret))
      {
        _debug_smb_null_return(fname:FUNCTION_NAME, label:'msrpc_unmarshal_ustring() (4)');
        return NULL;
      }
      logon_server = ret['ustr'];
      pos = ret['next'];
      user_info[3] = logon_server;
    }

    user_list[i] = user_info;
  }

  # Total entries available
  if(pos % 4) pos += (4 - pos % 4);
  total_entries = get_dword (blob:data, pos:pos); pos += 4;

  # Currently doesn't support resumption
  #if(entries < total_entries)
  #{
  #  # Enum again with resumption handle
  #}

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Returning user list: ' + obj_rep(user_list));
  return user_list;
}



#---------------------------------------------------------#
# Function    : NetServerEnum                             #
# Description : Return enumerated systems                 #
# Return      : return Array                              #
#---------------------------------------------------------#
#                                                         #
# If level == 0, array  of server names                   #
#                                                         #
# If level == 1, array of                                 #
#                  - [0] name (STRING)                    #
#                  - [1] version_major (DWORD)            #
#                  - [2] version_minor (DWORD)            #
#                  - [3] type (DWORD)                     #
#                  - [4] comment (STRING)                 #
#                                                         #
#---------------------------------------------------------#

function direct_NetServerEnum (level)
{
  var data, resp, convert, count, available, ret, i, offset, comment;
  var entry, info, j, name, tmp;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Trying NetServerEnum');

  data = raw_word (w:104)         + # Function code
         ascii (string:"WrLehDO") + # Parameter Descriptor
         ascii (string:"B16BBDz") + # Return Descriptor
         raw_word (w:level)       + # Detail level
         raw_word (w:0xFFFF)      + # Receive buffer length
         raw_dword (d:3) ;          # Server type (server + workstation)

  data = smb_trans_lanman(data:data);
  if (!data || (strlen(data) < 8))
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'smb_trans_lanman() return', length:8);
    return NULL;
  }
  # WORD status
  # WORD convert
  # WORD Entry count
  # WORD Available entries

  resp = get_word (blob:data, pos:0);
  convert = get_word (blob:data, pos:2);
  count = get_word (blob:data, pos:4);
  available = get_word (blob:data, pos:6);

  if (resp != STATUS_SUCCESS)
  {
    _debug_smb_status_not_success(fname:FUNCTION_NAME);
    return NULL;
  }

  if (level == 0)
  {
    # struct :
    # byte [16] server_name;

    if (strlen (data) < (8 + count*16))
    {
      _debug_smb_length(fname:FUNCTION_NAME, varname:'smb_trans_lanman() return', length:(8 + count*16));
      return NULL;
    }
    ret = NULL;
    for (i=0; i<count; i++)
    {
      ret[i] = get_string (blob:data, pos:8+i*16, _type:ASCII_STRING);
    }
  }
  else
  {
    # struct :
    # byte [16] server name
    # byte os_vers_major
    # byte os_vers_minor
    # DWORD server_type
    # DWORD comment_offset

    if (strlen (data) < (8 + count*26))
    {
      _debug_smb_length(fname:FUNCTION_NAME, varname:'smb_trans_lanman() return', length:(8 + count*26));
      return NULL;
    }
    ret = NULL;
    for (i=0; i<count; i++)
    {
      # offset is a negative position at the end of the buffer
      offset = 65535 - get_dword (blob:data, pos:8+i*26+22);
      offset = strlen(data) - offset;
      if ((offset > 0) && (offset < strlen(data)))
        comment = get_string (blob:data, pos:offset, _type:ASCII_STRING);
      else
        comment = "";

      #ret[i] = substr (data, 8+i*26, 8+i*26+25) + comment;

      # NetServerInfo1 at
      # http://msdn.microsoft.com/en-us/library/cc240225.aspx
      info = substr (data, 8+i*26, 8+i*26+25);
      tmp = substr(info, 0, 15); # 16-byte NETBIOS name; NULL-padded
      name = NULL;
      for (j = 0; j < strlen(tmp); j++)
      {
        if(tmp[j] == '\x00')
          break;
        name += tmp[j];
      }

      entry[0] = name;                           # ServerName
      entry[1] = ord(info[16]);                  # OS major version
      entry[2] = ord(info[17]);                  # OS minor version
      entry[3] = get_dword(blob: info, pos: 18); # ServerType
      entry[4] = comment;

      ret[i] = entry;
    }
  }

  dbg::detailed_log(
    lvl:3,
    family:'SMB',
    src:FUNCTION_NAME,
    msg:'NetServerEnum response',
    msg_details:{
      "Return":{"lvl":3, "value":obj_rep(ret)}
    });
 return ret;
}


#---------------------------------------------------------#
# Function    : NetUserGetGroups                          #
# Description : Return user's group                       #
#---------------------------------------------------------#

function direct_NetUserGetGroups (user, resolv)
{
  var ret, handle, domains, sid, handle2, rid, uhandle, rids;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Trying NetUserGetGroups');

  ret = NULL;

  handle = SamConnect2 ();
  if (!isnull(handle))
  {
    domains = SamEnumerateDomainsInSamServer (handle:handle);
    if (!isnull(domains))
    {
      sid = SamLookupDomainInSamServer (handle:handle, domain:domains[0]);
      if (!isnull(sid))
      {
        handle2 = SamOpenDomain (handle:handle, sid:sid, access:0x200);
        if (!isnull (handle2))
        {
          rid = SamLookupNamesInDomain (handle:handle2, user:user);
          if (!isnull(rid))
          {
            uhandle = SamOpenUser (handle:handle2, rid:rid, access:0x100);
            if (!isnull(uhandle))
            {
              rids = SamGetGroupsForUser (handle:uhandle);
              if (!isnull (rids))
              {
                if (resolv)
                  ret = SamLookupIdsInDomain (handle:handle2, ids:rids);
                else
                  ret = rids;
              }
              SamCloseHandle(handle:uhandle);
            }
          }
        }

      SamCloseHandle(handle:handle2);
      }
    }

    SamCloseHandle(handle:handle);
  }

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Returning groups: ' + obj_rep(ret));
  return ret;
}


#---------------------------------------------------------#
# Function    : NetUserGetLocalGroups                     #
# Description : Return user's local group                 #
#---------------------------------------------------------#

function direct_NetUserGetLocalGroups (user, resolv)
{
  var ret, handle, domains, sid, handle2, rid, uhandle, rids, builtsid, handle3, aliases, aliases2;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Trying NetUserGetLocalGroups for user ' + user);
  builtsid = raw_string (0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x05,0x20,0x00,0x00,0x00);
  ret = NULL;

  handle = SamConnect2 ();
  if (!isnull(handle))
  {
    domains = SamEnumerateDomainsInSamServer (handle:handle);
    if (!isnull(domains))
    {
      sid = SamLookupDomainInSamServer (handle:handle, domain:domains[0]);
      if (!isnull(sid))
      {
        handle2 = SamOpenDomain (handle:handle, sid:sid, access:0x280);
        if (!isnull (handle2))
        {
          handle3 = SamOpenDomain (handle:handle, sid:builtsid, access:0x280);
          if (!isnull (handle3))
          {
            rid = SamLookupNamesInDomain (handle:handle2, user:user);
            if (!isnull(rid))
            {
              uhandle = SamOpenUser (handle:handle2, rid:rid, access:0x100);
              if (!isnull(uhandle))
              {
                rids = SamGetGroupsForUser (handle:uhandle);
                if (!isnull (rids))
                {
                  aliases = SamGetAliasMemberShip (handle:handle2, sid:sid, rids:rids, urid:rid);
                  aliases2 = SamGetAliasMemberShip (handle:handle3, sid:sid, rids:rids, urid:rid);

                  if (resolv && !isnull(aliases))
                    aliases = SamLookupIdsInDomain (handle:handle2, ids:aliases);

                  if (resolv && !isnull(aliases2))
                    aliases2 = SamLookupIdsInDomain (handle:handle3, ids:aliases2);

                  if (isnull(aliases))
                    aliases = aliases2;
                  else if (!isnull(aliases2))
                  {
                    if (!isnull(aliases))
                      aliases = make_list(aliases, aliases2);
                    else
                      aliases = aliases2;
                  }

                  ret = aliases;
                }

                SamCloseHandle(handle:uhandle);
              }
            }
          }
        }

        SamCloseHandle(handle:handle2);
      }
    }

    SamCloseHandle(handle:handle);
  }

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Returning groups: ' + obj_rep(ret));
  return ret;
}


#---------------------------------------------------------#
# Function    : NetLocalGroupGetMembers                   #
# Description : Return local group members                #
#---------------------------------------------------------#
function direct_NetLocalGroupGetMembers (group, domain)
{
  var ret, handle, domains, sid, handle2, rid, handle3, names, lsa, members, builtsid;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Trying NetLocalGroupGetMembers');

  builtsid = raw_string (0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x05,0x20,0x00,0x00,0x00);
  ret = NULL;

  handle = SamConnect2 ();
  if (!isnull(handle))
  {
    handle2 = SamOpenDomain (handle:handle, sid:builtsid, access:0x200);
    if (!isnull (handle2))
    {
      rid = SamLookupNamesInDomain (handle:handle2, user:group);
      if (isnull(rid))
      {
        SamCloseHandle(handle:handle2);

        domains = SamEnumerateDomainsInSamServer (handle:handle);
        if (!isnull(domains))
        {
          if ((!empty_or_null(domain) && domains[0] == domain) ||
              empty_or_null(domain))
          {
            sid = SamLookupDomainInSamServer (handle:handle, domain:domains[0]);
            if (!isnull(sid))
            {
              handle2 = SamOpenDomain (handle:handle, sid:sid, access:0x200);
              if (!isnull (handle2))
              {
                rid = SamLookupNamesInDomain (handle:handle2, user:group);
              }
            }
          }
        }
      }

      if (!isnull(rid))
      {
        handle3 = SamOpenAlias (handle:handle2, rid:rid, access:0x2000C);
        if (!isnull(handle3))
        {
          members = SamGetMembersInAlias (handle:handle3);
          if (!isnull(members))
          {
            lsa = LsaOpenPolicy (desired_access:0x20801);
            if (!isnull(lsa))
            {
              names = LsaLookupSid (handle:lsa, sid_array:members);
              if (!isnull(names))
              {
                ret = names;
              }

              LsaClose (handle:lsa);
            }
          }

          SamCloseHandle(handle:handle3);
        }
      }

      SamCloseHandle(handle:handle2);
    }

    SamCloseHandle(handle:handle);
  }

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Returning names: ' + obj_rep(ret));
  return ret;
}



#---------------------------------------------------------#
# Function    : NetGroupGetUsers                          #
# Description : Return group members                      #
#---------------------------------------------------------#

function direct_NetGroupGetUsers (group)
{
  var ret, handle, domains, sid, handle2, rid, ghandle, members;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Trying NetGroupGetUsers');

  ret = NULL;

  handle = SamConnect2 ();
  if (!isnull(handle))
  {
    domains = SamEnumerateDomainsInSamServer (handle:handle);
    if (!isnull(domains))
    {
      sid = SamLookupDomainInSamServer (handle:handle, domain:domains[0]);
      if (!isnull(sid))
      {
        handle2 = SamOpenDomain (handle:handle, sid:sid, access:0x200);
        if (!isnull (handle2))
        {
          rid = SamLookupNamesInDomain (handle:handle2, user:group);
          if (!isnull(rid))
          {
            ghandle = SamOpenGroup (handle:handle2, rid:rid, access:0x10);
            if (!isnull(ghandle))
            {
              members = SamGetMembersInGroup (handle:ghandle);
              if (!isnull(members))
              {
                ret = SamLookupIdsInDomain (handle:handle2, ids:members);
              }

              SamCloseHandle(handle:ghandle);
            }
          }
        }

        SamCloseHandle(handle:handle2);
      }
    }

    SamCloseHandle(handle:handle);
  }

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Returning users: ' + obj_rep(ret));
  return ret;
}


##
# Gets users in a SAM domain.
#
# @return Returns an array of user information.
##

function direct_NetGetSamrUsers()
{
  var info, handle, domains, sid, handle2;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Trying NetGetSmarUsers');

  handle = SamConnect2();
  if (!isnull(handle))
  {
    domains = SamEnumerateDomainsInSamServer(handle:handle);
    if (!isnull(domains))
    {
      sid = SamLookupDomainInSamServer(handle:handle, domain:domains[0]);
      if (!isnull(sid))
      {
        handle2 = SamOpenDomain(handle:handle, sid:sid, access:0x305);
        if (!isnull (handle2))
        {
          info = SamQueryDisplayInformation(handle:handle2);
          dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
            'SamQueryDisplayInformation for sid ' + sid + ' is: ' + obj_rep(info));
          SamCloseHandle(handle:handle2);
        }
      }
    }

    SamCloseHandle(handle:handle);
  }
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Success');
  return info;
}

#---------------------------------------------------------#
# Function    : NetUserGetInfo                            #
# Description : Return user's info                        #
#---------------------------------------------------------#

function direct_NetUserGetInfo (user)
{
  var ret, handle, domains, sid, handle2, rid, uhandle;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Trying NetGetUserInfo');
  ret = NULL;

  handle = SamConnect2 ();
  if (!isnull(handle))
  {
    domains = SamEnumerateDomainsInSamServer (handle:handle);
    if (!isnull(domains))
    {
      sid = SamLookupDomainInSamServer (handle:handle, domain:domains[0]);
      if (!isnull(sid))
      {
        handle2 = SamOpenDomain (handle:handle, sid:sid, access:0x200);
        if (!isnull (handle2))
        {
          rid = SamLookupNamesInDomain (handle:handle2, user:user);
          if (!isnull(rid))
          {
            uhandle = SamOpenUser (handle:handle2, rid:rid, access:0x11b);
            if (!isnull(uhandle))
            {
              ret = SamQueryInformationUser (handle:uhandle);
              SamCloseHandle(handle:uhandle);
            }
          }
        }

        SamCloseHandle(handle:handle2);
      }
    }

    SamCloseHandle(handle:handle);
  }

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Success');
  return ret;
}


#---------------------------------------------------------#
# Function    : NetUserGetModals                          #
# Description : Return password policy                    #
# Return      : if level == 1                             #
#                 ret[0] = min pass len                   #
#                 ret[1] = pass history len               #
#                 ret[2] = max pass age                   #
#                 ret[3] = min pass age                   #
#                 ret[4] = force logoff                   #
#                 ret[5] = must meet complexity           #
#               if level == 3                             #
#                 ret[0] = lockout duration               #
#                 ret[1] = lockout observation window     #
#                 ret[2] = lockout threshold              #
# Note        : time in seconds (-1 if infinite)          #
#---------------------------------------------------------#

function direct_NetUserGetModals (level)
{
  var ret, handle, domains, sid, handle2, rid, uhandle, tmp;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Trying NetUserGetModals');

  ret = NULL;

  handle = SamConnect2 ();
  if (!isnull(handle))
  {
    domains = SamEnumerateDomainsInSamServer (handle:handle);
    if (!isnull(domains))
    {
      sid = SamLookupDomainInSamServer (handle:handle, domain:domains[0]);
      if (!isnull(sid))
      {
        handle2 = SamOpenDomain (handle:handle, sid:sid, access:0x205);
        if (!isnull (handle2))
        {
          if (level == 1)
          {
            ret = SamQueryInformationDomain (handle:handle2, level:1);
            if (!isnull (ret))
            {
              tmp = SamQueryInformationDomain (handle:handle2, level:3);
              if (!isnull(tmp))
                ret[max_index(ret)] = tmp[0];
            }
          }
          else if (level == 3)
          {
            ret = SamQueryInformationDomain (handle:handle2, level:12);
          }
        }

        SamCloseHandle(handle:handle2);
      }
    }

    SamCloseHandle(handle:handle);
  }

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Success');
  return ret;
}
