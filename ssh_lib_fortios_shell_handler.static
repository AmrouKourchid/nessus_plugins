#TRUSTED 7fbc4ef2b4212b5bfbb8ee60e1d11ef745fbdc76352c63e75ee2d749c2e50e609357daa8701781c36019fb2c6450d31a80acdce96f4647163eaf637bb659918a29cd6d0f6c0dab49697556cfeb9092d239add7e94d447cdb8eb9078e040e1dfe74ed7d125eeca98802806d1e125117ea6bf40709f4af6ea37428dc4a41a6c50183ac2000cf30d4f32dacbcfe2de472d00e5c9715dd7fb20f31f2e13150f7129008512d7949af698fd681a0b8718212877bfcfdde25856ad4ced6975db2a547b31a92a4edc1843b4b6d14fd170d4936e17be088f099ac26fc0fa50961155d8632009a1f527b8602271a51067899c7dd806cbe195081725de92131b8c545134ee67a0c7732044adead666c2286ea75220e15eba12f88556799079355bda55dc9652ef146347cc6b7d172dd2985a30185dbd2cf92a40b6ff45efbdf499d6a4692efe63309a9fc419fcb99715b99f74f87c001ce20d8ba106270ca1f9e61d7b5f05d153020d618a7c8d64dc3b46f18a8cf9e2841d7858e74120ce9e79ab5ca5cbfe9f41f1b8d644b3c988ac6c0c38c0c3034dfb964df61b19a2f5641651a0294b7791174b3372c0014c180c3d73db5e9148d6247285c5c689cbeda7dbf1fe9467c4b41f498187b5e9498a8d60a190a98e4ec3841a71de9d1d7df8966826d1fc590bdab227c72c8455a72a2bbec93c4490bd0922c1d2970fecc1b02b3e8a5612e2cb8
#TRUST-RSA-SHA256 1b59c7338a553f4c6f972fb1cbc54b6d0cb8a9ff581f319b793e9b46bb0a4ef5d01691bbcaddbcb5ee2b793b5c5c30e7cde5fa9db3cd8a043c96a896f631aaefadc04aef142fb6db203ec47b82baa2a5b75012f7c45b1f6958ecd43bc895d0c6bfcb121087c8c5ae0617c8d2955b99acd610c15d014e5b158a691b588f8d95d4b9e1d7f55cc8c63b5905b8f78c57a3de5d857cba59152f9ccf9717264612feaca15ec0c82d44ea65f8291eb8a5be01f1a2f9d679e304317b76f9ed309b6bbf06e050e306e4828690d15e71db9e5741bc06ae0034078e5b58c45b0906e49944bc957d862b7f0deccde739fd64b8c72d947d3b341621bc45e76782ca2885afecaa9dc532cae7b4b1cdaad4a3e7a80d426e503cda347d216c8d0fbdcaa75901aabd944604702098eac66715b17d0ec66e9957633903239d65c98b4b5854b11034ac2f64e0b47a2e0cf4dfbd5ccc458697ebf224d37b896f1f427caf394a9f3761affbbbf9b59b1a3216eaee4dda808a7d2259438b315940f94dd68278538bbbe0cc64c3dc8979da60ad4a2810d955fad5a22b371791125e90e2cde9ea72dc2b2a744ecf436b2a87634cdfb6a625f7f84e501db0fc7145897e5ebdfe8b3002e10ec8a7072183e5b6ae54a736907b2c1b6436d1b487fa55d524176ac133a62d172b3649dc3e4637633a5ba112df18d0e915d4872695bf8193e31ff7f6c03e8b9ddf9d
# (C) Tenable Network Security, Inc.
#
# This script is released under one of the Tenable Script Licenses and may not
# be used from within scripts released under another license without the
# authorization from Tenable Network Security Inc.
#
# Revision: 1.8

namespace sshlib
{
  # global key/value array callbacks can use to share information
  host_info_key_val = make_array();

  # all timeouts are controlled by a timer with 1s resolution
  # for that reason keep the shell timeout sufficiently beyond
  # the timer resolution (10s = 10x resolution)
  global_var _FORTIOS_DEFAULT_CMD_TIMEOUT = 60;
  global_var _FORTIOS_DEFAULT_INACTIVITY_TIMEOUT = 45;
  global_var _FORTIOS_INITIAL_INACTIVITY_TIMEOUT = 2;

  # cmd_states
  # _FORTIOS_CMD_STATE_SEND_REQ: ready to send a command to device
  # _FORTIOS_CMD_STATE_RECV_RSP: ready to recv a response from device
  # _FORTIOS_CMD_STATE_AT_PROMPT: found command prompt in response
  global_var _FORTIOS_CMD_STATE_SEND_REQ = 0;
  global_var _FORTIOS_CMD_STATE_AT_POST_LOGIN_BANNER = 1;
  global_var _FORTIOS_CMD_STATE_AT_PROMPT = 2;

  ##
  # callback function that checks for either a timeout or buffer update
  #
  # @param session session handle for ssh session
  # @param channel channel for ssh session
  #
  # @return TRUE if timeout reached
  # @category SSH
  ##
  function fortios_shell_handler_incoming_data_timeout_cb(session, channel)
  {
    var fn = 'fortios_shell_handler_incoming_data_timeout_cb';
    var sh = channel.shell_handler;
    var obj_ch_id = 'fortios_shell_handler [channel ' + channel.local_channel + ']: ';
    var lines = split(channel.data_buf, sep:'\n', keep:FALSE);
    var last_line = lines[max_index(lines)-1];
    if(isnull(channel))
    {
      dbg::detailed_log(lvl:1, src:fn, msg:"Channel does not exist");
      return TRUE;
    }
    if(channel.state == CHANNEL_STATE_CLOSED)
    {
      dbg::detailed_log(lvl:1, src:fn, msg:obj_ch_id + "Channel is closed.");
      return TRUE;
    }

    dbg::detailed_log(lvl:3, src:fn, msg:obj_ch_id + "_FORTIOS_STATE : " + sh.cmd_state);

    if(pgrep(pattern:"-+\s*[Mm]ore\s*-+", string:last_line))
    {
      channel.window_send_data(data:' ');
      return FALSE;
    }

    if(sh.at_post_login_prompt(buf:channel.data_buf, channel)) return TRUE;
    return sh.check_inactivity_timeout(channel:channel);
  }

  ##
  # callback function that checks for buffer update, timeout or shell prompt
  #
  # @param session session handle for ssh session
  # @param channel channel for ssh session
  #
  # @return TRUE if found
  # @category SSH
  ##
  function fortios_shell_handler_incoming_data_timeout_or_prompt_cb( session, channel )
  {
    var fn = 'fortios_shell_handler_incoming_data_timeout_or_prompt_cb';
    var obj_ch_id = 'fortios_shell_handler [channel '+channel.local_channel+']: ';
    var lines = split(channel.data_buf, sep:'\n', keep:FALSE);
    var last_line = lines[max_index(lines)-1];
    # does a channel exist?
    if ( isnull(channel) )
    {
      dbg::detailed_log(lvl:1, src:fn, msg:"Channel does not exist");
      return TRUE;
    }
    if (channel.state == CHANNEL_STATE_CLOSED)
    {
      dbg::detailed_log(lvl:1, src:fn, msg:obj_ch_id + "Channel is closed.");
      return TRUE;
    }
    # does channel have a valid data buffer?
    if ( isnull(channel.data_buf) )
    {
      dbg::detailed_log(lvl:1, src:fn, msg:obj_ch_id + "channel.data_buf does not exist");
      return TRUE;
    }
    if ( isnull(channel.shell_handler ) )
    {
      dbg::detailed_log(lvl:1, src:fn, msg:obj_ch_id + "Shell handler does not exist");
      return TRUE;
    }
    if(pgrep(pattern:"-+\s*[Mm]ore\s*-+", string:last_line))
    {
      channel.window_send_data(data:' ');
      return FALSE;
    }

    var sh = channel.shell_handler;
    dbg::detailed_log(lvl:3, src:fn, msg:obj_ch_id + "_FORTIOS_STATE : " + sh.cmd_state);
    return sh.at_prompt_or_timeout(channel:channel);

  }

  #shell handler for FortiOS
  object fortios_shell_handler
  {
    var settings;
    var cmd_state;
    var cmd_last;
    var cmd_prompt;
    var cmd_timeout;
    var inactivity_timeout;
    var last_md5;
    var last_buffer_update_ts;
    var last_cmd_error = FALSE;
    var fresh_shell = TRUE;
    var timed_out = FALSE;
    var previous_prompt;

    ##
    # Shell handler constructor
    #
    # @anonparam <first> Shell handler settings array
    # @category SSH
    ##
    function fortios_shell_handler()
    {
      settings = _FCT_ANON_ARGS[0];
      this.init(settings:settings);
    }

    ##
    # Shell handler initialization
    #
    # @param settings Shell handler settings array
    # @category SSH
    ##
    public function init(settings)
    {
      this.cmd_last = "";
      this.cmd_prompt = "";
      this.cmd_timeout = _FORTIOS_DEFAULT_CMD_TIMEOUT;
      this.inactivity_timeout = _FORTIOS_DEFAULT_INACTIVITY_TIMEOUT;
      this.cmd_state = _FORTIOS_CMD_STATE_SEND_REQ;
      this.last_cmd_error = FALSE;
      this.last_buffer_update_ts = unixtime();
      this.last_md5 = "";

      host_info_key_val["getsystemstatus_unrecognized"] = NULL;

      if (!isnull(settings))
      {
        this.settings = settings;
        if ( !isnull(this.settings['cmd_prompt']) )
          this.previous_prompt = this.settings['cmd_prompt'];
        if ( !isnull(this.settings['cmd_timeout']) )
          this.cmd_timeout = this.settings['cmd_timeout'];
      }
      else
      {
        this.settings = make_array();
      }
    }

    ##
    # Returns terminal options
    #
    # @no53   If true don't populate flag 53 with any value - flag 53 (PTY_OPT_ECHO)
    #         reputedly breaks Palo Alto's SSH implementation. (optional)
    # @return Returns an array with a terminal carriage return Opcode
    ##
    public function get_pty_opts(no53)
    {
      if(isnull(no53))
        no53 = FALSE;

      return make_array(PTY_OPT_OCRNL, 0);
    }

    ##
    # get default PTY size in characters
    #
    # @return default PTY size in characters
    # @category SSH
    ##
    public function get_pty_size_chars()
    {
      # Make the default pty size large to avoid issues with truncation
      return make_list(200, 200);
    }

    ##
    # get default PTY size in pixels
    #
    # @return default PTY size in pixels
    # @category SSH
    ##
    public function get_pty_size_pixels()
    {
      return DEFAULT_PTY_SIZE_PIXELS;
    }

    ##
    # get PTY terminal
    #
    # @return default PTY terminal
    # @category SSH
    ##
    public function get_pty_term()
    {
      return DEFAULT_PTY_TERM;
    }


    ##
    # should we send / recv data to device without setting up a channel?
    #
    # @return FALSE
    # @category SSH
    ##
    public function is_nosetup()
    {
      return FALSE;
    }

    ##
    # do we want to request a PTY on this device?
    #
    # @return TRUE
    # @category SSH
    ##
    public function send_pty_req()
    {
      return TRUE;
    }

    ##
    # do we want to handle the "shell" channel request?
    #
    # @category SSH
    ##
    public function get_shell_channel_request_cb()
    {
      return NULL;
    }

    ##
    # Sets the last command error.
    #
    # @anonparam <first> The last command error message.
    # @return NULL
    # @category SSH
    ##
    public function set_last_cmd_error()
    {
      this.last_cmd_error = _FCT_ANON_ARGS[0];
    }

    ##
    # Sets the shell command prompt
    #
    # @anonparam <first> The prompt
    # @return Returns NULL
    # @category SSH
    ##
    public function set_cmd_prompt()
    {
      this.previous_prompt = this.cmd_prompt;
      this.cmd_prompt = _FCT_ANON_ARGS[0];
    }

    ##
    # Sets the shell command handling state
    #
    # @anonparam <first> Command state
    # @return Returns NULL
    # @category SSH
    ##
    public function set_cmd_state(new_cmd_state)
    {
      var channel = _FCT_ANON_ARGS[0];
      if(!isnull(channel))
      {
        var obj_ch_id = 'fortios_shell_handler [channel ' + channel.local_channel + ']: ';
        dbg::detailed_log(lvl:3, src:'fortios_shell_handler.set_cmd_state',
          msg:obj_ch_id + ' updating from state ' + this.cmd_state + ' to state ' + new_cmd_state);
      }

      this.cmd_state = new_cmd_state;
    }

    ##
    # run a command on target system using FortiOS shell handler
    #
    # @param [channel:object] channel used for connection
    # @param [command:string] the command to run against the target
    # @param [force_priv_escl:bool] command should use escl if available
    # @param [cmd_timeout_min:int] timeout for command to run
    # @param [inactivity_timeout_min:int] timeout for inactivity
    #
    # @return NULL on fail, response to command on success
    ##
    public function run_command(channel, command, force_priv_escl, cmd_timeout_min, inactivity_timeout_min)
    {
      var fn = 'fortios_shell_handler.run_command';
      # Local reference to session, channel's reference gets deleted
      # if the channel gets closed
      var session = channel.session;
      var obj_ch_id = 'fortios_shell_handler [channel ' + channel.local_channel + ']: ';
      var cmd_logger = new("sshlib::cmd_logger");
      var lines;
      var kb_base = SSH_LIB_KB_PREFIX + session.get_kb_connection_id();
      var accept_disclaimer = get_one_kb_item("Settings/automatically_accept_disclaimer");
      var post_login_prompt = "\(Press '[Aa]' to accept\):";

      if(isnull(force_priv_escl))
        force_priv_escl = FALSE;

      if(isnull(channel)) return NULL;
      if(isnull(command)) return NULL;

      dbg::detailed_log(lvl:3, src:fn, msg:obj_ch_id + "In run_command");

      if( this.last_cmd_error )
      {
        session.set_error(obj_ch_id +
          'ERROR - shell is in unknown state from last interaction, ' +
          'no additional commands via this shell will be executed.');
        return NULL;
      }

      # Reset default timeouts
      this.inactivity_timeout = _FORTIOS_DEFAULT_INACTIVITY_TIMEOUT;
      this.cmd_timeout = _FORTIOS_DEFAULT_CMD_TIMEOUT;

      # If custom inactivity_timeout and cmd_timeout values are passed,
      # ensure the values in use meet or exceed passed values
      if (inactivity_timeout_min &&
          this.inactivity_timeout < inactivity_timeout_min)
        this.inactivity_timeout = inactivity_timeout_min;

      if (cmd_timeout_min &&
          this.cmd_timeout < cmd_timeout_min)
        this.cmd_timeout = cmd_timeout_min;

      if (this.fresh_shell)
      {
        var post_login_buffer = get_kb_blob(kb_base + "/post_login_buffer");
        dbg::detailed_log(lvl:2, src:fn, msg:obj_ch_id + "Getting prompt on fresh shell.");

        var check_prompt = FALSE;
        var initial_recv_timeout = _FORTIOS_INITIAL_INACTIVITY_TIMEOUT;

        if(strlen(this.cmd_prompt) >= 3)
        {
          # Remove first found instance of prompt from previous post
          # login buffer
          var sub_prompt = substr(this.cmd_prompt, strlen(this.cmd_prompt) - 3, strlen(this.cmd_prompt) - 1);
          post_login_buffer -= sub_prompt;

          # If we don't find it again (e.g. in MOTD), it's probably ok
          # to look for last characters of prompt to recognize prompt
          if(sub_prompt >!< post_login_buffer)
            check_prompt = TRUE;
        }

        if(check_prompt)
        {
          dbg::detailed_log(lvl:2, src:fn, msg:obj_ch_id + "Using command prompt from previous login to find cmd prompt.");
          session.sshrecv_until(
            end_states     : make_list("SOC_CLOSED"),
            check_callback : @fortios_shell_handler_incoming_data_timeout_or_prompt_cb,
            channel        : channel,
            timeout        : initial_recv_timeout
          );
        }
        else
        {
          dbg::detailed_log(lvl:2, src:fn, msg:obj_ch_id + "Waiting for inactivity period to find command prompt.");
          session.sshrecv_until(
            end_states     : make_list("SOC_CLOSED"),
            check_callback : @fortios_shell_handler_incoming_data_timeout_cb,
            channel        : channel,
            timeout        : initial_recv_timeout
          );
        }

        if(preg(pattern:post_login_prompt, string:channel.data_buf, multiline:TRUE) && accept_disclaimer)
        {
          dbg::detailed_log(lvl:2, src:fn, msg:obj_ch_id + "Sending 'a' to accept disclaimer");
          this.cmd_prompt = "";
          channel.clear_data_buf();
          this.last_buffer_update_ts = unixtime();
          channel.window_send_data(data:'a');
          session.sshrecv_until(
            end_states     : make_list("SOC_CLOSED"),
            check_callback : @fortios_shell_handler_incoming_data_timeout_cb,
            channel        : channel,
            timeout        : initial_recv_timeout
          );
        }

        if(empty_or_null(channel.data_buf))
        {
          if(this.timed_out)
            return session.set_cmd_error(obj_ch_id +
              "Timed out waiting for data from server after opening shell.");

          last_cmd_error = TRUE;
          return session.set_cmd_error(obj_ch_id +
            "No data received from server after opening shell.");
        }

        if (channel.state == CHANNEL_STATE_CLOSED)
        {
          dbg::detailed_log(lvl:1, src:fn, msg:obj_ch_id + "Channel is closed.");
          return TRUE;
        }

        post_login_buffer = channel.data_buf;
        replace_kb_blob(name:kb_base + "/post_login_buffer_recheck", value:post_login_buffer);
        if(isnull(get_kb_item(kb_base + "/post_login_buffer")))
          replace_kb_blob(name:kb_base + "/post_login_buffer", value:post_login_buffer);

        this.fresh_shell = FALSE;
        this.timed_out = FALSE;

        lines = split(post_login_buffer, sep:'\n', keep:FALSE);
        this.cmd_prompt = lines[max_index(lines)-1];
        if('\n' >< this.cmd_prompt)
          this.cmd_prompt = str_replace(find:'\n', replace:'', string:this.cmd_prompt);

        replace_kb_blob(name:kb_base + "/cmd_prompt", value:cmd_prompt);

        if(strlen(this.cmd_prompt) == 0)
        {
          session.set_cmd_error(obj_ch_id +
            "Unable to detect command prompt on shell.");
          last_cmd_error = TRUE;
          return NULL;
        }

        dbg::detailed_log(lvl:2, src:fn, msg:obj_ch_id + 'Detected command prompt  "' + this.cmd_prompt + '".');

        this.settings['cmd_prompt'] = this.cmd_prompt;
      }

      if ( preg(pattern:post_login_prompt, string:this.cmd_prompt, multiline:TRUE) )
      {
        session.set_cmd_error(obj_ch_id +
            "Unable to proceed past post-login prompt, cmd_prompt still the post-login prompt.");
        cmd_logger.add(
          cmd                : this.cmd_last,
          response           : channel.data_buf,
          error              : session.cmd_error,
          priv_escl_failed   : FALSE,
          user               : session.user
        );
        return channel.data_buf;
      }

      this.cmd_last = command + '\n';
      session.reset_cmd_interrupted();
      channel.clear_data_buf();

      dbg::detailed_log(lvl:1, src:fn, msg:"sending command: " + cmd_last);
      channel.clear_data_buf();
      this.last_buffer_update_ts = unixtime();
      this.cmd_state = _FORTIOS_CMD_STATE_SEND_REQ;
      dbg::detailed_log(lvl:3, src:fn, msg:obj_ch_id + "cmd_state:_FORTIOS_CMD_STATE_SEND_REQ(" + this.cmd_state + ")");
      channel.window_send_data(data:cmd_last);
      session.sshrecv_until(
        end_states     : make_list("SOC_CLOSED"),
        check_callback : @fortios_shell_handler_incoming_data_timeout_or_prompt_cb,
        channel        : channel,
        cmd_timeout    : this.cmd_timeout
      );

      var ret = NULL;

      if(channel && channel.data_buf )
      {
        if ( preg(pattern:post_login_prompt, string:channel.data_buf, multiline:TRUE) )
        {
          last_cmd_error = TRUE;
          session.set_cmd_error(obj_ch_id +
            "Unable to proceed past post-login prompt, response buffer contains the post-login prompt.");
          cmd_logger.add(
            cmd                : this.cmd_last,
            response           : channel.data_buf,
            error              : session.cmd_error,
            priv_escl_failed   : FALSE,
            user               : session.user
          );
          return channel.data_buf;
        }
        if ( this.cmd_state != _FORTIOS_CMD_STATE_AT_PROMPT )
        {
          session.set_cmd_error(obj_ch_id +
            "Unable to return to command prompt after last command.");
          this.last_cmd_error = TRUE;
        }
        ret = str_replace(string:channel.data_buf, find:command, replace:'');

        ret = chomp(string_reverse(chomp(string_reverse(remove_cmd_prompt(cmd_res:ret)))));

        if ( "Command fail." >< ret)
        {
          session.set_cmd_error(ret);
          ret = NULL;
        }
      }
      cmd_logger.add(
        cmd                : this.cmd_last,
        response           : ret,
        error              : session.cmd_error,
        priv_escl_failed   : FALSE,                     # exit on failed privesc
        user               : session.user
      );
      return ret;
    }

    ##
    # Removed the command prompt from the output
    #
    # @param [cmd_res:string] command results
    #
    # @return the command output stripped of the prompt
    ##
    public function remove_cmd_prompt(cmd_res)
    {
      var idx = stridx(cmd_res, this.cmd_prompt);
      if(idx < 1)
        return cmd_res;

      return substr(cmd_res, 0, idx-1);
    }

    ##
    # Determines if the shell is back at the command prompt.
    #
    # @param [buf:data] the incoming data buffer
    # @anonparam First the channel belonging to the shell handler
    #
    # @return TRUE if at prompt, else implicitly returns NULL
    ##
    function at_cmd_prompt(buf)
    {
      var channel = _FCT_ANON_ARGS[0];
      var lines = split(buf, sep:'\n', keep:FALSE);
      var last_line = lines[max_index(lines)-1];

      if(this.cmd_prompt && this.cmd_prompt >< last_line)
      {
        this.set_cmd_state(new_cmd_state: _FORTIOS_CMD_STATE_AT_PROMPT, channel);

        return TRUE;
      }
    }

    ##
    # Determines if the shell is at a FortiOS post-login prompt.
    #
    # @param [buf:data] the incoming data buffer
    # @anonparam First the channel belonging to the shell handler
    #
    # @return TRUE if at post-login prompt, else implicitly returns NULL
    ##
    public function at_post_login_prompt(buf)
    {
      var channel = _FCT_ANON_ARGS[0];
      var lines = split(buf, sep:'\n', keep:FALSE);
      var last_line = lines[max_index(lines)-1];
      var post_login_prompt = "\(Press '[Aa]' to accept\):";

      if(preg(pattern:post_login_prompt, string:last_line))
      {
        this.set_cmd_state(new_cmd_state: _FORTIOS_CMD_STATE_AT_POST_LOGIN_BANNER, channel);

        return TRUE;
      }
    }

    ##
    # Determines if the shell is at the prompt, or a post-login prompt, or a timeout has occurred
    #
    # @param [channel:object] the channel belonging to the shell handler
    #
    # @return TRUE if at prompt, post-login prompt, or timed out, FALSE if neither
    ##
    public function at_prompt_or_timeout(channel)
    {
      if(at_cmd_prompt(buf:channel.data_buf, channel)) return TRUE;
      if(at_post_login_prompt(buf:channel.data_buf, channel)) return TRUE;
      return check_inactivity_timeout(channel:channel);
    }

    ##
    # Determines if there has been a timeout to inactivity
    #
    # @param [channel:object] the channel belonging to the shell handler
    #
    # @return TRUE if timeout reached, else FALSE
    ##
    public function check_inactivity_timeout(channel)
    {
      var fn = 'fortios_shell_handler.check_inactivity_timeout';
      if ( channel && channel.data_buf && strlen(channel.data_buf) > 0 )
      {
        var new_md5 = MD5( channel.data_buf );
        if ( this.last_md5 != new_md5 )
        {
          if(!isnull(channel) && !isnull(channel.session))
          {
            dbg::detailed_log(lvl:2, src:fn, msg:"New data found, updating last_buffer_update_ts");
          }
          this.last_md5 = new_md5;
          this.last_buffer_update_ts = unixtime();
          return FALSE;
        }
      }
      if (channel && (unixtime() - this.last_buffer_update_ts) >= this.inactivity_timeout)
      {
        if(channel.session)
        {
          dbg::detailed_log(lvl:1, src:fn, msg:"Inactivity timeout.");
        }
        this.timed_out = TRUE;
        return TRUE;
      }
      else if(isnull(channel))
      {
        return TRUE;
      }

      return FALSE;
    }

    ##
    # Stub for privilege escalation functions required by shell handlers
    #
    # @remark FortiOS doesn't have privilege escalation
    #
    # @return NULL
    ##
    public function set_priv_escalation(type, extra)
    {
      return NULL;
    }

    ##
    # Stub for privilege escalation functions required by shell handlers
    #
    # @remark FortiOS doesn't have privilege escalation
    #
    # @return NULL
    ##
    public function unset_priv_escalation()
    {
      return NULL;
    }
  }
}
