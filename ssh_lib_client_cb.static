#TRUSTED 71fc102fec7f04efc9242921c5790cddc0ebf42592efcd6a699fc58aa30525e45d928929484fc0e784699a3898460d564639aa78fe6ea5b8960170d6da4ab827aa5005848c8ca1514af639c001dec4a0a8b3a380cd68af3ca3e7e2a73c43b07fad589d57039de5944ad18d052a9bcc602252d44348645b73a979f422c9363b094c294e3115c79546908e5950e60a955f43d2fd39d5e9589f85d021d2b858d2f61e1878b1bc91dcafff97f3585101d0998a8b425fbf82597d9658f2c639a244729c03beb7bbee86b2477b5fd0355c072ac3c9eeec7d9429957c8928c14c035a23a688a88618bcecbf5bf61432cc68c7950e7113c32e7041fe558ea3fb675796156142ffff6251acc947e2de4854f832cb6099789cc561315922c829d70e4c83f7f50f8958ddfe075773fac74c1b131d8048b06d9fbcb33033badc623623fbe3e3263a71aa405c218613a6c9027d0a18602aa7319b55b4264b318ef034b2823d5919e5b7a60e54e2bd7d9a299e1ce7d5d3d032ad519bb907d972312d90a9ce8fbe808893eb5947cb79fff2fc754f84962243bd2291c4338cf67f8d6a35518c83af483e14231c0bed97ce3371370d0bb26512691598376efcd6cc30215c956341484032758830fb64c8cd460131e704d7d3a88f1a7a898c2c1285a373ccea76d0b165aedf9573148f9606ff036a2c39c2d12fae15066544241a47959143155ebb2c
#TRUST-RSA-SHA256 05c35ac4e1f38196c3f43395d8418fc8cc1c4070487a77ae177fe73a33b52968bde72f494298ef6ddc5527e3e4ec61ce7324a4147e646f0ad62f22ca4e89767654463c4ca66da739344fb3ac9337dabd8bb940c5360193fbc3fd220589df133ccce8cc4a375dbff2228d491121c39f7cfbe4683a0cf20ee4515e011faedc3ef27a1e74879e4da68fe7b5626982ba603b0010e3a5c00a603e04563e0b31e1c79aa8b219d414d1259dd04c24077b7c01b98c70214a9d90db066f755565646f47e96e896c42008557dfcacc9e1aa46b5f54f4253c832cd0195d00eed8d3a33bb5b1e2eb7225f83d6ec85f61e772bb0057c2922ae8eb848589cab1c5347c84dbd8685473cd8d7f6ff79ab385963d4b7dbd3d3a159ae3c340c974d944353006c2bd5eaddac4a8457c2307de084d76c03d01a9919e473218cd44b0c9356d2e5d7ee8ec7d25b4b0a6edeb51c37400c7a7474586b7bb6064a58c2aafaa65b6c11b0a2e4a11f0d466ffc238e022a91a48c55dcc37c0643359df2f7e4c87a202eb6963a3eb00cd54cb89c62ab10725877f4e3ab1fb0e01388ae053b31c121dc006ec796b5cafdbfbe1d4f359bea4ed7b26d8af8dfb9de0d8cc9a1e7aef17da1fec9715f5ca4aed26e62357e052789e4e1ac436d396e63720f54b90ebca40fde58941602f8da0ca61e0958762f75432cbdab61f4d732f58618ed33fdd67f889b09d063e2964
###
# Collection of callbacks to handle different SSH statuses and packets.
#
# @license
# (C) Tenable Network Security, Inc.
#
# This script is released under one of the Tenable Script Licenses and may not
# be used from within scripts released under another license without the
# authorization from Tenable Network Security Inc.
#
# Revision: 1.15
#
# @library ssh_lib.inc
# @category SSH
###

##
#
#  Namespace sshlib
#    Provides an encapsulated naming scope for sshlib functions and objects
#
##
namespace sshlib
{

  ##
  # default set of handlers for ssh client
  ##
  global_var SSH_CLIENT_HANDLERS = make_array(
    PROTO_SSH_MSG_KEXINIT,          @client_cb_begin_kex,
    PROTO_SSH_MSG_KEXDH_REPLY,      @client_cb_finalize_kex,
    PROTO_SSH_MSG_KEXDH_GEX_REPLY,  @client_cb_finalize_kex,
    PROTO_SSH_MSG_NEWKEYS,          @client_cb_new_keys,
    PROTO_SSH_MSG_EXT_INFO,         @client_cb_ext_info,
    
    PROTO_SSH_MSG_SERVICE_ACCEPT,   @client_cb_msg_service_accept,

    PROTO_SSH_MSG_USERAUTH_BANNER,        @client_cb_msg_userauth_banner,
    PROTO_SSH_MSG_USERAUTH_SUCCESS,       @client_cb_msg_userauth_success,
    PROTO_SSH_MSG_USERAUTH_INFO_REQUEST,  @client_cb_msg_userauth_info_request,
    PROTO_SSH_MSG_USERAUTH_FAILURE,       @client_cb_msg_userauth_failure,

    PROTO_SSH2_MSG_CHANNEL_OPEN_CONFIRMATION, @client_cb_channel_open_confirm,
    PROTO_SSH2_MSG_CHANNEL_OPEN_FAILURE,      @client_cb_channel_open_fail,
    PROTO_SSH2_MSG_CHANNEL_WINDOW_ADJUST,     @client_cb_channel_window_adjust,
    PROTO_SSH2_MSG_CHANNEL_DATA,              @client_cb_channel_data,
    PROTO_SSH2_MSG_CHANNEL_EXTENDED_DATA,     @client_cb_channel_extended_data,
    PROTO_SSH2_MSG_CHANNEL_EOF,               @client_cb_channel_eof,
    PROTO_SSH2_MSG_CHANNEL_CLOSE,             @client_cb_channel_close,
    PROTO_SSH2_MSG_CHANNEL_SUCCESS,           @client_cb_channel_success,
    PROTO_SSH2_MSG_CHANNEL_FAILURE,           @client_cb_channel_failure,
    PROTO_SSH2_MSG_CHANNEL_REQUEST,           @client_cb_channel_request,

    PROTO_SSH_MSG_GLOBAL_REQUEST, @client_cb_global_request,

    PROTO_SSH_MSG_DISCONNECT,      @client_cb_msg_disconnect,
    PROTO_SSH_MSG_IGNORE,          @client_cb_msg_ignore,
    PROTO_SSH_MSG_DEBUG,           @client_cb_msg_debug,

    PROTO_SSH_MSG_USERAUTH_GSSAPI_TOKEN,      @client_cb_userauth_gssapi_token,

    PROTO_SSH_MSG_USERAUTH_GSSAPI_ERROR,      @client_cb_userauth_gssapi_error,
    PROTO_SSH_MSG_USERAUTH_GSSAPI_ERRTOK,     @client_cb_userauth_gssapi_errtok,

    PROTO_SSH_MSG_UNIMPLEMENTED,   @client_cb_msg_unimplemented,

    -1, @client_cb_response_timeout
  );

  ##
  # sshrecv_until callbacks
  ##

  ##
  # Checks if the remote host has signaled that no more data will be sent
  # via a ``SSH_MSG_CHANNEL_EOF`` message.
  #
  # @param [session:object] An ``sshlib::session`` object (unused).
  # @param [channel:object] A channel object for the current SSH connection.
  #
  # @return [boolean|NULL] TRUE if the remote has indicated that no more data will be sent over this channel,
  #         ``FALSE`` or NULL otherwise.
  ##
  function client_cb_check_channel_eof(session, channel)
  {
    return channel.remote_eof;
  }

  ##
  # Checks the current channel to see if it is in a closed state.
  #
  # @param [session:object] An ``sshlib::session`` object (unused).
  # @param [channel:object] A channel object for the current SSH connection.
  #
  # @return [boolean] TRUE if the indicated channel is closed, ``FALSE`` otherwise.
  ##
  function client_cb_check_channel_closed(session, channel)
  {
    if(channel.state == CHANNEL_STATE_CLOSED)
      return TRUE;
    return FALSE;
  }

  ##
  # Checks if the remote host has accepted a channel request.
  #
  # @param [session:object] An ``sshlib::session`` object (unused).
  # @param [channel:object] A channel object for the current SSH connection.
  #
  # @return [boolean] TRUE if the remote host has sent a ``SSH_MSG_CHANNEL_OPEN_CONFIRMATION`` message
  #         indicating that it has opened a channel, ``FALSE`` otherwise.
  ##
  function client_cb_check_channel_not_pending(session, channel)
  {
    if(channel.state != CHANNEL_STATE_PENDING)
      return TRUE;
    return FALSE;
  }

  ##
  # Checks if a post-login error has occurred on the connection.
  #
  # @param [session:object] An ``sshlib::session`` object.
  # @param [channel:object] A channel object for the current SSH connection.
  #
  # @return [boolean] TRUE if a request to login as a different user or a post login error has occurred,
  #         otherwise returns ``FALSE``.
  ##
  function client_cb_post_login_error(session, channel)
  {
    var text = session.error + channel.data_buf + channel.stderr;
    if (
      ("Please login as the user" >< text && "rather than the user" >< text) ||
      "This account is currently not available" >< text ||
      "password has expired" >< text ||
      "could not get login name" >< text
    )
    {
      dbg::detailed_log(lvl:1, src:FUNCTION_NAME, msg:"Post-login error detected.");
      if("rather than the user" >< text || "not available" >< text)
        session.set_error(src:FUNCTION_NAME, err_msg:"The host requested that login be performed as a different user.");
      if("password has expired" >< text)
        session.set_error(src:FUNCTION_NAME, err_msg:"The account password has expired.");
      session.found_post_login_error();
      return TRUE;
    }
    else
    {
      return FALSE;
    }
  }

  ##
  # Checks for known /etc/profile.d/ssh_confirm.sh prompts and answers them if scan policy permits.
  #
  # @param [channel:object] channel for ssh session
  #
  # @return [bool|NULL] Returns TRUE if the prompt is rejected, NULL otherwise.
  # @category SSH
  ##
  function client_cb_check_ssh_confirm_prompt(channel)
  {
    var accept_disclaimer = get_one_kb_item("Settings/automatically_accept_disclaimer");
    var disa_consent_prompt = "Do you agree\? \[y/N\]\s*$";

    if(preg(pattern:disa_consent_prompt, string:channel.data_buf, multiline:TRUE))
    {
      replace_kb_item(name:SSH_LIB_KB_PREFIX + 'known_ssh_confirm_prompt', value:'DISA');
      if(accept_disclaimer)
      {
        dbg::detailed_log(lvl:2, src:FUNCTION_NAME, msg:
          "[channel " + channel.local_channel + "]: Sending 'y' to accept consent prompt.");
        channel.clear_data_buf();
        channel.window_send_data(data:'y\n');
      }
      else
      {
        dbg::detailed_log(lvl:2, src:FUNCTION_NAME, msg:
          "[channel " + channel.local_channel + "]: Sending 'N' to reject consent prompt.");
        channel.window_send_data(data:'N\n');
        return TRUE;
      }
    }
  }


  ##
  # packet handler callbacks
  ##

  ##
  # Handles timeouts during the receipt of SSH packets.
  #
  # @param [session:object] An ``sshlib::session`` object (unused).
  ##
  function client_cb_response_timeout(session)
  {
    dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'Entering handler.');
  }

  ##
  # Handles ``SSH_MSG_USERAUTH_BANNER`` messages that may contain a
  # pre-login legal warning or informational message.
  #
  # @param [session:object] An ``sshlib::session`` object.
  #
  # @remark
  # See the RFC to know more: https://www.ietf.org/rfc/rfc4252.txt
  ##
  function client_cb_msg_userauth_banner(session)
  {
    dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'Entering handler.');
    var userauth_banner = get_ssh_string(buffer:session.last_packet.payload, pos:0);
    if(strlen(userauth_banner) > 0)
      session.set_userauth_banner(userauth_banner);
  }

  ##
  # Handles ``SSH_MSG_CHANNEL_EXTENDED_DATA`` messages used to transmit
  # alternate types of data such as ``STDERR`` output.
  #
  # @param [session:object] An ``sshlib::session`` object.
  #
  # @remark
  # See the RFC to know more: https://www.ietf.org/rfc/rfc4254.txt
  ##
  function client_cb_channel_extended_data(session)
  {
    dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'Entering handler.');
    var channel = session.channel_manager.packets_channel(sshpkt:session.last_packet);
    if (!isnull(channel))
      channel.handle_extended_data_received(sshpkt:session.last_packet);
  }

  ##
  # Handles ``SSH_MSG_DISCONNECT`` messages indicating the termination of the SSH connection.
  #
  # @param [session:object] An ``sshlib::session`` object.
  #
  # @remark
  # See the RFC to know more: https://www.ietf.org/rfc/rfc4253.txt
  ##
  function client_cb_msg_disconnect(session)
  {
    dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'Entering handler.');
    session.close_connection();
  }

  ##
  # Handles ``SSH_MSG_GLOBAL_REQUEST`` messages used to communicate requests
  # that are not tied to a specific channel.
  #
  # @param [session:object] An ``sshlib::session`` object.
  #
  # @remark
  # See the RFC to know more: https://www.ietf.org/rfc/rfc4254.txt
  ##
  function client_cb_global_request(session)
  {
    dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'Entering handler.');
    var req = get_ssh_string(buffer:session.last_packet.payload, pos:0);

    if(req != '')
      dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'Received the global request: ' + req);

    session.sshsend(data:NULL, code:PROTO_SSH_MSG_REQUEST_FAILURE);
  }

  ##
  # Handles ``SSH_MSG_IGNORE`` messages.
  #
  # @param [session:object] An ``sshlib::session`` object (unused).
  #
  # @remark
  # See the RFC to know more: https://www.ietf.org/rfc/rfc4253.txt
  ##
  function client_cb_msg_ignore(session)
  {
    dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'Entering handler.');
  }

  ##
  # Handles ``SSH_MSG_DEBUG`` messages that may contain information useful for debugging.
  #
  # @param [session:object] An ``sshlib::session`` object (unused).
  #
  # @remark
  # See the RFC to know more: https://www.ietf.org/rfc/rfc4253.txt
  ##
  function client_cb_msg_debug(session)
  {
    dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'Entering handler.');
  }

  ##
  # Handles ``SSH_MSG_UNIMPLEMENTED`` messages that indicate the receipt of an unrecognized message.
  #
  # @param [session:object] An ``sshlib::session`` object.
  #
  # @remark
  # See the RFC to know more: https://www.ietf.org/rfc/rfc4253.txt
  ##
  function client_cb_msg_unimplemented(session)
  {
    dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'Entering handler.');
    session.close_connection();

    exit(1, "Received SSH_MSG_UNIMPLEMENTED from remote SSH server.");
  }

  ##
  # Handles ``SSH_MSG_CHANNEL_DATA`` messages which are the primary SSH data transfer mechanism.
  #
  # @param [session:object] An ``sshlib::session`` object.
  #
  # @remark
  # See the RFC to know more: https://www.ietf.org/rfc/rfc4254.txt
  ##
  function client_cb_channel_data(session)
  {
    dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'Entering handler.');
    var channel = session.channel_manager.packets_channel(sshpkt:session.last_packet);

    if (!isnull(channel))
      channel.handle_data_received(sshpkt:session.last_packet);
  }

  ##
  # Handles ``SSH_MSG_CHANNEL_EOF`` messages that announce that the remote host will send no more data.
  #
  # @param [session:object] An ``sshlib::session`` object.
  #
  # @remark
  # See the RFC to know more: https://www.ietf.org/rfc/rfc4254.txt
  ##
  function client_cb_channel_eof(session)
  {
    dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'Entering handler.');
    var channel = session.channel_manager.packets_channel(sshpkt:session.last_packet);

    if (!isnull(channel))
      channel.remote_eof();
  }

  ##
  # Handles ``SSH_MSG_CHANNEL_REQUEST`` messages which contain channel specific requests.
  #
  # @param [session:object] An ``sshlib::session`` object.
  #
  # @remark
  # See the RFC to know more: https://www.ietf.org/rfc/rfc4254.txt
  ##
  function client_cb_channel_request(session)
  {
    dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'Entering handler.');
    var channel = session.channel_manager.packets_channel(sshpkt:session.last_packet);

    if (!isnull(channel))
      channel.handle_request(sshpkt:session.last_packet);
  }

  ##
  # Handles ``SSH_MSG_CHANNEL_SUCCESS`` messages which accept a channel request.
  #
  # @param [session:object] An ``sshlib::session`` object.
  #
  # @remark
  # See the RFC to know more: https://www.ietf.org/rfc/rfc4254.txt
  ##
  function client_cb_channel_success(session)
  {
    dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'Entering handler.');
    var channel = session.channel_manager.packets_channel(sshpkt:session.last_packet);

    if (!isnull(channel))
      channel.set_response(TRUE);
  }

  ##
  # Handles ``SSH_MSG_CHANNEL_FAILURE`` messages which reject a channel request.
  #
  # @param [session:object] An ``sshlib::session`` object.
  #
  # @remark
  # See the RFC to know more: https://www.ietf.org/rfc/rfc4254.txt
  ##
  function client_cb_channel_failure(session)
  {
    dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'Entering handler.');
    var channel = session.channel_manager.packets_channel(sshpkt:session.last_packet);

    if (!isnull(channel))
      channel.set_response(FALSE);
  }

  ##
  # Handles ``SSH_MSG_CHANNEL_WINDOW_ADJUST`` messages which contain how many bytes
  # we can send before we have to wait for another window size adjustment.
  #
  # @param [session:object] An ``sshlib::session`` object.
  #
  # @remark
  # See the RFC to know more: https://www.ietf.org/rfc/rfc4254.txt
  ##
  function client_cb_channel_window_adjust(session)
  {
    dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'Entering handler.');
    var channel = session.channel_manager.packets_channel(sshpkt:session.last_packet);

    if (!isnull(channel))
      channel.handle_window_adjust(sshpkt:session.last_packet);
  }

  ##
  # Handles ``SSH_MSG_CHANNEL_OPEN_CONFIRMATION`` messages, which accept a ``SSH_CHANNEL_OPEN`` request.
  #
  # @param [session:object] An ``sshlib::session`` object.
  #
  # @remark
  # See the RFC to know more: https://www.ietf.org/rfc/rfc4254.txt
  ##
  function client_cb_channel_open_confirm(session)
  {
    dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'Entering handler.');
    var channel = session.channel_manager.packets_channel(sshpkt:session.last_packet);

    if (!isnull(channel))
      channel.handle_channel_confirmation(sshpkt:session.last_packet);
  }

  ##
  # Handles ``SSH_MSG_CHANNEL_OPEN_FAILURE`` messages which reject a ``SSH_CHANNEL_OPEN`` request.
  #
  # @param [session:object] An ``sshlib::session`` object.
  #
  # @remark
  # See the RFC to know more: https://www.ietf.org/rfc/rfc4254.txt
  ##
  function client_cb_channel_open_fail(session)
  {
    dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'Entering handler.');
    var channel = session.channel_manager.packets_channel(sshpkt:session.last_packet);

    if (!isnull(channel))
      channel.handle_channel_open_failure(sshpkt:session.last_packet);
    session.channel_manager.remove_channel(channel:channel);
  }

  ##
  # Handles ``SSH_MSG_CHANNEL_CLOSE`` messages sent by the remote host to close the channel.
  #
  # @param [session:object] An ``sshlib::session`` object.
  #
  # @remark
  # See the RFC to know more: https://www.ietf.org/rfc/rfc4254.txt
  ##
  function client_cb_channel_close(session)
  {
    dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'Entering handler.');
    var channel = session.channel_manager.packets_channel(sshpkt:session.last_packet);

    if (isnull(channel))
      return NULL;

    # Remove the channel from channel_manager before calling channel.close()
    # in case close_socket() gets called by sshsend() to clean up objects
    session.channel_manager.remove_channel(channel:channel);

    if (channel.state != CHANNEL_STATE_CLOSED)
      channel.close();
  }

  ##
  # Handles ``SSH_MSG_SERVICE_ACCEPT`` messages which indicate support for a service requested with ``SSH_MSG_SERVICE_REQUEST``
  #
  # @param [session:object] An ``sshlib::session`` object.
  #
  # @remark
  # See the RFC to know more: https://www.ietf.org/rfc/rfc4253.txt
  ##
  function client_cb_msg_service_accept(session)
  {
    dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'Entering handler.');
    session.cur_state.set("SERVICE_REQUEST_SUCCESS");
  }

  ##
  # Handles ``SSH_MSG_USERAUTH_SUCCESS`` messages, which indicates authentication success.
  #
  # @param [session:object] An ``sshlib::session`` object.
  #
  # @remark
  # See the RFC to know more: https://www.ietf.org/rfc/rfc4252.txt
  ##
  function client_cb_msg_userauth_success(session)
  {
    dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'Entering handler.');
    session.cur_state.set("USERAUTH_SUCCESS");

    if(session.compression_alg_c_to_s == "zlib@openssh.com")
      session.enable_compression(mode:MODE_OUT);
    if(session.compression_alg_s_to_c == "zlib@openssh.com")
      session.enable_compression(mode:MODE_IN);
  }

  ##
  # Handles ``SSH_MSG_USERAUTH_FAILURE`` messages, which reject an authentication request.
  #
  # @param [session:object] An ``sshlib::session`` object.
  #
  # @remark
  # See the RFC to know more: https://www.ietf.org/rfc/rfc4252.txt
  ##
  function client_cb_msg_userauth_failure(session)
  {
    dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'Entering handler.');
    session.cur_state.set("USERAUTH_FAILURE");
  }

  ##
  # Handles ``SSH_MSG_USERAUTH_INFO_REQUEST`` and ``SSH_MSG_USERAUTH_PK_OK``
  # messages which share the same SSH message id.
  #
  # @param [session:object] An ``sshlib::session`` object.
  #
  # @remark
  # See the RFC to know more: https://www.ietf.org/rfc/rfc4256.txt and https://www.ietf.org/rfc/rfc4252.txt
  ##
  function client_cb_msg_userauth_info_request(session)
  {
    dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'Entering handler.');
    if(session.cur_state.val == "USERAUTH_GSSAPI_REQUEST")
      client_cb_userauth_gssapi_response(session:session);
    else if(session.cur_state.val == "USERAUTH_PK_REQUEST")
      client_cb_msg_userauth_pk_ok(session:session);
    else
      session.cur_state.set("USERAUTH_INFO_REQ");
  }

  ##
  # Handles ``SSH_MSG_USERAUTH_PK_OK`` messages accepting a public key presented for authentication.
  #
  # @param [session:object] An ``sshlib::session`` object.
  #
  # @remark
  # See the RFC to know more: https://www.ietf.org/rfc/rfc4252.txt
  ##
  function client_cb_msg_userauth_pk_ok(session)
  {
    dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'Entering handler.');
    session.cur_state.set("USERAUTH_PK_OK");
  }

  ##
  # Handles ``SSH_MSG_USERAUTH_INFO_REQUEST`` messages sent to request information for authentication.
  #
  # @param [session:object] An ``sshlib::session`` object.
  #
  # @remark
  # See the RFC to know more: https://www.ietf.org/rfc/rfc4256.txt
  ##
  function client_cb_userauth_gssapi_response(session)
  {
    dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'Entering handler.');
    session.cur_state.set("USERAUTH_GSSAPI_RESPONSE");
  }

  ##
  # Handles ``SSH_MSG_USERAUTH_GSSAPI_TOKEN`` messages, which request a MIC
  # to complete the gssapi-with-mic exchange.
  #
  # @param [session:object] An ``sshlib::session`` object.
  #
  # @remark
  # See the RFC to know more: https://www.ietf.org/rfc/rfc4462.txt
  ##
  function client_cb_userauth_gssapi_token(session)
  {
    dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'Entering handler.');
    session.cur_state.set("USERAUTH_GSSAPI_TOKEN");
  }

  ##
  # Handles ``SSH_MSG_USERAUTH_GSSAPI_ERROR`` messages, which indicate a GSSAPI authentication failure.
  #
  # @param [session:object] An ``sshlib::session`` object.
  #
  # @remark
  # See the RFC to know more: https://www.ietf.org/rfc/rfc4462.txt
  ##
  function client_cb_userauth_gssapi_error(session)
  {
    dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'Entering handler.');
    session.cur_state.set("USERAUTH_GSSAPI_ERROR");
  }

  ##
  # Handles ``SSH_MSG_USERAUTH_GSSAPI_ERRTOK`` messages, which indicate a GSSAPI authentication failure.
  #
  # @param [session:object] An ``sshlib::session`` object.
  #
  # @remark
  # See the RFC to know more: https://www.ietf.org/rfc/rfc4462.txt
  ##
  function client_cb_userauth_gssapi_errtok(session)
  {
    dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'Entering handler.');
    session.cur_state.set("USERAUTH_GSSAPI_ERRTOK");
  }

  ##
  # Handles ``SSH_MSG_NEWKEYS`` messages, which provide parameters used to encrypt further communication.
  #
  # @param [session:object] An ``sshlib::session`` object.
  #
  # @return [NULL] This function implicitely returns NULL, but if the session object
  #         did not initialize a new cipherset object, it will return the return value of `sshlib::session.close_socket()`_.
  #
  # @remark
  # See the RFC to know more: https://www.ietf.org/rfc/rfc4253.txt
  ##
  function client_cb_new_keys(session)
  {
    dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'Entering handler.');

    if(!session.new_cipherset)
      return session.close_socket(error:"Packet type 'SSH_MSG_NEWKEYS' was received before cipherset was established.");

    dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'SSH_MSG_NEW_KEYS Received! Updating ciphers.');

    # "zlib" compression method is enabled directly after ``NEWKEYS``
    if(session.compression_alg_c_to_s == "zlib")
      session.enable_compression(mode:MODE_OUT);
    if(session.compression_alg_s_to_c == "zlib")
      session.enable_compression(mode:MODE_IN);

    # re-initialize streams if compression was enabled previously using zlib@openssh.com
    if(session.compression_enabled_c_to_s && "zlib@openssh.com" == session.compression_alg_c_to_s)
      session.enable_compression(mode:MODE_OUT);
    if(session.compression_enabled_s_to_c && "zlib@openssh.com" == session.compression_alg_s_to_c)
      session.enable_compression(mode:MODE_IN);

    # these are not likely to happen, but handle it here just in case
    if(session.compression_alg_c_to_s == "none" && session.compression_enabled_c_to_s)
      session.disable_compression(mode:MODE_OUT);
    if(session.compression_alg_s_to_c == "none" && session.compression_enabled_s_to_c)
      session.disable_compression(mode:MODE_IN);

    session.new_keys();
    session.cur_state.set("KEX_DONE");
  }

  ##
  # Handles ``SSH_MSG_EXT_INFO`` messages, which provide parameters used to encrypt further communication.
  #
  # @param [session:object] An ``sshlib::session`` object.
  #
  # @remark
  # See the RFC to know more: https://www.ietf.org/rfc/rfc4253.txt
  ##
  function client_cb_ext_info(session)
  {
    dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'Entering handler.');
    var tmp, pos, i, algo, supported_list;
    var nr_extensions, extension, extension_results;
    var supported_array = {};
    var pkt = session.last_packet.payload;

    pos = 0;
    nr_extensions = getdword(blob:pkt, pos:pos, order:BYTE_ORDER_BIG_ENDIAN); 
    pos += 4;

    for (i=0; i<nr_extensions;i++)
    {
      extension = get_ssh_string(buffer:pkt, pos:pos);
      pos += strlen(extension) + 4;
      extension_results = get_ssh_string(buffer:pkt, pos:pos);
      pos += strlen(extension_results) + 4;
      if (extension == 'server-sig-algs')
      {
        supported_list = split(extension_results, sep:",", keep:FALSE);
        foreach algo (supported_list)
        {
          supported_array[algo] = 1;
        }

        algo = NULL;
        if (supported_array["rsa-sha2-512"])
        {
          algo = "rsa-sha2-512";
        }
        else if (supported_array["rsa-sha2-256"])
        {
          algo = "rsa-sha2-256";
        }
        else
        {
          # If no SHA2, leave the rsa label default
          algo = "ssh-rsa";
        }
        session.dbg_log(lvl:3, src:FUNCTION_NAME, msg:"Setting RSA key connection label as: "+algo);
        session.set_rsa_connection_label(algo);
      }
    }
  }


  ##
  # Handles ``SSH_MSG_KEXINIT`` messages, which acknowledge receipt of a
  # ``SSH_MSG_KEXINIT`` and provide parameters for key exchange.
  #
  # @param [session:object] An ``sshlib::session`` object.
  #
  # @return [NULL] This function always implicitely returns NULL, or the return value of
  #         `sshlib::session.close_socket()`_  or `sshlib::session.set_error()`_ if an error occurred.
  #
  # @remark
  # See the RFC to know more: https://www.ietf.org/rfc/rfc4253.txt
  ##
  function client_cb_begin_kex(session)
  {
    dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'Entering handler.');
    
    session.cur_state.set("KEX_BEGIN");

    var pkt = session.last_packet;
    var remote_init = pkt.payload;
    var namelists = session.kex_handler.kex_pkt_parse_namelists(pkt);
    session.kex_handler.set_remote_cookie(substr(pkt.payload, 0, 15));

    session.kex_handler.set_remote_init_pkt(remote_init);
    _server_algo = pkt.raw;

    # Error parsing namelists
    if(isnull(namelists))
      return session.close_socket(error:"Error parsing key exchange name lists.");

    session.kex_handler.set_kex_recv_namelists(namelists);

    var namelist, algo;
    foreach namelist (keys(session.kex_handler.kex_supported_namelists))
    {
      # we don't care about language, we'll connect to anything :)
      if("language" >< namelist)
        continue;
      algo = session.kex_handler.select_algorithm(namelist:namelist);

      if(!algo)
      {
        var err_msg =
          "Nessus does not support any " + namelist +
          " offered by the server: " + session.kex_handler.get_kex_recv_namelist(namelist);
        return session.close_socket(error:err_msg);
      }
      session.kex_handler.set_algorithm(namelist,algo);

      # Support rsa-specific connection labels based on what's available
      if (namelist == "server_host_key_algorithms")
        determine_rsa_connection_label(session:session);
    }

    session.kex_handler.generate_ssh_cookie();

    # send back our cookie + supported algorithms
    var init_pkt = session.kex_handler.our_cookie;
    var nlist;
    foreach namelist (KEX_NAME_LISTS)
    {
      nlist = session.kex_handler.kex_supported_namelists[namelist];

      if(isnull(nlist))
        nlist = "";
      init_pkt += mk_ssh_string(nlist);
    }

    init_pkt += crap(data:'\0', length:5); # boolean + uint32 (remaining fields)
    session.sshsend(data:init_pkt, code:PROTO_SSH_MSG_KEXINIT);

    if(session.cur_state.val == "SOC_CLOSED")
      return session.set_error(src:FUNCTION_NAME, err_msg:"Socket already closed when attempting to send KEXINIT packet.");

    session.kex_handler.set_our_init_pkt(init_pkt);

    if(session.kex_handler.kex_alg == "diffie-hellman-group-exchange-sha1" ||
       session.kex_handler.kex_alg == "diffie-hellman-group-exchange-sha256")
    {
      # Send group request
      pkt =
        # minimal size in bits of group
        mkdword(MIN_DH_GROUP_SIZE, order:BYTE_ORDER_BIG_ENDIAN) +
        # preferred size in bits of group
        mkdword(PRF_DH_GROUP_SIZE, order:BYTE_ORDER_BIG_ENDIAN) +
        # maximal size in bits of group
        mkdword(MAX_DH_GROUP_SIZE, order:BYTE_ORDER_BIG_ENDIAN);
      session.sshsend(data:pkt, code:PROTO_SSH_MSG_KEXDH_GEX_REQUEST);

      return;
    }

    var cipherset = new("sshlib::cipherset");
    session.set_new_cipherset(cipherset);
    session.init_new_crypto();

    if(session.kex_handler.kex_alg =~ "^ecdh-sha2-")
    {
      var nid;
      if(session.kex_handler.kex_alg == "ecdh-sha2-nistp256")
        nid = curve_nid.nist.P256;
      if(session.kex_handler.kex_alg == "ecdh-sha2-nistp384")
        nid = curve_nid.nist.P384;
      if(session.kex_handler.kex_alg == "ecdh-sha2-nistp521")
        nid = curve_nid.nist.P521;

      if(!session.kex_handler.ecdh_gen_secret_key(nid:nid))
        return session.close_socket(error:'ecdh_gen_secret_key() failed.');

      # transmit key in uncompressed format - see http://www.secg.org/sec1-v2.pdf sec. 2.3.3
      pkt = mk_ssh_string('\x04' + session.kex_handler.ecdh_local_pub.x + session.kex_handler.ecdh_local_pub.y);
    }
    else if(session.kex_handler.kex_alg =~ "^curve25519-sha256")
    {
      if(!session.kex_handler.ecdh_gen_25519_key())
        return session.close_socket(error:'ecdh_gen_25519_key() failed.');

      pkt = mk_ssh_string(session.kex_handler.ecdh_x25519_local.get_raw_public_key());
    }
    else
    {
      var dh_group = ereg_replace(pattern:"-[^-]+$", string:session.kex_handler.kex_alg, replace:"");
      var p = DH_CONSTANT_GROUP_P_AND_G[dh_group]["p"];
      var g = DH_CONSTANT_GROUP_P_AND_G[dh_group]["g"];

      session.kex_handler.set_dh_groups(p:p, g:g);

      if(!session.kex_handler.dh_gen_key())
        return session.close_socket(error:'dh_gen_key() failed.');

      pkt = mk_ssh_mpint(session.kex_handler.dh_local_pub);
    }

    session.sshsend(data:pkt, code:PROTO_SSH_MSG_KEXDH_INIT);
  }

  ##
  # Handles ``PROTO_SSH_MSG_KEXDH_REPLY`` and ``PROTO_SSH_MSG_KEXDH_GEX_REPLY`` messages,
  # which provide parameters to compute a shared encryption key.
  #
  # @param [session:object] An ``sshlib::session`` object.
  #
  # @return [NULL] This function always implicitely returns NULL, or the return value of
  #         `sshlib::session.close_socket()`_ if an error occurred.
  #
  # @remark
  # See the RFC to know more: https://www.ietf.org/rfc/rfc4253.txt
  ##
  function client_cb_finalize_kex(session)
  {
    dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'Entering handler.');

    # still need p and g
    if(isnull(session.new_cipherset) && (session.kex_handler.kex_alg == "diffie-hellman-group-exchange-sha1" ||
                                         session.kex_handler.kex_alg == "diffie-hellman-group-exchange-sha256"))
    {
      var pkt = session.last_packet;

      var p, g, tmp, pos, err_msg;
      tmp = get_ssh_mpint(buffer:pkt.payload, pos:0);

      if(isnull(tmp) || empty_or_null(tmp['value']) || isnull(tmp['length']))
        return session.close_socket(error:"Unable to parse DH base or modulus.");

      p = tmp['value'];
      pos = tmp['length'];

      tmp = get_ssh_mpint(buffer:pkt.payload, pos:pos);
      if(isnull(tmp) || empty_or_null(tmp['value']) || isnull(tmp['length']))
        return session.close_socket(error:"Unable to parse DH base or modulus.");

      g = tmp['value'];

      if(strlen(p) > (MAX_DH_GROUP_SIZE/8))
      {
        err_msg =
          "DH Modulus length (" + (strlen(p)*8) + " bits) is greater than maximum modulus length (" +
          MAX_DH_GROUP_SIZE + " bits).";
        return session.close_socket(error:err_msg);
      }

      if(strlen(p) < (MIN_DH_GROUP_SIZE/8))
      {
        err_msg =
          "DH Modulus length (" + (strlen(p)*8) + " bits) is less than minimum modulus length (" +
          MIN_DH_GROUP_SIZE + " bits).";
        return session.close_socket(error:err_msg);
      }

      if(isnull(g) || !strlen(g))
        return session.close_socket(error:"Invalid DH value for g.");

      dbg::detailed_log(
        lvl:3,
        src:FUNCTION_NAME,
        msg:'Parsed the following p and g parameters.',
        msg_details:{
          'p':{'lvl':3, 'value':hexstr(p)},
          'g':{'lvl':3, 'value':hexstr(g)}});

      session.kex_handler.set_dh_groups(p:p, g:g);
      var cipherset = new("sshlib::cipherset");

      session.set_new_cipherset(cipherset);

      session.init_new_crypto();

      if(!session.kex_handler.dh_gen_key())
        return session.close_socket(error:'dh_gen_key() failed.');

      pkt = mk_ssh_mpint(session.kex_handler.dh_local_pub);
      session.sshsend(data:pkt,code:PROTO_SSH_MSG_KEXDH_GEX_INIT);

      return NULL;
    }
    # this function will set session error message and return NULL if
    # there is a problem.  you might want to refactor this
    if(isnull(session.kex_handler.parse_host_cert()))
      return session.close_socket(error:"error parsing host certificate.");

    # If a certificate was provided by the server rather than a public key,
    # verify that the signature is valid
    if(!isnull(session.kex_handler.host_cert))
    {
      if(!session.kex_handler.verify_ssh_cert_signature(session.kex_handler.host_cert))
        return session.close_socket(error:"Invalid signature on " + session.kex_handler.server_host_key_alg + " host certificate.");
      else
        session.dbg_log(lvl:3, src:FUNCTION_NAME, msg:"Verified host certificate signature.");
    }

    if(!session.ignore_known_hosts)
    {
      if(!isnull(session.kex_handler.host_cert))
      {
        if(!session.kex_handler.verify_known_hosts(cert:session.kex_handler.host_cert))
          session.close_socket(error:"Verification of SSH server certificate against known_hosts failed.");
      }
      else
      {
        if(!session.kex_handler.verify_known_hosts(key:session.remote_host_key, key_type:session.kex_handler.auth_alg))
          session.close_socket(error:"Verification of SSH server public key against known_hosts failed.");
      }
    }

    session.sshsend(data:NULL, code:PROTO_SSH_MSG_NEWKEYS);
    if(session.cur_state.val == "SOC_CLOSED")
      return session.set_error(src:FUNCTION_NAME, err_msg:"Socket already closed when attempting to send SSH_MSG_NEW_KEYS packet.");
  }

  ##
  # Handles responses by the remote host to "exec" commands sent via an ``SSH_MSG_CHANNEL_REQUEST`` message.
  #
  # @param [session:object] An ``sshlib::session`` object.
  #
  # @return [boolean] TRUE if the remote host has closed the channel or the remote host does not support the command.
  #         Otherwise it will return the return value of `sshlib::client_cb_check_channel_closed()`_.
  #
  # @remark
  # See the RFC to know more: https://www.ietf.org/rfc/rfc4254.txt
  ##
  function run_exec_command_cb(session, channel)
  {
    dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'Entering handler.');
    var buf = tolower(channel.data_buf);
    # Check for pk-command-not-found prompt and close channel if found
    if ("install package" >< buf && "to provide command" >< buf)
    {
      session.set_cmd_error(chomp(channel.data_buf));
      session.set_cmd_error("Prompt to install missing command detected. Closing channel.");
      channel.clear_data_buf();
      channel.close();
      return TRUE;
    }

    return client_cb_check_channel_closed(session:session, channel:channel);
  }


  ##
  # Callback function to check for prompt of rate-limited devices in the channel's data buffer.
  #
  # @param [session:object] An ``sshlib::session`` object (unused).
  # @param [channel:object] An ``sshlib::channel`` object.
  #
  # @return [boolean|NULL] TRUE if a rate-limited device's prompt was detected, NULL otherwise.
  ##
  function rate_limiting_check_cb(session, channel)
  {
    var last6;
    if(strlen(channel.data_buf) == 0)
      last6 = " ";
    else if(strlen(channel.data_buf) < 6)
      last6 = channel.data_buf;
    else
      last6 = substr(channel.data_buf, strlen(channel.data_buf) - 6);

    if ("access denied" >< tolower(channel.data_buf))
      return TRUE;
    if ("junos" >< tolower(channel.data_buf))
      return TRUE;
    if ("juniper" >< tolower(channel.data_buf))
      return TRUE;
    if ("omniswitch" >< tolower(channel.data_buf))
      return TRUE;
    if ("#" >< last6 || ">" >< last6 || "$" >< last6 || "%" >< last6)
      return TRUE;

    return client_cb_check_ssh_confirm_prompt(channel:channel);
  }


  ##
  # Callback function to check for password prompt of rate-limited devices in the channel's data buffer.
  #
  # @param [session:object] An ``sshlib::session`` object (unused).
  # @param [channel:object] An ``sshlib::channel`` object.
  #
  # @return [boolean|NULL] TRUE if a rate-limited device's password prompt was detected, NULL otherwise.
  ##
  function rate_limiting_check_password_prompt_cb(session, channel)
  {
    if ("password:" >< tolower(channel.data_buf))
    {
      return TRUE;
    }
  }

  ##
  # Callback function to check for markers of password submission success
  # on Sonicwall devices in the channel's data buffer.
  #
  # @param [session:object] An ``sshlib::session`` object (unused).
  # @param [channel:object] An ``sshlib::channel`` object.
  #
  # @return [boolean|NULL] TRUE if markers of password submission success were detected, NULL otherwise.
  ##
  function sonicwall_is_password_success_cb(session, channel)
  {
    var last6;
    if(strlen(channel.data_buf) == 0)
      last6 = " ";
    else if(strlen(channel.data_buf) < 6)
      last6 = channel.data_buf;
    else
      last6 = substr(channel.data_buf, strlen(channel.data_buf) - 6);

    if("must be changed" >< channel.data_buf)
      return TRUE;
    if(">" >< last6 && "access denied" >!< tolower(channel.data_buf))
      return TRUE;
  }

  ##
  # Callback function to check the channel's data buffer for the username
  # prompt on Cisco Wireless LAN Controller (WLC) devices.
  # 
  # @param [session:object] An ``sshlib::session`` object (unused).
  # @param [channel:object] An ``sshlib::channel`` object.
  #
  # @return [boolean] TRUE if the username prompt was detected, FALSE otherwise.
  ##
  function cisco_wlc_user_prompt_cb(session, channel)
  {
    return (channel.data_buf =~ "\nUser:\s?$");
  }

  ##
  # Callback function to check the channel's data buffer for the password
  # prompt on Cisco Wireless LAN Controller (WLC) devices.
  # 
  # @param [session:object] An ``sshlib::session`` object (unused).
  # @param [channel:object] An ``sshlib::channel`` object.
  #
  # @return [boolean] TRUE if the password prompt was detected, FALSE otherwise.
  ##
  function cisco_wlc_password_cb(session, channel)
  {
    return (channel.data_buf =~ "\nPassword:\s?$");
  }

  ##
  # Callback function to check the end of the channel's data buffer for the
  # username or command prompt on Cisco Wireless LAN Controller (WLC) devices.
  #
  # @remark
  # This function should be used to determine if password authentication was successful on Cisco WLC.
  # If the scan is back at the username prompt then auth failed, if it is as the command prompt
  # it means auth succeeded.
  # 
  # @param [session:object] An ``sshlib::session`` object (unused).
  # @param [channel:object] An ``sshlib::channel`` object.
  #
  # @return [boolean] TRUE if the channel's data buffer ends with the username or command prompt, FALSE otherwise.
  ##
  function cisco_wlc_login_cb(session, channel)
  {
    return (channel.data_buf =~ "\nUser:\s?$" || channel.data_buf =~ "\n\(Cisco Controller\) >$");
  }

  ##
  # Determines an appropriate RSA connection label based on the available entries in the
  # namelist gathered during KEX completion.
  #
  # @param [session:object] An ``sshlib::session`` object.
  #
  # @return [string] The algoritm selected if there is an appopriate label supported,
  #         otherwise it will return "ssh-rsa". 
  #
  # @remark
  # For this function to run properly, the list of server host key
  # algorithms should have been populated by the KEX handler object.
  #
  # If an appropriate label is found in the name list, this function will call
  # `sshlib::session.set_rsa_connection_label()`_ to set the label in the session object.
  ##
  function determine_rsa_connection_label(session)
  {
    var algo;
    var supported_array = {};
    if (isnull(session) || isnull(session.kex_handler) ||
        empty_or_null(session.kex_handler.kex_recv_namelists) ||
        empty_or_null(session.kex_handler.kex_recv_namelists["server_host_key_algorithms"]) )
    {
      dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg: "Unable to access kex_recv_namelists, returning default of ssh-rsa.");
      return "ssh-rsa";
    }

    var supported_list = split(session.kex_handler.kex_recv_namelists["server_host_key_algorithms"], sep:",", keep:FALSE);
    foreach algo (supported_list)
    {
      supported_array[algo] = 1;
    }

    algo = NULL;
    if (supported_array["rsa-sha2-512"])
    {
      algo = "rsa-sha2-512";
    }
    else if (supported_array["rsa-sha2-256"])
    {
      algo = "rsa-sha2-256";
    }
    else
    {
      # If no SHA2, leave the rsa label default
      algo = "ssh-rsa";
    }
    session.dbg_log(lvl:3, src:FUNCTION_NAME, msg:"Setting rsa key connection label as: " + algo);
    session.set_rsa_connection_label(algo);
    return algo;
  }
}
