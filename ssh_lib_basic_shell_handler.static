#TRUSTED 29ad8c731bda845471952fe9fb638100c387447885aee41313483ccff101876359f4192e2695dea6c960858d37bdf3434e9f8d42302bc058a788f3bd973bf4f9228542896660da1d7a52e9a8701b92d605377c3d295f4839a1285a998373c3e8f551c7648b559a412010c55fc36c09fc399a8fac82fbcfd58aa7d8f7b4e20e325f271e48be2ffb13dae89e78f32d5026d01c5c86b029d59bc392204e679414f53bdaf5ff092bbaa1b0b372d0f48bcfd5343aab0c40da5cb5fb0a12f513d2cbcfd8b700d94655dd3a8dd3a62e1ed24525d548a6a9664cb614191c1fc8ed49ee0262501774de03d3fe521c9627ed5c6186756dcf628490b1bbc51fbfbe5858a2c32a84ca1937c73d37803a01bfef190a5f07fdf59748f68105e289a8a33fc05b9d2b4518d2f806ed24f6b5433cb33073f77aa4fab8bdc703871b07e65b00d9e6a586b44623d848e7b6eb3bf7646a170bc5e378bdb024a73e6186471914806bf03da705632ea83fdf5376edf3f1dad1a12c2fe9e61d682f7ecdc2c579b33889c159725375c7355c7759f2094bcf750fb4768d94469c29014c700361c9fe917c0df9df2467d0678a6288fcfd150540e81e09356379c16c62b20e5e9f6de1d99bad98a0e991bd167d8697b7b8a4a03a8f99f3e2da894e5c94476bee04bbf110a78fb209710eb97f2feb878175757ad839a2f38a3c50cf8ea0014dd2e5021dfb3843c8
#TRUST-RSA-SHA256 525ca5d29d51f2252fb42e83f4be0543921c55a9bccd704566f7ef1ce6ceda562666907b0778f48b0f67e004bfadd54f621ff2942a8f792ae686ae3250e5d3e49a6746b9cc97a1d0f7544a0fb5e2210a47a6e3ab82a372b6a559eb9d26f057b67b9f12d879ccb0cb031c7c798b38ca70b6b520bdfde938d71dad571f46996ddc08999d907b76f5b1ab28e50c1cbe76b395a49d2d7b46007b8cd2e07054cc3e8deb70d5e5b4fa24cbeb371ad06a609baa2e80a97ca14c2dc61fdf2a1b21d1d3d4c72afa13830ba16ef75d7765ffd4c0826ef7657c15ba2edcce9572a90717b01997c4bb8c8deff616511edddef06543b6a5b684bcfd3c998f9ea08ae0664d929285262a0aebfa0c88626fc1692d6e937d4934ce59ef2539938d85fbd0255eb8b9ef8dbbfb4ac068769a9a50f33041aa81c626418d169853b655b633d745c4d6d3ec7638178ec752957d5028e351ff99a00aa777b2a95f7d0bbc0bda5ba949ab9f1518554b38475e563031e7eb7d0fb61d122f3d8a7658512696720721a97a7a9b5962134c4492df536044bd11bb8c70c02069b6f5139e7a14d5f65c47a44f4df9d65c562089d9f792ec3c28d1c54da5edd6332528f9fa119db9c847f386d91d039e7d64ca48bccdb4ccdd91fe8d0d33c44bb90970e4e1fa827357b9adbabb3d0de6166532698542a2dac3e17d28e11d3c1c3b61353b6a8a746150a6aba17f245b
###
# (C) Tenable Network Security, Inc.
#
# This script is released under one of the Tenable Script Licenses and may not
# be used from within scripts released under another license without the
# authorization from Tenable Network Security Inc.
#
# @NOGPL@
#
# Revision: 1.22
#
###

namespace sshlib
{
  DEFAULT_PRIV_ESCL_WARNING_TIMEOUT = 3;
  global_var _BASIC_DEFAULT_INACTIVITY_TIMEOUT = 60;
  global_var _BASIC_INITIAL_INACTIVITY_TIMEOUT = 20;
  global_var _BASIC_DEFAULT_CMD_TIMEOUT = NULL;

  ### RECV_UNTIL CALLBACKS ###

  ##
  # callback function that checks for either a timeout or buffer update
  #
  # @param session session handle for ssh session
  # @param channel channel for ssh session
  #
  # @return TRUE if timeout reached
  # @category SSH
  ##
  function basic_shell_handler_on_channel_buffer_update_or_timeout(&session, &channel)
  {
    var sh = channel.shell_handler;
    if(!sh) return channel_closed_return_true(channel:channel);
    return sh.on_channel_buffer_update_or_timeout(channel:channel);
  }

  ##
  # callback function that checks for buffer inactivity
  #
  # @param session session handle for ssh session
  # @param channel channel for ssh session
  #
  # @return TRUE if inactive
  # @category SSH
  ##
  function basic_shell_handler_on_channel_buffer_inactivity(&session, &channel)
  {
    var sh = channel.shell_handler;
    if(!sh) return channel_closed_return_true(channel:channel);
    return sh.on_channel_buffer_inactivity(channel:channel);
  }

  ##
  # callback function to check for prompt or timeout
  #
  # @param session session handle for ssh session
  # @param channel channel for ssh session
  #
  # @return TRUE if found
  # @category SSH
  ##
  function basic_shell_handler_at_prompt3_or_timeout(&session, &channel)
  {
    var sh = channel.shell_handler;
    if(!sh) return channel_closed_return_true(channel:channel);
    return sh.at_prompt3_or_timeout(channel:channel);
  }

  ##
  # callback function to check for prompt or timeout
  #
  # @param session session handle for ssh session
  # @param channel channel for ssh session
  #
  # @return TRUE if found
  # @category SSH
  ##
  function basic_shell_handler_at_prompt2_or_timeout(&session, &channel)
  {
    var sh = channel.shell_handler;
    if(!sh) return channel_closed_return_true(channel:channel);
    return sh.at_prompt2_or_timeout(channel:channel);
  }
  ### END RECV_UNTIL CALLBACKS ###

  ### Basic shell handler utils ###

  ##
  # Logs error and returns TRUE
  #
  # @param channel channel for ssh session
  #
  # @return TRUE
  ##
  function channel_closed_return_true(&channel)
  {
    dbg::detailed_log(lvl:1, src:FUNCTION_NAME, msg:'basic_shell_handler [channel ' + channel.local_channel + ']: Channel is closed.');
    return TRUE;
  }

  ##
  # Logs error and returns NULL
  #
  # @param fn function name for logging
  # @param session session handle for ssh session
  # @anonparam channel for ssh session
  #
  # @return NULL
  ##
  function channel_closed_return_null(fn, &session, &channel)
  {
    var ch_label = '';
    if (channel) ch_label = '[channel ' + channel.local_channel + ']: ';
    var msg = ch_label + 'Channel is closed.';

    dbg::detailed_log(lvl:1, src:FUNCTION_NAME, msg:msg);

    return NULL;
  }

  ### End basic shell handler utils ###

  # basic raw shell handler, no escalation or special formatting
  object basic_shell_handler
  {
    var fresh_shell = TRUE;
    var last_buffer_update_ts;
    var cur_user;
    var cur_buf = "";
    var cur_buf_change_counter = 0;
    var initial_prompt_timeout_count = 0;

    var kb_id;
    var obj_ch_id;

    # this can be set in class before using sshrecv_until.  this will cause the callback check functions to
    # return after a given inactivity period (no channel data updates)
    var timeout_check;
    var timed_out = FALSE;

    var command_result_found;
    var found_cmd_prompt;

    # did we run into a problem running last command? if so set this, so we don't
    # try running more
    var last_cmd_error = FALSE;

    # buffer received after initial login before shell starts waiting for input, include prompt
    var post_login_buffer = NULL;
    var cmd_prompt = NULL;

    # number of seconds of inactivity before we assume shell is ready for input
    var initial_inactivity_period = _BASIC_INITIAL_INACTIVITY_TIMEOUT;
    # timeout for sshrecv for initial wait to reach command prompt post login
    var initial_recv_timeout = 2;
    # default buffer inactivity timeout check
    var inactivity_timeout = _BASIC_DEFAULT_INACTIVITY_TIMEOUT;
    # default timeout for individual recv
    var recv_timeout = 2;
    # default timeout for cmd_timeout (no default)
    var cmd_timeout = _BASIC_DEFAULT_CMD_TIMEOUT;

    var settings;
    var objname = 'basic_shell_handler::';

    # Extending objects can override these if the shell state is escalated
    var escl_user = NULL;
    var escl_method = NULL;

    # This tells channel.close() to call this.cleanup_before_close() before closing the channel if set to TRUE
    var cleanup_required_before_close;

    ##
    # Shell handler initialization caller
    # @category SSH
    ##
    function basic_shell_handler()
    {
      this.init();
    }


    ##
    # Shell handler init
    # @param settings
    # @category SSH
    ##
    public function init(settings)
    {
      if (!isnull(settings)) this.settings = settings;
      this.cmd_prompt = this.settings['cmd_prompt'];
      this.fresh_shell = TRUE;
      this.cur_buf = "";
      this.cur_buf_change_counter = 0;
      this.last_cmd_error = FALSE;
      this.command_result_found = FALSE;
    }

    ##
    # Returns carriage return tty opcode turned off
    # @no53   If true don't populate flag 53 with any value - flag 53 (PTY_OPT_ECHO)
    #         reputedly breaks Palo Alto's SSH implementation. (optional)
    # @return list of required pty opcodes
    # @category SSH
    ##
    public function get_pty_opts(no53)
    {
      if(isnull(no53))
        no53 = FALSE;

      return make_array(PTY_OPT_OCRNL, 0);
    }

    ##
    # get default size PTY chars
    # @return default size PTY chars
    # @category SSH
    ##
    public function get_pty_size_chars()
    {
      return DEFAULT_PTY_SIZE_CHARS;
    }

    ##
    # get default size PTY pixels
    # @return default size PTY pixels
    # @category SSH
    ##
    public function get_pty_size_pixels()
    {
      return DEFAULT_PTY_SIZE_PIXELS;
    }

    ##
    # get pty term
    # @return default pty term
    # @category SSH
    ##
    public function get_pty_term()
    {
      return DEFAULT_PTY_TERM;
    }

    ##
    # should we send / recv data to device without setting up a channel?
    # @return FALSE
    # @category SSH
    ##
    public function is_nosetup()
    {
      return FALSE;
    }

    ##
    # do we want to request a PTY on this device?
    # @return TRUE
    # @category SSH
    ##
    public function send_pty_req()
    {
      return TRUE;
    }

    ##
    # do we want to handle the "shell" channel request?
    #
    # @category SSH
    ##
    public function get_shell_channel_request_cb()
    {
      return NULL;
    }

    ##
    # set priv escalation
    #
    # @param type escalation type
    # @param extra
    #
    # @category SSH
    ##
    public function set_priv_escalation(type, extra)
    {
      return NULL;
    }

    ##
    # unset priv escalation
    # @category SSH
    ##
    public function unset_priv_escalation()
    {
      return NULL;
    }

    ###
    # Setter functions for variables defined in this object so that child
    # objects can update them for functions defined here
    ###

    ##
    # Set cmd_prompt
    # @category SSH
    ##
    public function set_cmd_prompt()
    {
      this.cmd_prompt = _FCT_ANON_ARGS[0];
      this.settings.cmd_prompt = this.cmd_prompt;
    }

    ##
    # Set timeout_check
    # @category SSH
    ##
    protected function set_timeout_check() { this.timeout_check = _FCT_ANON_ARGS[0]; }

    ##
    # Reset last buffer update time
    # @category SSH
    ##
    protected function reset_buffer_update_time()
    {
      this.last_buffer_update_ts = unixtime();
    }

    ##
    # Set fresh_shell
    # @category SSH
    ##
    protected function set_fresh_shell() { this.fresh_shell = _FCT_ANON_ARGS[0]; }

    ##
    # Set timed_out
    # @category SSH
    ##
    protected function set_timed_out() { this.timed_out = _FCT_ANON_ARGS[0]; }

    ##
    # Set last_cmd_error
    # @category SSH
    ##
    protected function set_last_cmd_error() { this.last_cmd_error = _FCT_ANON_ARGS[0]; }

    ##
    # Set kb_id
    # @category SSH
    ##
    protected function set_kb_id() { this.kb_id = _FCT_ANON_ARGS[0]; }

    ##
    # Set initial_inactivity_period
    # @category SSH
    ##
    protected function set_initial_inactivity_period() { this.initial_inactivity_period = _FCT_ANON_ARGS[0]; }

    ##
    # Set objname
    # @category SSH
    ##
    protected function set_objname() { this.objname = _FCT_ANON_ARGS[0]; }

    ##
    # Set obj_ch_id
    # @category SSH
    ##
    protected function set_obj_ch_id() { this.obj_ch_id = _FCT_ANON_ARGS[0]; }

    ##
    # Set escl_user
    # @category SSH
    ##
    protected function set_escl_user() { this.escl_user = _FCT_ANON_ARGS[0]; }

    ##
    # Set escl_method
    # @category SSH
    ##
    protected function set_escl_method() { this.escl_method = _FCT_ANON_ARGS[0]; }

    ##
    # Set recv_timeout
    # @category SSH
    ##
    protected function set_recv_timeout() {this.recv_timeout = _FCT_ANON_ARGS[0]; }

    ##
    # Set inactivity_timeout
    # @category SSH
    ##
    protected function set_inactivity_timeout() {this.inactivity_timeout = _FCT_ANON_ARGS[0]; }

    ##
    # Set recv_timeout
    # @category SSH
    ##
    protected function set_cmd_timeout() {this.cmd_timeout = _FCT_ANON_ARGS[0]; }

    ##
    # send command by line length
    #
    # @param cmd command to run
    # @param max_cmd_len max command length
    # @param channel channel
    #
    # @category SSH
    ##
    protected function send_command_by_line_length(cmd, max_cmd_len, &channel)
    {
      local_var subcmd_start, subcmd_end, subcmd;

      #Honor no limit for TAP testing
      if(TAP_MODE) max_cmd_len = 1 << 30;

      for ( subcmd_start = 0 ; subcmd_start < strlen(cmd) ; subcmd_start += max_cmd_len)
      {
        if ( strlen(cmd) <= subcmd_start + max_cmd_len - 1)
          subcmd_end = strlen(cmd) - 1;
        else
          subcmd_end = subcmd_start + max_cmd_len - 1;
        subcmd = substr(cmd, subcmd_start, subcmd_end);
        channel.window_send_data(data:subcmd);
      }

      return NULL;
    }

    ##
    # check inactivity timeout function
    #
    # @param channel channel for ssh session
    #
    # @return TRUE if timeout reached
    # @category SSH
    ##
    protected function check_inactivity_timeout(&channel)
    {
      var fn = objname + FUNCTION_NAME;
      this.timed_out = FALSE;
      if(channel.state == CHANNEL_STATE_CLOSED)
      {
        dbg::detailed_log(lvl:1, src:FUNCTION_NAME, msg:this.obj_ch_id + 'Channel is closed.');
        return TRUE;
      }
      if(channel.buf_change_counter != cur_buf_change_counter)
      {
        dbg::detailed_log(lvl:2, src:FUNCTION_NAME, msg:this.obj_ch_id + 'Channel data buffer updated, resetting shell inactivity timer.');
        cur_buf_change_counter = channel.buf_change_counter;
        this.last_buffer_update_ts = unixtime();
      }
      else
      {
        if ((unixtime() - this.last_buffer_update_ts) >= this.timeout_check)
        {
          dbg::detailed_log(lvl:1, src:FUNCTION_NAME, msg:this.obj_ch_id + 'Reached recv timeout limit [' + this.timeout_check + 's].');
          this.timed_out = TRUE;
          return TRUE;
        }
      }
    }

    ##
    # function to check for buffer update or inactivity timeout
    #
    # @param channel channel for ssh session
    #
    # @return TRUE if found
    # @category SSH
    ##
    public function on_channel_buffer_update_or_timeout(&channel)
    {
      if(channel.buf_change_counter != cur_buf_change_counter)
      {
        cur_buf_change_counter = channel.buf_change_counter;
        return TRUE;
      }
      return this.check_inactivity_timeout(channel:channel);
    }

    ##
    # check for prompt or inactivity timeout
    #
    # @param channel channel for ssh session
    #
    # @return TRUE
    # @category SSH
    ##
    public function at_prompt3_or_timeout(&channel)
    {
      if(this.at_cmd_prompt(buf:channel.data_buf, check_len:3)) return TRUE;
      return this.check_inactivity_timeout(channel:channel);
    }

    ##
    # check for prompt or inactivity timeout with 2 character prompt
    #
    # @param channel channel for ssh session
    #
    # @return TRUE
    # @category SSH
    ##
    public function at_prompt2_or_timeout(&channel)
    {
      if(this.at_cmd_prompt(buf:channel.data_buf, check_len:2)) return TRUE;
      return this.check_inactivity_timeout(channel:channel);
    }

    ##
    # check for buffer or inactivity timeout
    #
    # @param channel channel for ssh session
    #
    # @return TRUE if found
    # @category SSH
    ##
    public function on_channel_buffer_inactivity(&channel)
    {
      if(this.fresh_shell && !isnull(this.post_login_buffer))
      {
        if(this.post_login_buffer >< channel.data_buf) return TRUE;
      }
      return this.check_inactivity_timeout(channel:channel);
    }

    ##
    # determine if we are at command prompt
    #
    # @param channel channel
    #
    # @return TRUE if found
    # @category SSH
    ##
    public function at_cmd_prompt(buf, check_len)
    {
      this.found_cmd_prompt = FALSE;
      if (isnull(cmd_prompt)) return FALSE;
      if (strlen(cmd_prompt) < check_len) return FALSE;
      var sub_prompt = substr(cmd_prompt, strlen(cmd_prompt) - check_len, strlen(cmd_prompt) - 1);
      if(strlen(buf) < check_len) return FALSE;
      var sub_buf = substr(buf, strlen(buf) - check_len, strlen(buf) - 1);

      if(sub_prompt == sub_buf)
      {
        this.found_cmd_prompt = TRUE;
        return TRUE;
      }
    }

    ##
    # Set the shell timeouts
    #
    # @param cmd_timeout_min The total number of seconds that may elapse
    #                      waiting for the command response. (optional)
    # @param inactivity_timeout_min The number of seconds that may
    #                             elapse with no data received from
    #                             the target. (optional)
    #
    # @return NULL
    # @category SSH
    ##
    protected function set_timeouts(inactivity_timeout_min, cmd_timeout_min)
    {
      # Reset default timeouts
      this.inactivity_timeout = _BASIC_DEFAULT_INACTIVITY_TIMEOUT;
      this.cmd_timeout = _BASIC_DEFAULT_CMD_TIMEOUT;

      # If custom inactivity_timeout and cmd_timeout values are passed,
      # ensure the values in use meet or exceed passed values
      if (inactivity_timeout_min &&
          this.inactivity_timeout < inactivity_timeout_min)
        this.inactivity_timeout = inactivity_timeout_min;

      if (cmd_timeout_min &&
          this.cmd_timeout < cmd_timeout_min)
        this.cmd_timeout = cmd_timeout_min;

      return NULL;
    }

    ##
    # Handle a fresh shell, getting the post-login buffer and command
    # prompt and setting in KB if needed
    #
    # @param [session:session object] Session object
    # @param [channel:channel object] Channel object with fresh shell
    # @return TRUE if successful, else FALSE
    # @category SSH
    ##
    public function handle_fresh_shell(&session, &channel)
    {
      var fn = objname + FUNCTION_NAME;

      # run_command() should have already validated this, but just in case
      if (!session) session = channel.session;
      if (!session)
      {
        dbg::detailed_log(lvl:1, src:fn, msg:'No session passed and channel.session is missing. A valid session is required.');
        return NULL;
      }

      # Make sure this.kb_id has been initialized
      if (!this.kb_id)
        this.kb_id = SSH_LIB_KB_PREFIX + session.get_kb_connection_id();

      dbg::detailed_log(lvl:2, src:FUNCTION_NAME, msg:this.obj_ch_id + 'Getting prompt on fresh shell.');

      # Check to see if command prompt has been cached from previous
      # login and is usable for initial command prompt detection
      # rather than waiting for timeout
      var _post_login_buffer = get_kb_blob(this.kb_id + '/post_login_buffer');
      this.set_cmd_prompt(get_kb_blob(this.kb_id + '/cmd_prompt'));

      this.timeout_check = this.initial_inactivity_period;
      this.last_buffer_update_ts = unixtime();

      var check_prompt = FALSE;
      if(strlen(this.cmd_prompt) >= 3)
      {
        # Remove first found instance of prompt from previous post
        # login buffer
        var sub_prompt = substr(this.cmd_prompt, strlen(this.cmd_prompt) - 3, strlen(this.cmd_prompt) - 1);
        _post_login_buffer -= sub_prompt;

        # If we don't find it again (e.g. in MOTD), it's probably ok
        # to look for last characters of prompt to recognize prompt
        if(sub_prompt >!< _post_login_buffer)
          check_prompt = TRUE;
      }

      if (check_prompt)
      {
        dbg::detailed_log(lvl:2, src:FUNCTION_NAME, msg:this.obj_ch_id + 'Using command prompt from previous login to find cmd prompt.');
        channel.set_shell_handler(this);
        session.sshrecv_until(
          end_states     : make_list("SOC_CLOSED"),
          check_callback : @basic_shell_handler_at_prompt3_or_timeout,
          channel        : channel,
          timeout        : this.initial_recv_timeout
        );
      }
      else
      {
        dbg::detailed_log(lvl:2, src:FUNCTION_NAME, msg:this.obj_ch_id + 'Waiting for inactivity period to find command prompt.');
        channel.set_shell_handler(this);
        session.sshrecv_until(
          end_states     : make_list('SOC_CLOSED'),
          check_callback : @basic_shell_handler_on_channel_buffer_inactivity,
          channel        : channel,
          timeout        : this.initial_recv_timeout);
      }

      # Check received data and return appropriate error message
      if (empty_or_null(channel.data_buf))
      {
        if (this.timed_out)
        {
          session.set_cmd_error(this.obj_ch_id +
            'Timed out waiting for data from server after opening shell.');
          return FALSE;
        }

        session.set_cmd_error(this.obj_ch_id +
          'No data received from server after opening shell.');
        this.set_last_cmd_error(TRUE);
        return FALSE;
      }

      if('password has expired' >< channel.data_buf)
      {
        session.set_error(this.obj_ch_id + 'Account password has expired.');
        this.set_last_cmd_error(TRUE);
        return FALSE;
      }

      if(channel.state == CHANNEL_STATE_CLOSED)
      {
        dbg::detailed_log(lvl:1, src:FUNCTION_NAME, msg:this.obj_ch_id + 'Channel is closed.');
        this.set_last_cmd_error(TRUE);
        return FALSE;
      }

      # Set post-login buffer
      this.post_login_buffer = channel.data_buf;

      if (isnull(get_kb_item(this.kb_id + '/post_login_buffer')))
        set_kb_blob(name:this.kb_id + '/post_login_buffer', value:this.post_login_buffer);

      channel.clear_data_buf();
      this.set_fresh_shell(FALSE);

      # Parse and set command prompt
      var lines = split(this.post_login_buffer, sep:'\n', keep:FALSE);
      this.set_cmd_prompt(lines[max_index(lines)-1]);

      if (isnull(get_kb_item(this.kb_id + "/cmd_prompt")))
        set_kb_blob(name:this.kb_id + "/cmd_prompt", value:this.cmd_prompt);

      dbg::detailed_log(lvl:2, src:FUNCTION_NAME, msg:this.obj_ch_id + 'Detected command prompt',
        msg_details:{"Data":{"lvl":3, "value":this.cmd_prompt}});

      if(strlen(this.cmd_prompt) == 0)
      {
        session.set_cmd_error(this.obj_ch_id +
          'Unable to detect command prompt on shell.');
        this.set_last_cmd_error(TRUE);
        return FALSE;
      }

      this.set_timed_out(FALSE);
      return TRUE;
    }

    ##
    # run given command
    #
    # @param channel channel for ssh session
    # @param command cmd to run
    # @param force_priv_escl force priv escalation flag
    # @param cmd_timeout_min The total number of seconds that may elapse
    #                      waiting for the command response. (optional)
    # @param inactivity_timeout_min The number of seconds that may
    #                             elapse with no data received from
    #                             the target. (optional)
    #
    # @return command result or NULL on failure
    # @category SSH
    ##
    public function run_command(&channel, command, force_priv_escl,
        cmd_timeout_min, inactivity_timeout_min)
    {
      var fn = objname + FUNCTION_NAME;
      this.set_obj_ch_id('[channel ' + channel.local_channel + ']: ');

      # Check channel state
      if (!channel.session || channel.state == CHANNEL_STATE_CLOSED)
      {
        this.last_cmd_error = TRUE;
        return channel_closed_return_null(fn:fn, session:session, channel:channel);
      }
      var session = channel.session;

      # Check shell state
      if (this.last_cmd_error)
      {
        return session.set_error(this.obj_ch_id +
          'ERROR - shell is in unknown state from last interaction, ' +
          'no additional commands via this shell will be executed.');
      }

      # Initialize variables
      this.set_kb_id(SSH_LIB_KB_PREFIX + session.get_kb_connection_id());
      set_timeouts(inactivity_timeout_min:inactivity_timeout_min,
          cmd_timeout_min:cmd_timeout_min);

      var cmd_logger = new("sshlib::cmd_logger");
      this.command_result_found = FALSE;

      cur_user = session.user;

      var item, msg, cb;

      # Clear any errors from previous commands
      session.clear_cmd_error();

      # Get command prompt
      if(this.fresh_shell && !this.handle_fresh_shell(session:session, channel:channel))
        return NULL;

      if(channel.state == CHANNEL_STATE_CLOSED)
      {
        this.last_cmd_error = TRUE;
        return channel_closed_return_null(fn:fn, session:session, channel:channel);
      }

      # Run command and receive response, sending password as prompted
      session.reset_cmd_interrupted();

      dbg::detailed_log(lvl:2, src:FUNCTION_NAME, msg:obj_ch_id + "Sending command: " + command);

      # Use a 256 character line length limit for HP-UX and SunOS
      this.send_command_by_line_length(cmd:command + '\n', max_cmd_len:256, channel:channel);

      this.last_buffer_update_ts = unixtime();
      this.timeout_check = inactivity_timeout;
      channel.set_shell_handler(this);
      session.sshrecv_until(
        end_states     : make_list("SOC_CLOSED"),
        check_callback : @basic_shell_handler_at_prompt2_or_timeout,
        channel        : channel,
        timeout        : this.recv_timeout,
        cmd_timeout    : this.cmd_timeout
      );

      if(channel.state == CHANNEL_STATE_CLOSED)
      {
        this.last_cmd_error = TRUE;
        return channel_closed_return_null(fn:fn, session:session, channel:channel);
      }

      if(empty_or_null(channel.data_buf))
      {
        if(!this.timed_out)
        {
          msg = obj_ch_id + "No data received in response to command.";
          last_cmd_error = TRUE;
        }
        else
          msg = obj_ch_id + "Timed out waiting for command result. No data received.";

        channel.session.set_cmd_error(msg);
        return cmd_logger.log_error(
          cmd                : command,
          error              : session.cmd_error,
          user               : session.user,
          # These are NULL unless overridden by extending object
          escl_user          : this.escl_user,
          escl_method        : this.escl_method
        );
      }

      var check_len = 3;
      if(strlen(cmd_prompt) < 3) check_len = strlen(cmd_prompt);

      # Unless we've previously identified that we can't reach the
      # command prompt after executing a command,
      # recv up to two more times until we get to cmd prompt if we
      # aren't already
      var prompt_timeout_kb = SSH_LIB_KB_PREFIX + "cmd_prompt_timeouts";
      var prompt_timeout_count = get_kb_item(prompt_timeout_kb);
      if(!isnull(prompt_timeout_count) && prompt_timeout_count - initial_prompt_timeout_count >= 3)
      {
        session.set_cmd_error(obj_ch_id +
          'Returning to command prompt previously failed. Not looking' +
          ' for command prompt.');
        last_cmd_error = TRUE;
      }
      else
      {
        cur_buf_change_counter = channel.buf_change_counter;
        this.last_buffer_update_ts = unixtime();

        var i = 0;
        while(!at_cmd_prompt(buf:channel.data_buf, check_len:check_len))
        {
          if(i > 2) break;
          session.sshrecv_until(
            end_states     : make_list("SOC_CLOSED"),
            check_callback : @basic_shell_handler_on_channel_buffer_update_or_timeout,
            channel        : channel,
            timeout        : this.recv_timeout
          );
          i++;
        }

        if(at_cmd_prompt(buf:channel.data_buf, check_len:check_len))
        {
          dbg::detailed_log(lvl:2, src:FUNCTION_NAME, msg:obj_ch_id + 'Back at command prompt.');
        }

        if(!at_cmd_prompt(buf:channel.data_buf, check_len:check_len))
        {
          last_cmd_error = TRUE;
          if (!isnull(prompt_timeout_count))
            replace_kb_item(name:prompt_timeout_kb, value:prompt_timeout_count+1);
          else set_kb_item(name:prompt_timeout_kb, value:1);
          session.set_cmd_error(obj_ch_id +
            "ERROR - unable to get back to command prompt.");
        }
      }

      var cmd_res = channel.data_buf;
      channel.clear_data_buf();

      if(!empty_or_null(cmd_res))
      {
        cmd_res = str_replace(find:'\x00', replace:'', string:cmd_res);
        cmd_res = remove_escape_sequences(cmd_res);

        cmd_res = ereg_replace(pattern:"(^|\n)\s*" + command + "\s*($|\r|\n)", replace:"\1\2", string:cmd_res);

        if (cmd_prompt)
          cmd_res = str_replace(find:cmd_prompt, replace:'', string:cmd_res);
        cmd_res = strip(cmd_res);
      }

      dbg::detailed_log(lvl:2, src:FUNCTION_NAME, msg:obj_ch_id + "Extracted cmd result: " + cmd_res);

      cmd_logger.add(
        cmd         : command,
        response    : cmd_res,
        error       : session.cmd_error,
        user        : session.user,
        # These are NULL unless overridden by extending object
        escl_user   : this.escl_user,
        escl_method : this.escl_method
      );

      if(!empty_or_null(cmd_res)) return cmd_res;
      else return NULL;
    }

    ##
    # test private function
    #
    # @param name name of function to return
    # @param args args to pass to the function
    #
    # @return NULL on error / result of named function
    # @category SSH
    ##
    public function test_private_function(name, args)
    {
      var fn = 'sh_shell_handler.test_private_function';
      if (isnull(name))
      {
        dbg::detailed_log(lvl:1, src:FUNCTION_NAME, msg:'Missing name parameter');
        return NULL;
      }
      switch (name)
      {
        case "send_command_by_line_length":
          var old_mode = TAP_MODE;
          TAP_MODE = FALSE;
          var channel = args["channel"];
          var result = send_command_by_line_length(cmd:args["cmd"],
                                                   max_cmd_len:args["max_cmd_len"],
                                                   channel:channel);
          TAP_MODE = old_mode;
          return result;
        case "set_last_cmd_error":
          set_last_cmd_error(args);
          return NULL;
        default:
          dbg::detailed_log(lvl:1, src:FUNCTION_NAME, msg:'"'+name+'()" is not yet implemented for testing with this function');
          return NULL;
      }

      return NULL;
    }

    ##
    # Perform any required actions (if applicable) to clean up the shell before the channel is closed
    #
    # @param channel channel for ssh session
    # @return NULL
    # @category SSH
    ##
    public function cleanup_before_close(channel)
    {
      var fn = 'basic_shell_handler.cleanup_before_close';
      var ch_id = '[channel ' + channel.local_channel + ']: ';

      # First check to make sure channel is still open
      if (channel.state == CHANNEL_STATE_CLOSED)
      {
        dbg::detailed_log(lvl:1, src:fn, msg:ch_id +
          'Channel is already closed, unable to perform cleanup');
        return NULL;
      }

      # Send 'exit' to the shell before the channel is closed
      # This may help alleviate "zombie" shell processes due to environmental issues
      dbg::detailed_log(lvl:2, src:fn, msg:ch_id + 'Sending "exit"');
      channel.window_send_data(data:'exit\n');

      return NULL;
    }

  }
}
