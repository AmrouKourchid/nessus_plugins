#TRUSTED 7098dcec1189b68210fcb619ef3d6277c8edb626b6a2a26d2a57a2ee8b8b661e30fefa71e017467ab23a0b8c6789b1272f14307db4a37f6a87735cabe67495e4fe59c2a827d775c7c7d0195b14a746fca0829087013d15e6ce8b745fb2a20a956769492d8ad3ac1e79e49b4dbc8e7745e2b93dcc13510a9832c9bce4a734957cbc2a7e2b7dcd09065ae0506af8c65a9e6654d205e5b1761626154a43791f71ae423a0aa04882f0e1771dafbb231a857e6b3843d5369fbe40103414894e315a3a7feea56654803b0a0b528335587906a543a33b83996576bcd18a555211d972d86ff4e645e0cf1c5a1a46f761f7d46e06dffc32313c8457ac348c8fba5e802238ef8b1338e06a81b3c2f53b39c6acd83b948c97d764e2872d48b6e7cee6a78030d72a990f8abaf0cae1657530be7139f166212f8ffd54802ef115b18f45f87b3a57dbe41c8dc29e7a0b4fd35855ba2b5a4add05ac01037b635eec27ebe994f618ab4b9df7b9c3aa2d1daf7e5f99b96dfeae85ecd4287f8e34c13c331a2a87f4f020bd28e7b5d96eee20c70b5c6a3385044706e5f6ebbd7b6aee5b2e0da6b6cf00a4d68b5bb46ee6b73aeb3471eee742674fd216f86cd5e98c7b9724711a945501370471ab2edc26842b6db1746addfd7fc4592372f3deabc4443591bf3fd09814aebd3d815dd02f6c042aaabf4493597c81948963aa26841a0dd8dc9ea0c19808
#TRUST-RSA-SHA256 66fbd131a8e91daddd1f03ccdec71ee26b444c629b304ef32b2171431c96ed9c7a9e8d5ec9bd65c4b10a0b61317e7bdfed0d76ddebaa2aa9325b3c87c21a15b810e69008e36f6bc39b593b481132935d24b4fc7cb60b2ed3aff20799fbb19bfccc18b60d9775b2a7c38a98861ea9c2ff58a4b11da34fb87c11ea2c50bf71543204d8508ca9d1e12d59719eb92d266d14cf81801ec2d8de6183734c967e6a551b7d8dd3860678cf114a83945b7e22b6f27eed91e2850a85bb0182f87f9c1070644c733a4e63d381179cfed80a61a8d99850ebc8770bc1605852317d14c118fe2d381a41a220172a3c2ada05f8621546d194dbc26b4a0c1a7fa16dedfb1934d3d0519c7274b64828c009b54fcbc25b8787055eeda3e40e6bca8a61af43bed299871e5643755825d6d9801e5a87b9d2b5098bf39c9cc85622fb92946ac58809d527da15d697b5709f03e36043354870da40e063beb269a1cf3f6833dfb16b0c2d951b56b004348d05b5fb9d0d0e8efbd89c1f1a99bbbe67aee08c55035516a2b642deb454ba0e0a1fa60abaf0141d2f866077dcc20780ba8857399095ca3b578f30fd63ad6bf65a9c3f08a905c196155feb4dd8ba5535d07b1022c6fa777d69cd4e97802424705d4514871b75682ea3ab133b7417d48c1f54b92887127c863cd6a0e23b1240b999f819cb84ac87729a87505033ef9756a1d1d6815b874d4de76468
###
# Objects and functions making up the core of the SSH library.
#
# @license
# (C) Tenable Network Security, Inc.
#
# This script is released under one of the Tenable Script Licenses and may not
# be used from within scripts released under another license without the
# authorization from Tenable Network Security Inc.
#
# @NOGPL@
#
# Revision: 1.82
#
# @library ssh_lib.inc
# @category SSH
###

global_var tap_mode_close_socket, tap_mode_send, tap_mode_get_socket, tap_mode_recv, tap_mode_get_socket_error;

##
#
#  Namespace sshlib
#    Provides an encapsulated naming scope for sshlib functions and objects
#
##
namespace sshlib
{

  global_var USE_LEGACY, CRED_SETS;
  global_var _SCRATCH_PAD_MIRROR = make_list();
  global_var _SESSION_NUMBER_COUNTER = 0;
  global_var IS_SONICWALL = FALSE;
  global_var IS_JUNOS = FALSE;
  global_var IS_AOS = FALSE;
  USE_LEGACY = "use legacy";
  CRED_SETS  = "cred sets";
  global_var default_local_version = "TenableRocks";

  ##
  #
  # Object sshpacket
  #   Data and functions for processing SSH packets
  #
  ##

  object sshpacket
  {
    var raw;        # Raw unencrypted packet data

    var length;     # Length of entire packet
    var pad_length; # Length of random padding
    var payload;    # Payload minus the packet type byte
    var padding;    # Random padding
    var mac;        # MAC string (if applicable)

    var type;       # ord(packet type byte)

    var error;      # errors

    ##
    # Constructs an sshpacket object instance
    #
    # @anonparam [raw:data] Binary string of raw unencrypted packet bytes
    # @anonparam [infl_strm:data] zlib inflate stream for packet decompression
    ##
    function sshpacket()
    {
      raw = _FCT_ANON_ARGS[0];
      var infl_strm = _FCT_ANON_ARGS[1];

      if(!isnull(raw))
        parse(infl_strm:infl_strm);

      return NULL;
    }

    ##
    # Sets the packet payload.
    #
    # @anonparam [payload:data] Binary string representation of the payload.
    ##
    public function set_payload()
    {
      payload = _FCT_ANON_ARGS[0];

      return NULL;
    }

    ##
    # Records an error. Appends new error to current error state
    # and sets ``last_error`` to the new error.
    #
    # @anonparam [error:string] A string description of the error that occurred.
    #
    # @remark
    # This function does not log the error in the debug logs.
    ##
    function set_error()
    {
      if(isnull(error) || error == "")
        error = _FCT_ANON_ARGS[0];
      else
        error += '\n' + _FCT_ANON_ARGS[0];

      # get_ssh_error() in ssh_func.inc expects only the last error
      last_error = _FCT_ANON_ARGS[0];

      return NULL;
    }

    ##
    # Validates a raw unencrypted packet and decompresses it if it was compressed.
    #
    # @param [infl_strm:data] A zlib inflate stream for packet decompression.
    #
    # @return [NULL] This returns NULL on success but on an error it will
    #                return the return value of `sshlib::sshpacket.set_error()`_.
    ##
    function parse(infl_strm)
    {
      var payload_length;
      var pos = 0;

      # Length fields add up to 5 bytes
      if(strlen(raw) < 5)
        return set_error("Premature end of packet when reading length fields.");

      # Packet length is first 4 bytes
      length = getdword(blob:raw, pos:pos, order:BYTE_ORDER_BIG_ENDIAN);
      pos += 4;

      # If the remaining packet size after the packet length field is less than the
      # packet length, then the packet is malformed
      if(strlen(raw) - pos < length)
        return set_error("Premature end of packet when reading payload.");

      # Padding length is next 1 byte
      pad_length = getbyte(blob:raw,pos:pos);
      pos += 1;

      # If the remaining packet size after the padding length field is less than the
      # padding length, then the packet is malformed
      if(strlen(raw) - pos < pad_length)
        return set_error("Premature end of packet when reading padding.");

      # Payload length is the packet length minus the padding length minus the 1 byte
      # padding length field
      payload_length = length - pad_length - 1;

      # Payload
      payload = substr(raw, pos, (pos+payload_length)-1);
      pos += payload_length;

      # If the remaining packet size after the payload is less than the padding length,
      # then the packet is malformed
      if(strlen(raw) - pos < pad_length)
        return set_error("Premature end of packet when reading padding.");

      # Padding
      padding = substr(raw, pos, (pos+pad_length)-1);
      pos += pad_length;

      # There should be no data remaining after the padding, since we have not yet
      # received the MAC
      if(strlen(raw) - pos > 0)
        return set_error("Unexpected data after end of packet.");

      # Decompress payload
      if(!isnull(infl_strm))
      {
        payload = gzip_inflate(data:payload, flush:Z_PARTIAL_FLUSH, stream:infl_strm);
        if(empty_or_null(payload))
          return set_error("Could not decompress packet.");
      }

      # Strip type byte out of payload
      type = ord(payload[0]);
      payload = substr(payload, 1, strlen(payload));

      return NULL;
    }
  }

  ##
  #
  # Object session
  #   Data and functions for handling a SSH session.
  #
  ##

  object session
  {

    var number;
    var recv_timeout = 30;
    var legacy_data = make_array();

    var kex_handler;

    var channel_manager;

    var remote_host = '';

    var ignore_known_hosts = FALSE;

    var redact = FALSE; # set to redact displaying sensitive packets in debug log
    var user = "";
    var password = "";
    var login_method = "";
    var kerb_host, realm;

    var supported_auth_methods = make_list();

    var authenticated = FALSE;

    var compression_alg_s_to_c, compression_alg_c_to_s;

    var cur_state = new("sshlib::ssh_client_state");
    var packet_handler_callbacks = NULL;
    var compression_enabled_c_to_s = FALSE;
    var compression_enabled_s_to_c = FALSE;

    var interactive_login_cb = NULL;

    var socket = NULL;
    var port = 22;
    var remote_version = FALSE;
    var remote_host_key = NULL;
    var local_version = NULL;
    var encrypted = FALSE;
    var error = NULL;
    var cmd_error = NULL;
    var cmd_interrupted = FALSE;
    var seqn_w = 0; # Sent sequence number
    var seqn_r = 0; # Receive sequence number

    var infl_strm, defl_strm;

    var userauth_banner;
    var sftp_session = NULL;

    ##
    # Optional label used for sending non-"ssh-rsa" labels in connection with RSA public/private keys, with default
    ##
    var rsa_connection_label = "ssh-rsa";

    var bugged_sshd_ver = FALSE;

    var post_login_error = FALSE;

    var objname = 'session.';

    ##
    # Sets the compression algorithm to be used for the SSH session.
    # Each direction of communication can have its own compression algorithm or none.
    #
    # @param [mode:integer] An integer signifying the direction of communication to set a
    #        compression algorithm for. Either ``sshlib::MODE_IN`` or ``sshlib::MODE_OUT``.
    # @param [alg:string] A string denoting the compression algorithm to set. Currently:
    #        "none", "zlib" and "zlib.openssh.com" are supported.
    ##
    public function set_compression_alg(mode, alg)
    {
      var fn = 'session.set_compression_alg';
      if(mode == MODE_IN)
      {
        dbg_log(src:fn, msg:'Setting compression for MODE_IN to ' + alg);
        compression_alg_s_to_c = alg;
      }
      else if(mode == MODE_OUT)
      {
        dbg_log(src:fn, msg:'Setting compression for MODE_OUT to ' + alg);
        compression_alg_c_to_s = alg;
      }

      return NULL;
    }

    ##
    # Sets a timeout value for receiving data.
    #
    # @anonparam [recv_timeout:integer] An integer timeout in seconds.
    ##
    public function set_recv_timeout()
    {
      this.recv_timeout = int(_FCT_ANON_ARGS[0]);

      return NULL;
    }

    ##
    # Enables compression in the indicated direction.
    #
    # @param [mode:integer] An integer signifying the direction of communication to enable
    #        compression for. Either ``sshlib::MODE_IN`` or ``sshlib::MODE_OUT``.
    ##
    public function enable_compression(mode)
    {
      var fn = 'session.enable_compression';
      dbg_log(src:fn, msg:'Compression enabled at level 6 [MODE ' + mode + '].');
      if(mode == MODE_OUT)
      {
        compression_enabled_c_to_s = TRUE;
        defl_strm = gzip_deflate_init(windowBits:15, level:6);
      }
      else if(mode == MODE_IN)
      {
        compression_enabled_s_to_c = TRUE;
        infl_strm = gzip_inflate_init(windowBits:15);
      }

      return NULL;
    }

    ##
    # Disables compression in the indicated direction.
    # This function also closes any gzip stream that might be open in the
    # indicated direction.
    #
    # @param [mode:integer] An integer signifying the direction of communication to disable
    #        compression for. Either ``sshlib::MODE_IN`` or ``sshlib::MODE_OUT``.
    ##
    public function disable_compression(mode)
    {
      var fn = 'session.disable_compression';
      dbg_log(src:fn, msg:'Compression disabled. [ MODE ' + mode + '].');

      if(mode == MODE_OUT)
      {
        compression_enabled_c_to_s = FALSE;
        gzip_deflate_end(defl_strm);
        defl_strm = NULL;
      }
      else if(mode == MODE_IN)
      {
        compression_enabled_s_to_c = FALSE;
        gzip_inflate_end(infl_strm);
        infl_strm = NULL;
      }

      return NULL;
    }


    ##
    # Stores which credentials sets have already been tried so that if
    # the library fails over to legacy code they won't have to be tried
    # again.
    #
    # @anonparam [sets:array] An array of boolean values with TRUE indicating the
    #                         index of a credential set that has already been tried.
    ##
    public function set_legacy_cred_sets()
    {
      var sets = _FCT_ANON_ARGS[0];
      if(isnull(sets))
        return NULL;

      legacy_data[CRED_SETS] = sets;

      return NULL;
    }


    ##
    # Sets a flag that determines whether log messages should be redacted or not.
    # This is to prevent the logging of sensitive data such as passwords.
    #
    # @anonparam [redact:boolean] A boolean value. TRUE means comments will be redacted.
    ##
    public function set_redact()
    {
      redact = _FCT_ANON_ARGS[0];

      return NULL;
    }

    var pkt_data;
    var pkt_raw;
    var last_packet;

    var cipherset = NULL;
    var new_cipherset = NULL;

    var nosetup_shell_handler = NULL;

    ##
    # Turns on SSH host verification.
    ##
    public function check_known_hosts()
    {
      ignore_known_hosts = FALSE;

      return NULL;
    }

    ##
    # Turns off SSH host verification.
    ##
    public function ignore_known_hosts()
    {
      ignore_known_hosts = TRUE;

      return NULL;
    }

    ##
    # Sets the SSH port.
    #
    # @anonparam [port:interger] Integer value of the current SSH port.
    ##
    public function set_port()
    {
      port = _FCT_ANON_ARGS[0];

      return NULL;
    }

    ##
    # Gets the SSH port.
    #
    # @return [integer] Integer port value.
    ##
    public function get_port()
    {
      return this.port;
    }

    ##
    # Supplies a TCP socket to use for communication.
    #
    # @anonparam [socket:integer] A TCP socket handle.
    ##
    public function set_socket()
    {
      socket = _FCT_ANON_ARGS[0];

      return NULL;
    }

    ##
    # Stores the contents of the ``SSH_MSG_USERAUTH_BANNER message``. This banner
    # is sometimes used in host fingerprinting.
    #
    # @anonparam [userauth_banner:string] The text contents of the ``SSH_MSG_USERAUTH_BANNER`` message.
    ##
    public function set_userauth_banner()
    {
      userauth_banner = _FCT_ANON_ARGS[0];

      return NULL;
    }

    ##
    # Stores the remote server's SSH protocol version.
    #
    # @anonparam [remote_version:string] A string representation of the SSH protocol version.
    ##
    public function set_remote_version()
    {
      remote_version = _FCT_ANON_ARGS[0];

      return NULL;
    }

    ##
    # Stores the local client's SSH protocol version.
    #
    # @anonparam [local_version:string] A string representation of the SSH protocol version.
    ##
    public function set_local_version()
    {
      local_version = _FCT_ANON_ARGS[0];

      return NULL;
    }

    ##
    # Stores a set of ciphers to be used in key negotiation.
    #
    # @anonparam [new_cipherset:object] A ``sshlib::cipherset`` object instance.
    ##
    public function set_new_cipherset()
    {
      new_cipherset = _FCT_ANON_ARGS[0];

      return NULL;
    }

    ##
    # Stores a remote host key to be used with host verification.
    #
    # @anonparam [remote_host_key:string] A public host key identifying the remote host.
    ##
    public function set_remote_host_key()
    {
      var fn = 'session.set_remote_host_key';
      remote_host_key = _FCT_ANON_ARGS[0];
      dbg_log(
        lvl:3,
        src:fn,
        msg:'Remote host key in base64',
        msg_details:{
          "Data":{"lvl":3, "value":base64(str:remote_host_key)}});

      return NULL;
    }

    ##
    # Adds a message to the debug log with session information and redaction
    # of sensitive data when necessary.
    #
    # @remark
    # This function should only ever be used to do logging inside of the ``session`` object.
    #
    # @remark
    # This function uses `dbg::detailed_log()`_ and `dbg::log_packets()`
    # and as such, it accounts for the given debug level.
    #
    # @param [src:string] String that provides a function scope for the log message.
    # @param [lvl:int] The debug level of the logged message.
    # @param [msg:string] A description of the event being logged (can be passed anonymously).
    # @param [msg_details:array] Details to be passed to `dbg:detailed_log()`_. See that function for more information.
    #
    # @param [ddata:data] A binary string representing data to be added to ``msg_details`` and it is subject to redaction.
    #
    # @param [packets:list] A list of packets information to log. The list should be constructed with `sshlib::session.dbg_add_packet()`_.
    # @param [reverse:boolean] A boolean to reverse the packets order of importance, to be passed to `dbg::log_packets()`_.
    # @param [max_level:boolean] A boolean to set packets to be logged only at the debug level where there is no character limit.
    #
    # @param [base64:data] A binary string to be encoded in base64 and appended to the log message.
    # @param [sftp:string] name of the sftp specific log
    # @param [sftp_channel:int] number indicating channel number used by sftp
    #
    # @return [string|NULL] Returns the entire log message as formed or NULL if the current log
    #                       level is insufficient for the message.
    #
    # @remark
    # Only data passed in ``packets`` and ``ddata`` are subject to redaction.
    # So in the event that raw data should not be redacted, it should passed in ``msg_details``.
    ##
    public function dbg_log(src, lvl, msg, msg_details, ddata, packets, reverse, max_level, base64, sftp, sftp_channel)
    {
      # Set default values if they are missing
      if (isnull(lvl))
        lvl = 3;
      if (isnull(msg))
        msg = _FCT_ANON_ARGS[0];
      if (isnull(src))
        src = '';
      if (empty_or_null(msg_details))
        msg_details = {};

      # Prepend session information to the debug log source
      if(sftp && !isnull(sftp_channel))
        src = '[session ' + this.get_number() + ':' + sftp_channel + '] '+ src;
      else
        src = '[session ' + this.get_number() + '] '+ src;

      if (!isnull(base64))
        msg += base64(str:base64);

      # Redact data if necessary, and add it to the msg_details if we can
      if (!isnull(ddata))
      {
        if (this.redact)
          msg += '\n[REDACTED]';
        else if (empty_or_null(msg_details) || isnull(msg_details['Data']))
          msg_details['Data'] = {"lvl":3, "value":ddata};
        else
          dbg::detailed_log(src:FUNCTION_NAME, lvl:1, msg:'msg_details already contains a "Data" entry.');
      }

      if (!isnull(sftp))
        sftp = [sftp];

      dbg::detailed_log(src:src, lvl:lvl, msg:msg, msg_details:msg_details, extra_name_list:sftp);

      # Log packets after the regular message
      if (!isnull(packets))
        dbg::log_packets(src:src, packets:packets, reverse:reverse, max_level:max_level, extra_name_list:sftp);

      return src + msg;
    }

    ##
    # Formats and appends a packet debug message and data to the list of packets to log.
    #
    # @param [list:list] The list of packets to log to which the given data and message need to be appended.
    # @param [msg:string] The log message to print before the packet data.
    # @param [data:data] The packet data to log.
    #
    # @param [packet_code:integer|string] The packet code for the type of packet to log.
    #        Either an integer as defined in the array ``ssh2_packet_type_labels``,
    #        or a string representing the name of the packet type.
    #
    # @return [list|NULL] The return value of `dbg::add_packet_log()`_, i.e. the packet list to use with
    # `sshlib::session.dbg_log()`_ or NULL if the packet array was appended to ``list`` or if an error occurred.
    #
    # @remark
    # The list given is taken as a reference to which the data and message are appended.
    # That list is then meant to be given to `sshlib::session.dbg_log()`_.
    #
    # @remark
    # The data given is subject to redaction if the session has its redaction flag set.
    ##
    public function dbg_add_packet(&list, msg, data, packet_code)
    {
      if (this.redact)
        data = 'REDACTED';
      if (!isnull(packet_code))
      {
        if (typeof(packet_code) == 'int')
          packet_code = ssh2_packet_type_labels[packet_code];
        msg += ' ['+ packet_code + ']';
      }
      return dbg::add_packet_log(list:list, msg:msg, data:data);
    }

    ##
    # Records an error. Appends new error to session's current error state
    # and sets last_error to the new error. The new error is logged at
    # debug level 1.
    #
    # @param [src:string] The function name where the error occurred.
    # @param [err_msg:string] A string description of the error that occurred.
    #
    # @return [NULL] This function always returns NULL.
    ##
    public function set_error(src, err_msg)
    {
      if (isnull(err_msg))
        err_msg = _FCT_ANON_ARGS[0];
      if (isnull(src))
        src = FUNCTION_NAME;

      # get_ssh_error() in ssh_func.inc expects only the last error
      last_error = err_msg;

      error += err_msg + '\n';

      dbg_log(lvl:1, src:src, msg:err_msg);

      return NULL;
    }

    ##
    # Records authentication errors for reporting.
    #
    # @param [user:string] User id.
    # @param [port:integer] Integer SSH port number.
    # @param [msg:string] Authentication error description.
    #
    # @return [NULL] This function always returns NULL.
    ##
    public function set_auth_failure_error(user, port, msg)
    {
      this.set_error(src:FUNCTION_NAME, err_msg:msg);

      if(checking_default_account_dont_report)
        return NULL;

      if(isnull(port))
        port = sshlib::kb_ssh_transport();
      var prefix = "Host/Auth/SSH/" + port + "/";
      replace_kb_item(name:prefix + "Failure", value:TRUE);

      if(isnull(user) || strlen(user) == 0)
        user = "Unknown User";
      if(isnull(msg) || strlen(msg) == 0)
        msg = "No details available";

      lcx::log_issue(type:lcx::ISSUES_AUTH, msg:msg, port:port,
        proto:lcx::PROTO_SSH, user:user);

      return NULL;
    }

    ##
    # Records errors per command that is run locally using SSH. Command
    # errors are also recorded as an error in the session.
    #
    # @param [src:string] The function name where the error occurred.
    # @param [err_msg:string] A string description of the error that occurred.
    ##
    public function set_cmd_error(src, err_msg)
    {
      if (isnull(err_msg))
        err_msg = _FCT_ANON_ARGS[0];

      cmd_error += '\n' + err_msg;
      set_error(src:src, err_msg:err_msg);

      return NULL;
    }

    ##
    # Clears the current per-command error.
    #
    # @remark
    # This is to be run before executing a new local command on the target.
    ##
    public function clear_cmd_error()
    {
      cmd_error = NULL;

      return NULL;
    }

    ##
    # Reports if the last command timed out.
    #
    # @return [boolean] A boolean set to TRUE if the last command was interrupted, FALSE otherwise.
    ##
    public function last_cmd_interrupted()
    {
      return cmd_interrupted;
    }

    ##
    # Resets the ``cmd_interrtupted`` boolean variable.
    ##
    public function reset_cmd_interrupted()
    {
      cmd_interrupted = FALSE;
      return NULL;
    }


    ##
    # Called after a successful key exchange with the SSH server, this function
    # establishes the newly negotiated cipherset object as the working
    # cipher set for the current session.
    ##
    public function new_keys()
    {
      cipherset = new_cipherset;
      new_cipherset = NULL;

      encrypted = TRUE;

      return NULL;
    }

    ##
    # Initializes new cipherset for session with algorithms negotiated at the start
    # of key exchange. Associates the current session with the new cipher set.
    ##
    public function init_new_crypto()
    {
      new_cipherset.set_crypto_alg(mode:MODE_OUT, this.kex_handler.encryption_alg_c_to_s);
      new_cipherset.set_crypto_alg(mode:MODE_IN, this.kex_handler.encryption_alg_s_to_c);

      new_cipherset.set_mac_alg(mode:MODE_OUT, this.kex_handler.mac_alg_c_to_s);
      new_cipherset.set_mac_alg(mode:MODE_IN, this.kex_handler.mac_alg_s_to_c);

      new_cipherset.set_session(this);

      return NULL;
    }

    ##
    # Closes and removes the open channels of the current session.
    #
    # @return [NULL] This function always returns NULL.
    ##
    public function close_channels()
    {
      #for each non-closed channel in the channel manager, close them!
      if (typeof(channel_manager) == 'object')
      {
        if (!isnull(max_index(keys(channel_manager.channels))))
        {
          foreach var managed_channel (channel_manager.channels)
          {
            if (!isnull(managed_channel))
            {
              if (managed_channel.state != CHANNEL_STATE_CLOSED)
              {
                managed_channel.close();
              }
            }
          }
        }
      }
      return NULL;
    }

    ##
    # Closes the socket associated with the current session, set the session state
    # to closed and deletes objects associated with the session. If an error message
    # is supplied it sets it as an error in the session state.
    #
    # @param [error:string] String describing any error associated with closing the socket.
    #
    # @return [NULL] This function always returns NULL.
    ##
    public function close_socket(error)
    {
      var fn = 'session.close_socket';

      if(!isnull(error))
        set_error(src:fn, err_msg:error);

      # Verify that socket is still open
      if(cur_state.val == "SOC_CLOSED")
      {
        dbg_log(lvl:1, src:fn, msg:"Socket("+number+") has already been closed.");
        return NULL;
      }

      cur_state.set("SOC_CLOSED");
      close_channels();

      if(compression_enabled_s_to_c)
        disable_compression(mode:MODE_IN);
      if(compression_enabled_c_to_s)
        disable_compression(mode:MODE_OUT);
      encrypted = FALSE;
      seqn_r = 0;
      seqn_w = 0;

      if (!isnull(sftp_session) && typeof(sftp_session) == 'object')
      {
        delete(sftp_session);
        sftp_session = NULL;
      }

      if (typeof(kex_handler) == 'object')
        delete(kex_handler);
      if (typeof(channel_manager) == 'object')
        delete(channel_manager);
      if (!isnull(cipherset.cipher_s_to_c) && typeof(cipherset.cipher_s_to_c) == 'object')
        delete(cipherset.cipher_s_to_c);
      if (!isnull(cipherset.cipher_c_to_s) && typeof(cipherset.cipher_c_to_s) == 'object')
        delete(cipherset.cipher_c_to_s);
      if (typeof(cipherset) == 'object')
        delete(cipherset);
      if (!isnull(new_cipherset) && typeof(new_cipherset) == 'object')
        delete(new_cipherset);

      if(!TAP_MODE && nasl_level() >= 6900 && !is_sock_open(socket))
      {
        dbg_log(lvl:1, src:fn, msg:"Socket is no longer open - possibly closed by the remote host.");
        close(socket);
        return NULL;
      }

      dbg_log(lvl:2, src:fn, msg:"Closing socket.");

      if (TAP_MODE)
        tap_mode_close_socket(socket);
      else
        close(socket);

      return NULL;
    }

    ##
    # Initializes the session object.
    ##
    function session()
    {
      this.number = _SESSION_NUMBER_COUNTER;
      _SESSION_NUMBER_COUNTER += 1;

      dbg_log(src:FUNCTION_NAME, lvl:3, msg:'Initializing session object.');

      last_error = "";
      packet_handler_callbacks = SSH_CLIENT_HANDLERS;

      cur_state.set_session(this);

      dbg_log(src:FUNCTION_NAME, lvl:3, msg:'Setting state to "SOC_CLOSED" (this is not an error).');
      cur_state.set("SOC_CLOSED");

      return NULL;
    }

    ##
    # Runs the last instructions before the object is destroyed.
    ##
    function ~session()
    {
      dbg_log(src:FUNCTION_NAME, lvl:3, msg:'Closing session object.');
    }

    ##
    # Returns the number of the current session.
    #
    # @remark
    # The session number is assigned when the session is created from a global variable
    # counter. So the number means that this is the nth session created in a given plugin run.
    #
    # @return [integer] Integer number of the current session
    ##
    public function get_number()
    {
      return this.number;
    }

    ##
    # Return the default channel object. This is usually the first channel created
    # for a connection.
    #
    # @return [object] The default channel object of the current connection's channel manager.
    #         I.e. the return value of `sshlib::ChannelManager.get_default_channel()`_.
    ##
    public function get_default_channel()
    {
      return this.channel_manager.get_default_channel();
    }

    ##
    # Return the shell handler object owned by the default channel.
    #
    # @return [object] The shell handler of the default channel.
    ##
    public function get_default_shell_handler()
    {
      var dc = this.get_default_channel();
      return dc.shell_handler;
    }

    ##
    # This function initiates a new SSH session by requesting that the server open
    # a channel. The channel particulars are extracted from the SSH messages and
    # stored in a new channel object.
    #
    # @param [type:string] String denoting a channel type per definition of ``SSH_MSG_CHANNEL_REQUEST`` - see IETF RFC4254.
    # @param [options:data] Binary string representing options for the selected channel type.
    #
    # @param [window:integer] Integer local window size. The window size specifies how many bytes the other party can send
    #                         before it must wait for the window to be adjusted.
    #
    # @param [maxpacket:integer] Integer size of the largest packet that we can handle.
    #
    # @return [object|boolean] A new channel object if the request is successful, FALSE otherwise.
    ##
    public function get_channel(type, options, window, maxpacket)
    {
      if(cur_state.val == "SOC_CLOSED")
        return set_error(src:FUNCTION_NAME, err_msg:"Socket closed, unable to obtain channel.");

      if(isnull(type))
        type = "session";
      var channel = channel_manager.open_new_channel(
        type      : type,
        options   : options,
        window    : window,
        maxpacket : maxpacket
      );

      channel.open_channel();

      var cb = @client_cb_check_channel_not_pending;
      sshrecv_until(end_states:make_list("SOC_CLOSED"), check_callback:cb, channel:channel);

      if(channel.state == CHANNEL_STATE_ACCEPTED)
        return channel;

      # If the remote SSH server denied the channel open request with
      # a packet of type CHANNEL_OPEN_FAILURE, then the channel state
      # will have been set to CHANNEL_STATE_DENIED.
      # There's a race condition in OpenSSH that results in channel
      # open failure if MaxSessions is set to 1, so try one more time
      # to open a channel.
      if (channel.state != CHANNEL_STATE_DENIED)
        return FALSE;

      channel_manager.remove_channel(channel:channel);
      delete(channel);

      channel = channel_manager.open_new_channel(
        type      : type,
        options   : options,
        window    : window,
        maxpacket : maxpacket);

      channel.open_channel();

      sshrecv_until(end_states:make_list("SOC_CLOSED"), check_callback:cb, channel:channel);

      if(channel.state == CHANNEL_STATE_ACCEPTED)
        return channel;
      else
        return FALSE;
    }


    ##
    # Sends a packet over an open SSH connection to the remote server.
    #
    # @remark
    # Handles client to server compression and encryption if they are connfigured.
    #
    # @param [data:data] SSH packet data
    # @param [code:integer] The SSH message code. Message code enumerations are defined in
    #                       `ssh_lib_util.static`_ (e.g. ``PROTO_SSH2_MSG_CHANNEL_DATA``).
    #
    # @return [integer|NULL] If ``code`` is not given, the return value of the engine function ``send()`` is return (i.e. an integer).
    #                        Otherwise this function returns NULL even if an error occurred.
    ##
    public function sshsend(data, code)
    {
      var pkt_len, pad, pad_len, pkt_data, padding_len, payload, i;
      var fn = 'session.sshsend';
      var send_status;
      var packet_log = [];

      # Verify socket is still open before sending
      if (!check_socket())
        return NULL;

      if(isnull(code))
      {
        if (strlen(data))
        {
          dbg_add_packet(list:packet_log, msg:'Outgoing Unencrypted packet', data:data);
          dbg_log(src:fn, packets:packet_log);
        }
        if(TAP_MODE)
        {
          send_status = tap_mode_send(socket:socket,data:data);
          if(!send_status || send_status < 0)
            handle_socket_error();
          return send_status;
        }
        else
        {
          send_status = send(socket:socket,data:data);
          if(!send_status || send_status < 0)
            handle_socket_error();
          return send_status;
        }
      }
      if(compression_enabled_c_to_s && strlen(raw_string(code) + data))
      {
        dbg_add_packet(
          list:packet_log,
          msg:'Outgoing Uncompressed Payload',
          data:raw_string(code) + data,
          packet_code:code);
      }

      if(compression_enabled_c_to_s)
        payload  = gzip_deflate(data:raw_string(code) + data, flush:Z_PARTIAL_FLUSH, stream:defl_strm);
      else
        payload = raw_string(code) + data;

      pkt_len = strlen(payload) + 1; # payload + padding length

      #If we are using an ETM MAC, don't add length bytes to encryption length
      var pkt_len_len = 4;
      if(encrypted && (cipherset.is_etm(mode:MODE_OUT)|| cipherset.is_gcm(mode:MODE_OUT)))
        pkt_len_len = 0;

      if (!encrypted)
      {
        pad_len = 8 - ((pkt_len + pkt_len_len) % 8);
        if(pad_len < 4)
          pad_len += 8;
      }
      else
      {
        pad_len = cipherset.get_block_size(mode:MODE_OUT) - ((pkt_len + pkt_len_len) % cipherset.get_block_size(mode:MODE_OUT));
        if(pad_len < 4)
          pad_len += cipherset.get_block_size(mode:MODE_OUT);
      }

      pkt_len += pad_len;

      pad = "";
      for (i = 0; i < pad_len; i++)
        pad += mkbyte(rand() % 256);

      #Packet length is outside of encryption for ETM MACs
      if(!encrypted || (!cipherset.is_etm(mode:MODE_OUT) && !cipherset.is_gcm(mode:MODE_OUT)))
        pkt_data = mkdword(pkt_len, order:BYTE_ORDER_BIG_ENDIAN);
      else
        pkt_data = '';

      pkt_data += mkbyte(pad_len)  +
                  payload +
                  pad;

      if(strlen(pkt_data))
      {
        var tmp = '';
        if(compression_enabled_c_to_s)
          tmp = '/Compressed';
        dbg_add_packet(
          list:packet_log,
          msg:'Outgoing Raw Unencrypted' + tmp + ' packet',
          data:pkt_data,
          packet_code:code);
      }

      if (encrypted)
      {
        var mac, enc_pkt_len;

        mac = '';
        if(!cipherset.is_etm(mode:MODE_OUT) && !cipherset.is_gcm(mode:MODE_OUT))
          mac = cipherset.mac_compute(mode:MODE_OUT, data:pkt_data);

        if(cipherset.is_gcm(mode:MODE_OUT))
        {
          enc_pkt_len = mkdword(strlen(pkt_data));

          var cipher_result = cipherset.encrypt(data:pkt_data);
          pkt_data = cipher_result[0] + cipher_result[1];
          pkt_data = enc_pkt_len + pkt_data;
        }
        else
        {
          pkt_data = cipherset.encrypt(data:pkt_data);
        }

        if(cipherset.is_etm(mode:MODE_OUT) && !cipherset.is_gcm(mode:MODE_OUT))
        {
          enc_pkt_len = mkdword(strlen(pkt_data));
          pkt_data = enc_pkt_len + pkt_data;

          mac = cipherset.mac_compute(mode:MODE_OUT, data:pkt_data);
        }

        pkt_data += mac;
      }

      if(encrypted && strlen(pkt_data))
      {
        dbg_add_packet(
          list:packet_log,
          msg:'Outgoing Encrypted packet',
          data:pkt_data,
          packet_code:code);
      }

      dbg_log(src:fn, reverse:TRUE, packets:packet_log);

      if(TAP_MODE)
      {
        send_status = tap_mode_send(socket:socket, data:pkt_data);
        if(!send_status || send_status < 0)
          handle_socket_error();
        seqn_w++;
        return NULL;
      }

      send_status = send(socket:socket, data:pkt_data);
      if(!send_status || send_status < 0)
        handle_socket_error();
      seqn_w++;

      return NULL;
    }

    ##
    # Waits on the SSH socket, reading packets and dispatching them to
    # callbacks based on the SSH message code until one of the designated
    # end states is reached, the specified check callback returns true or
    # the socket is closed due to error or handling a message.
    #
    # @param [endstates:array] An array of strings describing SSH communication end states.
    #
    # @param [check_callback:function reference] A reference to a callback function that designates
    #        criteria for the end of message processing by returning TRUE.
    #
    # @param [channel:object] The current channel object instance.
    # @param [timeout:integer] Seconds that may elapse waiting for a single reply from the SSH server.
    # @param [cmd_timeout:integer] Seconds that may elapse during the processing of messages.
    # @param [inactivity_timeout:integer] Seconds that may elapse waiting for replies from the SSH server.
    #
    # @param [track_keepalives:boolean] Boolean flag to enable timeout via tracking "keepalive@openssh.com"
    #        messages. Used for sonicwall devices. (optional)
    #
    # @return [NULL] This function always returns NULL. Instead, everything received is stored in global variables.
    #
    # @remark
    # Possible end states are enumerated in `ssh_lib_state.static`_ in the global list ``ssh_client_allowed_states``.
    ##
    public function sshrecv_until(end_states, check_callback, &channel, timeout, cmd_timeout, inactivity_timeout, track_keepalives)
    {
      var func;
      var type_label;
      var fn = 'session.sshrecv_until';

      var ts;
      var keepalives = 0;
      var last_activity_ts;

      last_packet = NULL;

      if((isnull(timeout) || cmd_timeout < timeout) && !isnull(cmd_timeout))
        timeout = cmd_timeout;

      if(TAP_MODE && !cmd_timeout)
        cmd_timeout = 2;

      if (cmd_timeout)
        ts = unixtime();
      if (inactivity_timeout)
        last_activity_ts = ts;

      while (
        ((!cmd_timeout) || ((unixtime() - ts) < cmd_timeout)) &&
        ((!inactivity_timeout) || ((unixtime() - last_activity_ts) < inactivity_timeout))
      )
      {
        if(!isnull(end_states) && cur_state.oneof(state_list:end_states))
          break;
        if(!isnull(check_callback) && check_callback(session:this, channel:channel))
          break;

        if(track_keepalives)
        {
          if("keepalive@openssh.com" >< last_packet.payload)
            keepalives++;
          if(keepalives > 10)
            break;
        }

        last_packet = NULL;
        sshrecv(timeout:timeout);

        if(cur_state.val == "SOC_CLOSED" || channel.state == CHANNEL_STATE_CLOSED)
          break;

        if(isnull(last_packet))
        {
          func = packet_handler_callbacks[-1];
          type_label = ssh2_packet_type_labels[-1];
        }
        else
        {
          last_activity_ts = unixtime();
          func = packet_handler_callbacks[last_packet.type];
          type_label = ssh2_packet_type_labels[last_packet.type];
        }

        dbg_log(src:fn, msg:'Handling packet.type: ' + last_packet.type + ' [' + type_label + ']');
        if(!func)
        {
          this.close_connection();
          exit(1,"No handler for packet type " + last_packet.type + " [" + type_label +"].");
        }

        func(session:this);
      }

      if(cmd_timeout && (unixtime() - ts) >= cmd_timeout)
        dbg_log(lvl:1, src:fn, msg:cmd_timeout + '-second cmd_timeout reached');

      if(inactivity_timeout && (unixtime() - last_activity_ts) >= inactivity_timeout)
        dbg_log(lvl:1, src:fn, msg:inactivity_timeout + '-second inactivity_timeout reached');

      return NULL;
    }

    ##
    # Creates and returns an identifier unique to the remote host and port.
    #
    # @return [string] String representation of a MD5 hash of the remote host and port.
    ##
    public function get_kb_connection_id()
    {
      return hexstr(MD5(remote_host)) + "/" + port;
    }


    ##
    # Opens connection and does initial banner exchange to trigger binary protocol
    # transport.
    #
    # @param [host:string] String host name or ip address of the remote SSH server.
    # @param [port:integer] Listening port of the remote SSH server.
    # @param [existing_socket:integer] Socket descriptor to use instead of opening a new one (optional, reference).
    #
    # @return [boolean] Returns TRUE if the attempt to open a connection succeeds, FALSE otherwise
    ##
    public function open_connection(host, port, &existing_socket)
    {
      var version;
      var fn = "session.open_connection";

      dbg_log(src:fn, lvl:2, msg:'Opening the SSH connection.');

      if(!isnull(port))
        this.port = port;

      if(!isnull(host))
        this.remote_host = host;

      if(empty_or_null(this.remote_host))
        this.remote_host = get_host_name();

      var retry = 0;
      do
      {
        if(cur_state.val != "SOC_CLOSED")
          return set_error(src:fn, err_msg:"Error - expected SOC_CLOSED state of open_connection(), got " + cur_state.val);

        if(!isnull(existing_socket) && retry == 0)
        {
          # Verify socket is a valid integer
          if(typeof(existing_socket) != "int" || existing_socket < 1)
            return set_error(src:fn, err_msg:"Error - invalid existing_socket value '"+existing_socket+"'.");

          # Verify socket is still open
          if(!TAP_MODE && nasl_level() >= 6900 && !is_sock_open(existing_socket))
          {
            set_error(src:fn, err_msg:"Error - existing_socket '"+existing_socket+"' is no longer open.");
            # Call close_socket() so that objects are properly cleaned up
            close_socket();
            return NULL;
          }
          set_socket(existing_socket);
          dbg_log(src:fn, msg:"Using existing socket.");
        }
        else
        {
          if(isnull(port) || port == "")
            return set_error(src:fn, err_msg:"Error - no port specified.");

          if(typeof(port) != "int")
            return set_error(src:fn, err_msg:"Error - non integer port specified.");

          if(TAP_MODE)
            set_socket(tap_mode_get_socket());
          else if(!isnull(host))
          {
            if(nasl_level() >= 6600 && !rules_validate_target(target:host, port:port))
              return set_error(src:fn, err_msg:"Connecting to host "+host+" port "+port+" violates user-defined rules.");

            dbg_log(lvl:2, src:fn, msg:"Connecting to host '"+host+"', port "+port+".");
            set_socket(open_sock2(host:host, port:port));
          }
          else
          {
            dbg_log(lvl:2, src:fn, msg:"Connecting to port "+port+".");
            set_socket(open_sock_tcp(port));
          }

          if(!socket)
            return set_error(src:fn, err_msg:"Failed to open a socket on port "+port+".");

          dbg_log(src:fn, msg:"Socket opened on port " + port + '.');
        }

        cur_state.set("SOC_OPENED");

        # Reset remote_version so that sshrecv() does not expect a packet
        remote_version = FALSE;

        # it's possible that a server may try to send banner + first kex packet in first request
        # it's not RFC compliant, but it came up as a test case from QA, so the code below
        # only recvs until the newline and leaves the rest in the buffer for later
        version = '';
        var tmp_chr = '';
        # initial connection may be slow on some devices
        tmp_chr = sshrecv(timeout:30, length:1);
        var i = 0;

        while(tmp_chr != '' && !isnull(tmp_chr) && tmp_chr != '\n' &&
              cur_state.val == "SOC_OPENED" && i < 512)
        {
          version += tmp_chr;
          tmp_chr = sshrecv(timeout:5, length:1);
          i++;
        }

        if(!version)
          return close_socket(error:"No remote version received");

        dbg_log(src:fn, msg:"Received server version: " + version);

        #Trim training CR/LF characters, but leave trailing spaces.  At least one older
        #version of OpenSSL on FreeBSD includes trailing spaces in the server version.
        remote_version = ereg_replace(string:version, pattern:'[\r\n]+$', replace:'');

        if(remote_version =~ "^Not allowed at this time")
        {
          ++retry;
          if(retry == 1)
          {
            if(!TAP_MODE)
              close(this.socket);
            else
              TAP_NEXT_SOCKET--;
            set_socket(NULL);
            dbg_log(src:fn, msg:"Handling noauth PerSourcePenalty - sleep 30 seconds then retry.");
            #Assumes a noauth:1 min:15 post OpenSSH 9.8 default configuration with no run down.
            sleep(30);
            cur_state.set("SOC_CLOSED");
          }
          else
          {
            return close_socket(error:"Handling noauth PerSourcePenalty - retry failed.");
          }
        }
        else
        {
          retry = 0;
        }
      }
      while(retry == 1);

      var ver_num_match;
      ver_num_match = pregmatch(pattern:"^SSH-(2\.0|1\.\d+)-", string:remote_version);
      if (isnull(ver_num_match))
        return close_socket(error:"Bad remote version string received '" + remote_version + "'");

      # We should check to see if the version is < 1.99 here. If so, we should
      # fall back to legacy code, if we arrived here *through* legacy code
      # (through one of the wrapper functions).
      if (ver_compare(ver:ver_num_match[1], fix:'1.99', strict:TRUE) < 0)
      {
        close_socket(error:"Based on its reported version '"+remote_version+"', the remote SSH server does not support SSH 2.0.");
        return FALSE;
      }

      # If compression has been tried and disabled from a previous test, supress it here.
      if (get_kb_item(SSH_LIB_KB_PREFIX + "disable_compression"))
      {
        KEX_SUPPORTED_NAME_LISTS["compression_algorithms_server_to_client"] = "none";
        KEX_SUPPORTED_NAME_LISTS["compression_algorithms_client_to_server"] = "none";
      }

      kex_handler = new("sshlib::kex_handler", this);
      kex_handler.set_supported_namelists(KEX_SUPPORTED_NAME_LISTS);
      channel_manager = new("sshlib::ChannelManager", this);

      if(isnull(local_version))
        local_version = get_ssh_client_ver();

      sshsend(data:local_version+'\n');

      dbg_log(src:fn, lvl:2, msg:'SSH connection successfully opened.');

      #We might have had to open a new socket for PerSourcePenalties
      if(!isnull(existing_socket))
        existing_socket = this.socket;

      return TRUE;
    }

    ##
    # Checks the current local state of the socket and if it is still open, closing it if necessary.
    #
    # @return [boolean] TRUE if the socket is open, FALSE otherwise.
    #
    # @remark
    # This should be called before every call to ``send()``, ``recv()``, or ``close()``.
    ##
    function check_socket()
    {
      var fn = 'check_socket';
      if(cur_state.val == "SOC_CLOSED")
      {
        dbg_log(lvl:1, src:fn, msg:"Socket("+number+") has already been closed.");
        return FALSE;
      }
      if(!TAP_MODE && nasl_level() >= 6900 && !is_sock_open(socket))
      {
        dbg_log(lvl:1, src:fn, msg:"Socket("+number+") is no longer open.");
        # Call close_socket() so that objects are properly cleaned up
        close_socket();
        return FALSE;
      }
      return TRUE;
    }

    ##
    # Receives and validates a single SSH packet over the current SSH connection.
    # Encrypted packets are decrypted and compressed packets are decompressed.
    #
    # @param [timeout:integer] The number of seconds that may elapse while the function
    #                          waits to receive a packet from the remote SSH server.
    # @param [length:integer] The expected packet length.
    #
    # @return [data] Returns a binary string representation of the packet if a valid
    #                SSH packet was received, NULL otherwise.
    ##
    public function sshrecv(timeout, length)
    {
      var fn = 'session.sshrecv';

      # Verify socket is still open before receiving
      if (!check_socket())
        return NULL;

      if(isnull(timeout))
        timeout = this.recv_timeout;

      # Respect the policy value for the recv timeout if it is higher
      var policy_timeout = int(get_preference("checks_read_timeout"));
      if (policy_timeout && policy_timeout > timeout)
        timeout = policy_timeout;

      var need, mac, computed_mac, payload;

      if(isnull(length))
        length = MAX_PACKET_SIZE;

      # Versions not exchanged
      if(!remote_version)
      {
        if(TAP_MODE)
          pkt_data = tap_mode_recv(socket:socket, length:length);
        else
          pkt_data = recv(socket:socket, length:length, timeout:timeout);

        if(isnull(pkt_data))
          handle_socket_error();
        return pkt_data;
      }
      if (!encrypted)
      {
        if(TAP_MODE)
          pkt_raw = tap_mode_recv(socket:socket, length:4, min:4);
        else
          pkt_raw = recv(socket:socket, length:4, min:4, timeout:timeout);

        if(strlen(pkt_raw) < 4)
        {
          if(isnull(pkt_raw))
            handle_socket_error();
          dbg_log(lvl:1, src:fn, msg:"Invalid packet, less than 4 bytes received.");
          return NULL;
        }

        var pktlen = getdword(blob:pkt_raw, pos:0, order:BYTE_ORDER_BIG_ENDIAN);
        if(pktlen <= 0)
          return close_socket(error:"Invalid packet length '"+pktlen+"'.");
        else if(pktlen > MAX_PACKET_SIZE)
          return close_socket(error:"Packet length '"+pktlen+"' is larger than MAX_PACKET_SIZE.");

        # Verify socket is still open before receiving again
        if (!check_socket())
          return NULL;

        if(TAP_MODE)
          pkt_data = tap_mode_recv(socket:socket, length:pktlen, min:pktlen);
        else
          pkt_data = recv(socket:socket, length:pktlen, min:pktlen, timeout:timeout);
        if(isnull(pkt_data))
          handle_socket_error();

        pkt_raw += pkt_data;

        if(strlen(pkt_raw))
        {
          dbg_log(
            src:fn,
            packets:dbg_add_packet(msg:'Incoming Unencrypted packet', data:pkt_raw));
        }

        last_packet = new("sshlib::sshpacket",pkt_raw);
      }
      else
      {
        var initial_read_len, len;
        var packets_log = [];

        #Read in the etm mac data len (aadlen)
        if(cipherset.is_etm(mode:MODE_IN) || cipherset.is_gcm(mode:MODE_IN))
        {
          if(TAP_MODE)
            len = tap_mode_recv(socket:socket, length:4, min:4);
          else
            len = recv(socket:socket, length:4, min:4, timeout:timeout);
          if(isnull(len))
            handle_socket_error();

          if(strlen(len) == 0)
            return len;

          initial_read_len = getdword(blob:len, pos:0, order:BYTE_ORDER_BIG_ENDIAN);

          #Add the MAC/Tag length for authenticated ciphers like aes-gcm
          initial_read_len += cipherset.get_tag_len(mode:MODE_IN);

          dbg_add_packet(list:packets_log, msg:'Incoming packet length for ETM or GCM ciphers', data:len);

          len = initial_read_len;
        }
        else
          initial_read_len = cipherset.get_block_size(mode:MODE_IN);

        # Verify socket is still open before receiving again
        if (!check_socket())
          return NULL;

        if(TAP_MODE)
          pkt_raw  = tap_mode_recv(socket:socket, length:initial_read_len, min:initial_read_len);
        else
          pkt_raw  = recv(socket:socket, length:initial_read_len, min:initial_read_len, timeout:timeout);

        if(isnull(pkt_raw))
          handle_socket_error();

        if(strlen(pkt_raw) == 0)
          return pkt_raw;

        pkt_data = cipherset.decrypt(data:pkt_raw);
        if(!cipherset.is_etm(mode:MODE_IN) && !cipherset.is_gcm(mode:MODE_IN))
          len = getdword(blob:pkt_data, pos:0, order:BYTE_ORDER_BIG_ENDIAN);

        if(len <= 0)
        {
          close_socket(error:"Invalid packet length '"+len+"' after decrypting packet.");
          if(strlen(pkt_raw))
            dbg_add_packet(list:packets_log, msg:'Incoming Raw Encrypted data', data:pkt_raw);
          if(strlen(pkt_data))
            dbg_add_packet(list:packets_log, msg:'Incoming Decrypted data', data:pkt_data);

          dbg_log(src:fn, packets:packets_log);
          return NULL;
        }
        else if(len > MAX_PACKET_SIZE)
        {
          close_socket(error:"Packet length '"+len+"' after decrypting packet is larger than MAX_PACKET_SIZE.");
          if(strlen(pkt_raw))
            dbg_add_packet(list:packets_log, msg:'Incoming Raw Encrypted data', data:pkt_raw);
          if(strlen(pkt_data))
            dbg_add_packet(list:packets_log, msg:'Incoming Decrypted data', data:pkt_data);

          dbg_log(src:fn, packets:packets_log);
          return NULL;
        }

        if(cipherset.is_etm(mode:MODE_IN) && !cipherset.is_gcm(mode:MODE_IN))
        {
          pkt_data = mkdword(len) + pkt_data;
        }
        else if(cipherset.is_gcm(mode:MODE_IN))
        {
          pkt_data = mkdword(len - cipherset.get_tag_len(mode:MODE_IN)) + pkt_data;
        }
        else
        {
          need = 4 + len - cipherset.get_block_size(mode:MODE_IN);

          # Verify socket is still open before receiving again
          if (!check_socket())
            return NULL;

          var left;
          if(TAP_MODE)
            left = tap_mode_recv(socket:socket, length:need, min:need);
          else
            left = recv(socket:socket, length:need, min:need, timeout:timeout);
          if(isnull(left))
            handle_socket_error();

          if (need != 0)
          {
            pkt_data = pkt_data + cipherset.decrypt(data:left);
            pkt_raw += left;
          }
        }

        last_packet = new("sshlib::sshpacket",pkt_data,infl_strm);
        var pkt_type = "type unknown";
        if (!isnull(last_packet.type))
          pkt_type = ssh2_packet_type_labels[last_packet.type];

        if(strlen(pkt_raw))
          dbg_add_packet(list:packets_log, msg:'Incoming Raw Encrypted packet', data:pkt_raw, packet_code:pkt_type);

        if(strlen(pkt_data))
          dbg_add_packet(list:packets_log, msg:'Incoming Decrypted packet', data:pkt_data, packet_code:pkt_type);

        if(!isnull(infl_strm) && strlen(raw_string(last_packet.type) + last_packet.payload))
        {
          dbg_add_packet(
            list:packets_log,
            msg:'Incoming Decrypted Decompressed packet',
            data:raw_string(last_packet.type) + last_packet.payload,
            packet_code:pkt_type);
        }

        dbg_log(src:fn, packets:packets_log);

        if ("Could not decompress packet" >< last_packet.error)
          return close_socket(error:"Failed to decompress packet.");

        if(cipherset.is_etm(mode:MODE_IN))
          computed_mac = cipherset.mac_compute(data:mkdword(len) + pkt_raw, mode:MODE_IN);

        # Verify socket is still open before receiving again
        if (!check_socket())
          return NULL;

        #Authenticated ciphers like aes-gcm process message authentication during decryption/encryption
        if(!cipherset.is_gcm(mode:MODE_IN))
        {
          if(TAP_MODE)
            mac = tap_mode_recv(socket:socket, length:cipherset.get_mac_len(mode:MODE_IN), min:cipherset.get_mac_len(mode:MODE_IN));
          else
            mac = recv(socket:socket, length:cipherset.get_mac_len(mode:MODE_IN), min:cipherset.get_mac_len(mode:MODE_IN), timeout:timeout);
        }

        # Compute and check MAC
        if(!empty_or_null(mac))
        {
          if(!cipherset.is_etm(mode:MODE_IN))
            computed_mac = cipherset.mac_compute(data:last_packet.raw, mode:MODE_IN);

          var mac_log = [];
          dbg_add_packet(list:mac_log, msg:'MAC received with last packet', data:mac);
          dbg_add_packet(list:mac_log, msg:'MAC computed from last packet', data:computed_mac);
          dbg_log(src:fn, max_level:TRUE, packets:mac_log);

          if (mac != computed_mac)
            return close_socket(error:"The MAC received with the packet does not match the computed MAC.");
        }
        else if(!cipherset.is_gcm(mode:MODE_IN) && isnull(mac))
        {
          handle_socket_error();
        }
      }
      seqn_r++;
      if (!isnull(last_packet) && !isnull(last_packet.type) && !isnull(last_packet.payload))
        return raw_string(last_packet.type) + last_packet.payload;
      else
        return NULL;
    }

    ##
    # Executes a local command on the target host using the open SSH connection.
    #
    # @param [command:string] The command to be executed.
    # @param [channel:object] A channel object for the current SSH connection.
    #
    # @param [use_shell_handler:boolean] A boolean that controls whether SSH exec or a shell
    #        handler will be used to run the command. (optional)
    #
    # @param [cmd_timeout_min:integer] The total number of seconds that may elapse
    #        waiting for the command response. (optional)
    #
    # @param [inactivity_timeout_min:integer] The number of seconds that may
    #        elapse with no data received from the target. (optional)
    #
    # @param [force_priv_escl:boolean] A boolean which if true will force an attempt to
    #        escalate privileges before running the command. (only when using a shell handler)
    #
    # @return [string|NULL] Returns the target host's response to running the command as a string, or
    #         NULL if the command fails.
    #
    # @remark
    # This function will dynamically determine and use the execution method (shell or exec) for the command
    # based on the findings of ``ssh_get_info2.nasl``. This behaviour is bypassed if ``use_shell_handler``
    # is set to TRUE.
    ##
    public function run_command(command, &channel, use_shell_handler, cmd_timeout_min, inactivity_timeout_min, force_priv_escl)
    {
      var ret;
      var ts = unixtime();
      var fn = 'session.run_command';
      reset_cmd_interrupted();

      # Depending on the shell handler, timeout may be used to
      # increase the inactivity timeout for the command response,
      # and/or passed to sshrecv_until() as the cmd_timeout
      if(use_shell_handler)
        ret = run_shell_command(
          channel                : channel,
          command                : command,
          force_priv_escl        : force_priv_escl,
          cmd_timeout_min        : cmd_timeout_min,
          inactivity_timeout_min : inactivity_timeout_min
        );
      # For exec, timeout is passed to sshrecv_until() as the cmd_timeout
      # exec handling does not currently implement inactivity handling
      else
        ret = run_exec_command(
          command                : command,
          cmd_timeout_min        : cmd_timeout_min,
          inactivity_timeout_min : inactivity_timeout_min
        );

      return ret;
    }

    ##
    # Run a command over the SSH connection using the facility for execution of single
    # commands without a shell.
    #
    # @remark
    # WARNING: Passing untrusted input to this function may result in unexpected command execution.
    #
    # @param [command:string] The command to be executed.
    #
    # @param [cmd_timeout_min:integer] The total number of seconds that may elapse
    #        waiting for the command response. (optional)
    #
    # @param [inactivity_timeout_min:integer] The number of seconds that may
    #        elapse with no activity from the target. (optional)
    #
    # @return [string|NULL] Returns the target host's response to running the command as a string, or
    #         NULL if the command fails.
    ##
    public function run_exec_command(command, cmd_timeout_min, inactivity_timeout_min)
    {
      var fn = 'session.run_exec_command';
      reset_cmd_interrupted();

      if(cur_state.val == "SOC_CLOSED")
        return set_error(src:fn, err_msg:"Unable to execute command on closed ssh socket.");

      var channel = get_channel();
      if(!channel)
        return set_error(src:fn, err_msg:"Failed to get channel.");

      # Set a default timeout; this is the cmd_timeout for sshrecv_until()
      # to receive all data, so it should be relatively high
      var cmd_timeout = 180;
      if (TAP_MODE)
        cmd_timeout = 0;
      if (cmd_timeout < cmd_timeout_min)
        cmd_timeout = cmd_timeout_min;

      # Set the inactivity timeout if passed; this limits the length of time sshrecv_until() will continue attempting to
      # receive while there's no response from the target
      var inactivity_timeout = NULL;
      if (inactivity_timeout_min)
        inactivity_timeout = inactivity_timeout_min;

      clear_cmd_error();
      channel.make_request(type:"exec", want_reply:TRUE, extra:mk_ssh_string(command));

      sshrecv_until(
        end_states         : make_list("SOC_CLOSED"),
        check_callback     : @run_exec_command_cb,
        channel            : channel,
        timeout            : this.recv_timeout,
        cmd_timeout        : cmd_timeout,
        inactivity_timeout : inactivity_timeout
      );

      var cmd_logger = new("sshlib::cmd_logger");

      var failed_needs_escl = FALSE;
      if ((!empty_or_null(channel.data_buf) && is_priv_escl_required(cmd_res:channel.data_buf)) ||
          (!empty_or_null(channel.stderr) && is_priv_escl_required(cmd_res:channel.stderr)) )
        failed_needs_escl = TRUE;

      if(failed_needs_escl)
      {
        dbg_log(
          lvl:2,
          src:fn,
          msg:'The command response or error message indicates that privilege escalation may be ' +
              'required to run the command.',
          msg_details:{
            "Command": {"lvl":2, "value":command},
            "Response": {"lvl":2, "value":channel.data_buf},
            "Error": {"lvl":2, "value":channel.stderr}});
      }

      if(channel.state != CHANNEL_STATE_CLOSED)
        channel.close();

      # If no exit-status was sent back in the channel, then the exec command
      # did not complete successfully.
      cmd_interrupted = isnull(channel.last_exit_status);
      if(cmd_interrupted)
      {
        # record error for logging
        set_cmd_error("Command did not complete due to timeout or other error.");
        dbg_log(lvl:1, src:fn, msg:'The command "' + command + '" did not complete due to timeout or error.');
      }

      cmd_logger.add(cmd:command, response:channel.data_buf, error:cmd_error, failed_needs_escl:failed_needs_escl, user:this.user);

      if(channel.last_response && !empty_or_null(channel.data_buf))
        return channel.data_buf;
      else
        return NULL;
    }

    ##
    # Open a new channel, reconnecting first if necessary and copying
    # over shell handler settings if applicable.
    #
    # @param [channel:object] A channel object for the current SSH connection.
    #
    # @return [boolean] TRUE if shell is replaced successfully, else FALSE.
    ##
    public function replace_shell(&channel)
    {
      var fn = this.objname + FUNCTION_NAME;
      var sh, sh_sets, needs_new_connection;

      if (this.cur_state.val == 'SOC_CLOSED')
      {
        this.set_error(src:fn, err_msg:'Session is closed, unable to replace shell.');
        return FALSE;
      }

      # If the channel is not NULL, save the shell handler type,
      # ensure the channel gets closed, re-open the connection if
      # necessary, and try to set the shell handler to the same type
      if (!isnull(channel))
      {
        # Store a local reference to the shell handler and its settings
        # so it can be reinitialized for use with new channel,
        # preserving settings
        sh = channel.shell_handler;
        sh_sets = channel.shell_handler.settings;
        needs_new_connection = channel.shell_handler.new_channel_needs_new_connection;
        # Close the unusable channel
        if (channel.state != CHANNEL_STATE_CLOSED)
        {
          dbg_log(src:fn, lvl:3, msg:'Closing unusable channel.');
          channel.close();
        }
      }

      # Some devices require a new connection for every new channel
      # A new connection may also be required after 10 channels
      # have been opened in the same session
      if(needs_new_connection || this.channel_manager.next_id >= 10)
      {
        dbg_log(src:fn, lvl:3, msg:'The shell handler needs a new connection. Creating new connection.');
        this.close_connection();
        if(!this.open_connection(port:port))
          return FALSE;
        if(!this.login())
          return FALSE;
      }

      # If channel was NULL or a shell handler was not created,
      # default to KB shell handler
      if (!sh)
        sh = get_kb_shell_handler();

      # Restore shell handler settings
      if (!isnull(sh_sets))
        sh.init(settings:sh_sets);

      # Open new channel
      dbg_log(src:fn, lvl:3, msg:'Opening new channel.');
      var newchan = this.open_shell(shell_handler:sh);
      if(!newchan)
      {
        set_error(src:fn, err_msg:"Failed to open shell.");
        return FALSE;
      }

      if (isnull(channel))
        this.channel_manager.set_default_channel(newchan);
      this.channel_manager.replace_channel(old_chan:channel, new_chan:newchan);
      channel = newchan;
      return TRUE;
    }

    ##
    # Executes a local command on the target host over the open SSH connection
    # using a shell handler.
    #
    # @remark
    # WARNING: Passing untrusted input to this function may result in unexpected command execution.
    #
    # @param [channel:object] A channel object for the current SSH connection.
    # @param [command:string] The command to be executed.
    #
    # @param [force_priv_escl:boolean] A boolean which if true will force an attempt to
    #        escalate privileges before running the command.
    #
    # @param [cmd_timeout_min:integer] The total number of seconds that may elapse
    #        waiting for the command response. (optional)
    #
    # @param [inactivity_timeout_min:integer] The number of seconds that may
    #        elapse with no data received from the target. (optional)
    #
    # @return [string|NULL] Returns the target host's response to running the command as a string, or
    #         NULL if the command fails.
    ##
    public function run_shell_command(&channel, command, force_priv_escl, cmd_timeout_min, inactivity_timeout_min)
    {
      var fn = 'session.run_shell_command';
      reset_cmd_interrupted();

      dbg_log(lvl:1, src:fn, msg:'Command to run: "'+command+'"');
      if (isnull(channel))
        channel = this.channel_manager.get_default_channel();

      # Check channel and replace if necessary; replace_shell() will
      # set applicable error if it fails
      if (!channel_usable_for_shell_command(channel:channel, nosetup_ok:TRUE) &&
          !this.replace_shell(channel:channel))
      {
        var err = 'Did not run command due to session error.' +
                  '\nCommand : ' + command + '\nSession error : "' + last_error + '"';
        return set_error(src:fn, err_msg:err);
      }

      if(isnull(channel.shell_handler) && isnull(nosetup_shell_handler))
      {
        return set_error(src:fn, err_msg:"No shell handler setup, run open_shell() before run_shell_command()");
      }

      clear_cmd_error();
      var cmd_result = NULL;
      if(!isnull(nosetup_shell_handler))
      {
        cmd_result = nosetup_shell_handler(
            session                : this,
            command                : command,
            force_priv_escl        : force_priv_escl,
            cmd_timeout_min        : cmd_timeout_min,
            inactivity_timeout_min : inactivity_timeout_min
          );
      }
      else
      {
        cmd_result = channel.shell_handler.run_command(
            channel                : channel,
            command                : command,
            force_priv_escl        : force_priv_escl,
            cmd_timeout_min        : cmd_timeout_min,
            inactivity_timeout_min : inactivity_timeout_min
          );
      }

      # Shell handlers have timed out and command error properties that can determine if the
      # command was interrupted.
      cmd_interrupted = channel.shell_handler.timed_out || channel.shell_handler.last_cmd_error;
      if(cmd_interrupted)
      {
        # record error for logging
        # will not be recoreded to ssh_commands.log in this case but including for log verbosity.
        set_cmd_error("Command did not complete due to timeout or other error.");
        dbg_log(lvl:1, src:fn, msg:'The command "' + command + '" did not complete due to timeout or error.');
      }
      return cmd_result;
    }

    ##
    # Closes the SSH connection and frees the objects associated with it.
    #
    # @return [NULL] This function always returns NULL.
    ##
    public function close_connection()
    {
      var fn = 'session.close_connection';
      if(cur_state.val != "SOC_CLOSED")
        close_socket();
      else
        dbg_log(lvl:1, src:fn, msg:"Socket is already closed.");

      return NULL;
    }

    ##
    # Creates and returns a new SFTP session object.
    #
    # @return [object] A newly created SFTP session object initialized with this sessions's channel.
    ##
    public function get_sftp_session()
    {
      if(isnull(this.sftp_session))
      {
        var channel = get_channel();
        if(!channel)
          return set_error(src:FUNCTION_NAME, err_msg:"Error - unable to get a channel for SSH server on port " + port + ".");
        this.sftp_session = new("sshlib::sftp_session", channel);
      }

      return this.sftp_session;
    }

    ##
    # Determines whether or not the shell handler needs to check the default login
    # shell of the provided user.
    #
    # @param [shell_handler:object] The shell handler object to check.
    #
    # @return [boolean] TRUE if the defaul shell check is required, FALSE otherwise.
    ##
    public function need_shell_check(shell_handler)
    {
      var fn = this.objname + FUNCTION_NAME;
      var default_shell;
      default_shell = get_kb_item(SSH_LIB_KB_PREFIX + get_kb_connection_id() + '/default_shell');

      if(typeof_ex(shell_handler) == 'sshlib::sh_shell_handler')
      {
        # The response may be a valid "default shell" result,
        # or it may be an error, which we should not mistake as valid
        if (
             isnull(default_shell) ||                                                     # invalid response
             (default_shell =~ "error" && default_shell =~ "invalid input detected") ||   # error response
             ("echo $SHELL" >< default_shell && "print $NF" >< default_shell)             # invalid command response
           )
        {
          dbg_log(lvl:3, src:fn, msg:'Opening sh shell handler; default shell is NULL, shell check is required.');
          return TRUE;
        }
        else
        {
          dbg_log(lvl:3, src:fn, msg:'Opening sh shell handler; default shell is '+default_shell+', calling shell check is not required.');
        }
      }

      return FALSE;
    }

    ##
    # Opens a shell or tty on the open SSH connection by acquiring a channel and then making
    # the appropriate request depending on the shell handler.
    #
    # @param [shell_handler:object] A shell handler object.
    #
    # @param [skip_check_shell:boolean] A boolean flag to skip the ``need_shell_check`` logic. Used
    #        when running "raw" commands via ``sshlib::sh_shell_handler``. (optional)
    #
    # @param [reconnect_retry_on_fail:boolean] A boolean flag to retry opening the connection and
    #        channel if the first attempt failed.
    #
    # @return [object|NULL] A channel object with an open request for a shell or tty on the target host,
    #         or NULL is returned if an error occurs.
    #
    # @remark
    # If the object given in ``shell_handler`` is for a no-setup shell the function will return
    # the global variable ``sshlib::NOSETUP``.
    ##
    public function open_shell(shell_handler, skip_check_shell, reconnect_retry_on_fail)
    {
      var fn = this.objname + FUNCTION_NAME;
      var extra = '';
      var opt, opts;
      var check_shell = FALSE;

      if(cur_state.val == "SOC_CLOSED")
        return set_error(src:fn, err_msg:"Unable to open shell on closed socket.");

      if(isnull(shell_handler))
      {
        this.close_connection();
        exit(1, "Need shell_handler for open_shell().");
      }

      if(shell_handler.is_nosetup())
      {
        this.nosetup_shell_handler = shell_handler.run_command_func;
        dbg_log(src:fn, lvl:3, msg:'The ' +typeof_ex(shell_handler)+' shell handler is a nosetup shell.');
        return NOSETUP;
      }

      # Determine the need_shell_check before sending pty-req
      # so that the pty-opts in the shell handler will be
      # set appropriately in the shell handler object
      if(!skip_check_shell)
        check_shell = need_shell_check(shell_handler:shell_handler);

      var channel = get_channel();

      if(!channel && reconnect_retry_on_fail)
      {
        dbg_log(src:fn, lvl:3, msg:'The shell handler needs a new connection. Creating new connection.');
        close_connection();
        if(!open_connection(port:port))
          return NULL;
        if(!login())
          return NULL;
        channel = get_channel();
      }

      if (!channel)
        return set_error(src:fn, err_msg:"Failed to get channel.");

      channel.set_shell_handler(shell_handler);

      if(shell_handler.send_pty_req())
      {
        extra = mk_ssh_string(shell_handler.get_pty_term());

        var size_chars = shell_handler.get_pty_size_chars();
        var size_pixels = shell_handler.get_pty_size_pixels();
        extra += mkdword(size_chars[0], order:BYTE_ORDER_BIG_ENDIAN) +
                 mkdword(size_chars[1], order:BYTE_ORDER_BIG_ENDIAN);

        extra += mkdword(size_pixels[0], order:BYTE_ORDER_BIG_ENDIAN) +
                 mkdword(size_pixels[1], order:BYTE_ORDER_BIG_ENDIAN);

        opts = shell_handler.get_pty_opts();

        var opt_str = '';
        foreach opt (keys(opts))
          opt_str += mkbyte(opt) + mkdword(opts[opt], order:BYTE_ORDER_BIG_ENDIAN);

        opt_str += mkbyte(PTY_OPT_TTY_OP_END);

        extra += mk_ssh_string(opt_str);

        channel.make_request(type:"pty-req", want_reply:FALSE, extra:extra);
      }

      var shell_channel_request_cb = shell_handler.get_shell_channel_request_cb();

      if(isnull(shell_channel_request_cb) || TAP_MODE)
      {
        channel.make_request(type:"shell", want_reply:FALSE);
      }
      else
      {
        channel.set_response(NULL);
        channel.make_request(type:"shell", want_reply:TRUE);

        dbg_log(src:fn, lvl:3, msg:'Requested "shell" channel request response to set prompt.  Waiting for reply.');
        this.sshrecv_until(
          end_states         : make_list("SOC_CLOSED"),
          channel            : channel,
          check_callback     : shell_channel_request_cb,
          timeout            : this.recv_timeout,
          cmd_timeout        : 40,
          inactivity_timeout : 40
        );
      }

      if(check_shell)
      {
        dbg_log(src:fn, lvl:3, msg:'Calling shell_handler.is_echo_required() to determine default shell.');
        shell_handler.is_echo_required(channel:channel, session:this);
      }

      return channel;
    }

    ##
    # Removes saved login data from the KB.
    #
    # @remark
    # This is called when "none" auth succeeds but the library
    # is being used with compatibility wrappers for example. In that case, "none" auth is bypassed.
    # This function clears the KB to make way for further authentication attempts.
    ##
    public function clear_saved_login_info()
    {
      var extra, key;
      rm_kb_item(name:SSH_LIB_KB_PREFIX + get_kb_connection_id() + "/cred_type");
      rm_kb_item(name:SSH_LIB_KB_PREFIX + get_kb_connection_id() + "/login_method");
      extra = get_kb_args(kb_prefix:"Secret/" + SSH_LIB_KB_PREFIX + get_kb_connection_id() + "/login_extra");
      foreach key (keys(extra))
        rm_kb_item(name:"Secret/" + SSH_LIB_KB_PREFIX + get_kb_connection_id() + "/login_extra/" + key);

      return NULL;
    }


    ##
    # Stores information about a successful authentication.
    #
    # @param [method:string] The authentication method: "none", "password", "keyboard-interactive", "gssapi", or "publickey".
    #
    # @param [cred_type:string] The credential type: "password", "public key", "certificate", "kerberos", or one of
    #        the password managers such as "Thycotic", "Centrify", etc.
    #
    # @param [extra:array] A dictionary of data supporting the authentication method such as credentials, keys, etc.
    # @param [save_login:boolean] A flag telling the function whether or not to save the login information in the KB (optional, defaults to FALSE).
    #
    # @return [boolean] This function always returns TRUE.
    ##
    private function save_login_info(method, cred_type, extra, save_login)
    {
      login_method = method;
      if(save_login)
      {
        save_kb_args(kb_prefix:"Secret/" + SSH_LIB_KB_PREFIX + get_kb_connection_id() + "/login_extra", args:extra);

        if(isnull(get_kb_item(SSH_LIB_KB_PREFIX + get_kb_connection_id() + "/login_method")) && !empty_or_null(method))
        {
          set_kb_item(name:SSH_LIB_KB_PREFIX + get_kb_connection_id() + "/login_method", value:method);
        }
        if(isnull(get_kb_item(SSH_LIB_KB_PREFIX + get_kb_connection_id() + "/cred_type")) && !empty_or_null(cred_type))
        {
          set_kb_item(name:SSH_LIB_KB_PREFIX + get_kb_connection_id() + "/cred_type", value:cred_type);
        }
      }
      return TRUE;
    }


    ##
    # Stores information about a successful escalation of privileges in the KB.
    #
    # @param [type:string] The escalation method: "su", "sudo", "su+sudo", "pbrun", "dzdo", or "cisco_enable".
    # @param [args:array] A dictionary of data supporting the escalation method such as credentials, high privilege user, etc.
    ##
    public function save_escalation_info(type, args)
    {
      save_kb_args(kb_prefix:"Secret/" + SSH_LIB_KB_PREFIX + get_kb_connection_id() + "/escalation_extra", args:args);
      if(isnull(get_kb_item(SSH_LIB_KB_PREFIX + get_kb_connection_id() + "/escalation_type")))
        set_kb_item(name:SSH_LIB_KB_PREFIX + get_kb_connection_id() + "/escalation_type", value:type);

      return NULL;
    }

    ##
    # Loops receiving and processing messages from the remote SSH server until KEX is complete
    # or an error occurs.
    #
    # @return [boolean] TRUE if the session is already past KEX or KEX completes, FALSE on error.
    ##
    public function complete_kex()
    {
      var fn = 'session.complete_kex';
      if(!cur_state.oneof(state_list:make_list("SOC_OPENED", "KEX_BEGIN")))
        return TRUE;

      dbg_log(src:fn, lvl:3, msg:"KEX is not yet complete. Attempting to complete KEX before continuing.");
      sshrecv_until(end_states:make_list("KEX_DONE", "SOC_CLOSED"));
      if(cur_state.val != "KEX_DONE")
      {
        if(cur_state.val != "SOC_CLOSED")
          return close_socket(error:"KEX failed: " + last_error);
        else
          return set_error(src:fn, err_msg:"KEX failed: " + last_error);
      }

      return TRUE;
    }

    ##
    # Logs a user into the remote host using the supplied SSH authentication method and extra data.
    #
    # @remark
    # If no authentication method is supplied, but data from a previous successful
    # authentication was stored in the KB the stored method and data will be used.
    #
    # @param [method:string] The authentication method: "none", "password", "keyboard-interactive", "gssapi", or "publickey".
    # @param [extra:array] A dictionary of data supporting the authentication method such as credentials, keys, etc.
    # @param [save_login:boolean] If TRUE the function will save login information in KB as preferred login info if login is successful.
    #
    # @param [force_none_auth:boolean] A flag to force a recheck of the supported auth methods
    #        if ``method`` is ``none`` (optional, defaults to FALSE).
    #
    # @param [cred_type:string] The credential type: "password", "public key", "certificate", "kerberos", or one of
    #        the password managers such as "Thycotic", "Centrify", etc.
    #
    # @remark
    # The argument ``force_none_auth`` is ignored if the ``none`` auth was already confirmed
    # or if the supported auth method is already set to ``unknown``.
    #
    # @return [boolean|NULL] Returns TRUE if the login succeeds, FALSE if it fails and NULL if an error occurs.
    #
    # @remark
    # To give more details on the return value:
    #
    # - If login succeeds, it returns the return value of `sshlib::session.save_login_info()`_.
    # - If login fails, depending on the given ``method`` it returns the return value of:
    #   * `sshlib::default_interactive_login_cb()`_ or the function reference given in ``extra['cb']`` for the ``keyboard-interactive`` method.
    #   * `sshlib::session.gssapi_login()`_ for the ``gssapi`` method.
    #   * `sshlib::session.publickey_login()`_ for the ``publickey`` method.
    #   * FALSE for the ``none`` and ``password`` methods.
    # - If any other error occurs, either NULL of the return value of `sshlib::session.set_error()`_ is returned.
    ##
    public function login(method, extra, save_login, force_none_auth, cred_type)
    {
      var ret_val;
      var fn = 'session.login';

      if(isnull(method))
      {
        method = get_kb_item(SSH_LIB_KB_PREFIX + get_kb_connection_id() + "/login_method");
        if(isnull(method))
          return set_error(src:fn, err_msg:"No login method specified.");

        # If we got "none" from the KB it means we already vetted it, force authentication
        if (method == 'none')
          force_none_auth = TRUE;

        extra = get_kb_args(kb_prefix:"Secret/" + SSH_LIB_KB_PREFIX + get_kb_connection_id() + "/login_extra");
      }

      var payload;
      if(cur_state.val == "SOC_CLOSED")
        return set_error(src:fn, err_msg:"SSH socket closed, unable to log in.");

      # If the session has just been opened, wait for KEX to complete
      if(!complete_kex())
        return NULL;

      if(!auth_method_supported(method:method, username:extra["username"]))
      {
        var err = "Remote server does not support the '"+method+"' authentication method for user '"+extra["username"]+"'. " +
                  "It supports : "+join(supported_auth_methods,sep:",")+".";
        return set_error(src:fn, err_msg:err);
      }

      if(method != "none" && cur_state.val != "USERAUTH_FAILURE" && cur_state.val != "USERAUTH_INFO_REQ")
      {
        sshsend(code:PROTO_SSH_MSG_SERVICE_REQUEST, data:mk_ssh_string("ssh-userauth"));
        sshrecv_until(end_states:make_list("SERVICE_REQUEST_SUCCESS", "SOC_CLOSED"));
        if(cur_state.val != "SERVICE_REQUEST_SUCCESS")
          return set_error(src:fn, err_msg:"Did not receive SERVICE_ACCEPT for ssh-userauth authentication.");
      }

      if(method == "password")
      {
        if(!isnull(extra["password"]))
          password = extra["password"];
        if(!isnull(extra["username"]))
          user = extra["username"];

        dbg_log(lvl:1, src:fn, msg:'Trying password authentication...');

        redact = TRUE;
        payload =
          mk_ssh_string(user) +
          mk_ssh_string("ssh-connection") +
          mk_ssh_string("password") +
          mkbyte(0) +
          mk_ssh_string(password);
        sshsend(data:payload, code:PROTO_SSH_MSG_USERAUTH_REQUEST);
        redact = FALSE;
        cur_state.set("USERAUTH_REQUEST");

        sshrecv_until(end_states:make_list("USERAUTH_SUCCESS", "USERAUTH_FAILURE", "SOC_CLOSED"));

        if(cur_state.val == "USERAUTH_SUCCESS")
          return save_login_info(method:method, extra:extra, save_login:save_login, cred_type:cred_type);

        set_auth_failure_error(user:user, port:this.port, msg:"Failed to authenticate using the supplied password.");
        return FALSE;
      }
      else if(method == "keyboard-interactive")
      {
        var custom_prompt;

        if(!isnull(extra["password"]))
          password = extra["password"];
        if(!isnull(extra["username"]))
          user = extra["username"];
        if(!isnull(extra["custom_prompt"]))
          custom_prompt = extra["custom_prompt"];
        if(!isnull(extra["cb"]))
          interactive_login_cb = extra["cb"];
        else
          interactive_login_cb = @default_interactive_login_cb;

        dbg_log(lvl:1, src:fn, msg:'Trying keyboard-interactive authentication...');

        ret_val = interactive_login_cb(session:this, username:user, password:password, custom_prompt:custom_prompt);

        if(ret_val)
          return save_login_info(method:method, extra:extra, save_login:save_login, cred_type:cred_type);
        else
          return ret_val;
      }
      else if(method == "gssapi")
      {
        if(!isnull(extra["password"]))
          password = extra["password"];
        if(!isnull(extra["username"]))
          user = extra["username"];
        if(!isnull(extra["realm"]))
          realm = extra["realm"];
        if(!isnull(extra["host"]))
          kerb_host = extra["host"];
        else
          kerb_host = this.remote_host;

        dbg_log(lvl:1, src:fn, msg:'Trying gssapi-with-mic authentication...');

        ret_val = gssapi_login(user:user, password:password, realm:realm, kerb_host:kerb_host);
        if(ret_val)
          return save_login_info(method:method, extra:extra, save_login:save_login, cred_type:cred_type);

        return ret_val;
      }
      else if (method == "publickey")
      {
        dbg_log(lvl:1, src:fn, msg:'Trying publickey authentication...');
        ret_val = publickey_login(auth_info:extra);
        if(ret_val)
          return save_login_info(method:method, extra:extra, save_login:save_login, cred_type:cred_type);

        return ret_val;
      }
      else if (method == "none")
      {
        if(!isnull(extra["username"]))
          user = extra["username"];

        # If state is already USERAUTH_SUCCESS and supported_auth_methods contains
        # the single entry "none", then we already know the "none" method is supported
        if(cur_state.val == "USERAUTH_SUCCESS" && max_index(supported_auth_methods) == 1 && supported_auth_methods[0] == "none")
          return save_login_info(method:method, extra:extra, save_login:save_login, cred_type:cred_type);

        # If supported_auth_methods contains the single entry "unknown", then we
        # already know the "none" method is not supported
        if(max_index(supported_auth_methods) == 1 && supported_auth_methods[0] == "unknown")
          return FALSE;

        # Otherwise, get_supported_auth_methods() will try the "none" authentication
        # and populate the supported_auth_methods list
        get_supported_auth_methods(username:user, force:force_none_auth);
        if(cur_state.val == "USERAUTH_SUCCESS" && max_index(supported_auth_methods) == 1 && supported_auth_methods[0] == "none")
          return save_login_info(method:method, extra:extra, save_login:save_login, cred_type:cred_type);
        else
          return FALSE;
      }
    }

    ##
    # GSSAPI login handler.
    #
    # @param [user:string] The user id.
    # @param [password:string] The password for the given user.
    # @param [realm:string] The Kerberos domain.
    # @param [kerb_host:string] The KDC target host.
    #
    # @return [boolean|NULL] Returns TRUE if the login succeeds, FALSE if it fails and
    #         the return value of `sshlib::session.set_auth_failure_error()`_ if an error occurs.
    ##
    function gssapi_login(user, password, realm, kerb_host)
    {
      var code, kerb_data, message, mic, oid, payload, seq;

      # Ask the server if it supports the specific authentication method
      # we're planning on attempting.
      payload =
        mk_ssh_string(user) +
        mk_ssh_string("ssh-connection") +
        mk_ssh_string("gssapi-with-mic") +
        mkdword(1, order:BYTE_ORDER_BIG_ENDIAN) +
        mk_ssh_string(der_encode_oid(oid:KERBEROS5_OID));
      sshsend(code:PROTO_SSH_MSG_USERAUTH_REQUEST, data:payload);

      cur_state.set("USERAUTH_GSSAPI_REQUEST");
      sshrecv_until(end_states:make_list("USERAUTH_GSSAPI_RESPONSE", "USERAUTH_FAILURE", "SOC_CLOSED"));

      if(cur_state.val != "USERAUTH_GSSAPI_RESPONSE")
        return set_auth_failure_error(user:user, port:this.port, msg:"Did not receive SSH_MSG_USERAUTH_GSSAPI_RESPONSE for gssapi-with-mic authentication.");

      # Ensure the selected method matches the one we sent.
      oid = der_parse_oid(oid:get_ssh_string(buffer:this.last_packet.payload, pos:0));
      if (isnull(oid))
        return set_auth_failure_error(user:user, port:this.port, msg:"Server did not select a mechanism OID for gssapi-with-mic authentication.");
      else if (oid != KERBEROS5_OID)
        return set_auth_failure_error(user:user, port:this.port, msg:"Server selected mechanism OID " + oid + " for gssapi-with-mic authentication.");

      # Send first authentication request
      seq = rand();
      kerb_data = kerberos_ssh(
        login    : user,
        password : password,
        realm    : realm,
        host     : kerb_host,
        seqnum   : seq
      );

      if (isnull(kerb_data))
        return set_auth_failure_error(user:user, port:this.port, msg:"Did not receive ticket from KDC for gssapi-with-mic authentication.");

      payload = mk_ssh_string(kerb_data[1]);
      sshsend(code:PROTO_SSH_MSG_USERAUTH_GSSAPI_TOKEN, data:payload);

      sshrecv_until(end_states:make_list("USERAUTH_GSSAPI_TOKEN", "SSH_MSG_USERAUTH_FAILURE", "SOC_CLOSED"));

      if(cur_state.val != "USERAUTH_GSSAPI_TOKEN")
        return set_auth_failure_error(user:user, port:this.port, msg:"Did not receive SSH_MSG_USERAUTH_GSSAPI_TOKEN for gssapi-with-mic authentication.");

      # Parse ticket from server's response.
      if (! check_gssapi_token(
              data      : get_ssh_string(buffer:this.last_packet.payload, pos:0),
              key       : kerb_data[0],
              realm     : realm,
              principal : user
            )
      )
        return set_auth_failure_error(user:user, port:this.port, msg:"Checking GSSAPI token failed.");

      # Send second authentication request.
      message =
        mk_ssh_string(this.kex_handler.id) +
        raw_string(0x32) +
        mk_ssh_string(user) +
        mk_ssh_string("ssh-connection") +
        mk_ssh_string("gssapi-with-mic");
      mic = gssapi_ssh_get_mic(data:message, key:kerb_data[0], seqnum:seq, enc_type:kerb_data[2]);
      payload = mk_ssh_string(mic);
      sshsend(code:PROTO_SSH_MSG_USERAUTH_GSSAPI_MIC, data:payload);

      sshrecv_until(end_states:make_list("USERAUTH_SUCCESS", "USERAUTH_FAILURE", "SOC_CLOSED"));

      if(cur_state.val == "USERAUTH_SUCCESS")
        return TRUE;

      set_auth_failure_error(user:user, port:this.port, msg:"GSSAPI authentication failed : credentials not accepted.");
      return FALSE;
    }

    ##
    # Handles keyboard-interactive auth as second factor for scanning
    # targets with MFA which has been disabled for the scanning account.
    #
    # @remark
    # MFA products such as Duo and Dell Defender still prompt for the
    # second factor, even though it's expected to be blank.
    #
    # @param [username:string] The username used for authentication.
    #
    # @return [boolean] TRUE if successful, FALSE otherwise.
    ##
    private function handle_disabled_mfa(username)
    {
      var pos, i, tmp, prompts;
      var fn = this.objname + FUNCTION_NAME;

      var payload =
        mk_ssh_string(username) +
        mk_ssh_string("ssh-connection") +
        mk_ssh_string("keyboard-interactive") +
        mk_ssh_string("en-US") +
        mk_ssh_string("");

      this.sshsend(data:payload, code:PROTO_SSH_MSG_USERAUTH_REQUEST);
      this.cur_state.set("USERAUTH_REQUEST");

      this.sshrecv_until(end_states:make_list("SOC_CLOSED", "USERAUTH_INFO_REQ", "USERAUTH_FAILURE", "USERAUTH_SUCCESS"));

      if (this.cur_state.val != "USERAUTH_INFO_REQ")
      {
        set_error(src:fn, err_msg:'The server did not reply with SSH_MSG_USERAUTH_INFO_REQUEST during keyboard-interactive exchange.');
        return FALSE;
      }

      payload = mkdword(0);
      this.sshsend(data:payload, code:PROTO_SSH_MSG_USERAUTH_INFO_RESPONSE);

      this.cur_state.set("USERAUTH_INFO_RES");
      this.sshrecv_until(end_states:make_list("SOC_CLOSED", "USERAUTH_INFO_REQ", "USERAUTH_FAILURE", "USERAUTH_SUCCESS"));

      if (this.cur_state.val == "USERAUTH_SUCCESS")
        return TRUE;

      set_error(src:fn, err_msg:'The remote server did not accept a zero-length SSH_MSG_USERAUTH_INFO_RESPONSE.');
      return FALSE;
    }

    ##
    # The public key authentication handler.
    #
    # @param [auth_info:array] Dictionary of data required for public key authentication.
    #
    # @return [boolean|NULL] Returns TRUE if the login succeeds, FALSE if it fails and
    #         the return value of `sshlib::session.set_auth_failure_error()`_ if an error occurs.
    #
    # @remark
    # The array given in ``auth_info`` must contain: ``username``, ``privatekey``, ``passphrase``, ``cert``.
    ##
    private function publickey_login(auth_info)
    {
      var key, payload, hash, signature, fail_msg, nid_value;
      var fn = this.objname + FUNCTION_NAME;

      if (!auth_info.privatekey || !auth_info.username)
        return set_auth_failure_error(user:NULL, port:this.port, msg:"Missing publickey authentication arguments.");
      else
        user = auth_info.username;
      # Check for private key format RSA1, which is only supported by SSHv1
      # This library only supports SSHv2
      if ('SSH PRIVATE KEY FILE FORMAT 1.1\n\0' >< auth_info.privatekey)
      {
        fail_msg = "The private key type is RSA1, which is only supported by SSHv1. This library only supports SSHv2.";
        return set_auth_failure_error(user:user, port:this.port, msg:fail_msg);
      }

      dbg_log(lvl:2, src:fn, msg:'Attempting to parse ssh keys...');

      key = parse_ssh_keys(
        privatekey:auth_info.privatekey,
        passphrase:auth_info.passphrase,
        cert:auth_info.cert
      );

      if (!key)
        return set_auth_failure_error(user:user, port:this.port, msg:"Failed to parse ssh keys.");

      key.label = key.type;
      if (key.label == "ssh-rsa" && get_rsa_connection_label())
      {
        if (defined_func('rsa_sign_ex'))
        {
          key.label = get_rsa_connection_label();
          dbg_log(lvl:3, src:fn, msg:'Attempting use of RSA algorithm ' + key.label);
        }
        else
        {
          dbg_log(lvl:1, src:fn, msg:'Function rsa_sign_ex() does not exist, defaulting to use of ssh-rsa alg and rsa_sign() function.');
        }
      }

      # Build base of payload
      payload =
        mk_ssh_string(user) +
        mk_ssh_string("ssh-connection") +
        mk_ssh_string("publickey") +
        mkbyte(1) +
        mk_ssh_string(key.label) +
        mk_ssh_string(key.pub);

      var to_hash = mk_ssh_string(this.kex_handler.id) +
                    mkbyte(PROTO_SSH_MSG_USERAUTH_REQUEST) +
                    payload;

      if(key.type !~ '^ecdsa')
      {
        nid_value = NID_SHA1;
        # Obtain signature
        if ("ssh-rsa" >< key.type || "sign-rsa" >< key.type)
        {
          if(key.label == "rsa-sha2-256")
          {
            hash = SHA256(to_hash);
            nid_value = NID_SHA256;
          }
          if(key.label == "rsa-sha2-512")
          {
            hash = SHA512(to_hash);
            nid_value = NID_SHA512;
          }
          if (defined_func('rsa_sign_ex'))
          {
            if(nid_value != NID_SHA256 && nid_value != NID_SHA512)
              hash = SHA1(to_hash);

            signature = rsa_sign_ex(
              e : key.e,
              n : key.n,
              d : key.priv,
              data : hash,
              options: {"type":nid_value}
            );
          }
          else
          {
            hash = SHA1(to_hash);
            signature = rsa_sign(
              e : key.e,
              n : key.n,
              d : key.priv,
              data : hash
            );
          }
        }
        else if ("ssh-dss" >< key.type)
        {
          hash = SHA1(to_hash);
          signature = dsa_do_sign(
            p    : key.p,
            q    : key.q,
            g    : key.g,
            pub  : key.y,
            priv : key.priv,
            data : hash
          );
        }
        else if ("ssh-ed25519" >< key.type)
        {
          signature = ed25519_sign(
            priv : key.priv,
            data : to_hash
          );
        }
        else
        {
          fail_msg = "Invalid key type. Could not create signature with given information.";
          return set_auth_failure_error(user:user, port:this.port, msg:fail_msg);
        }

        if (!signature)
          return set_auth_failure_error(user:user, port:this.port, msg:"Failed to create signature.");

        # Finalize payload
        if (key.type == "ssh-rsa")
          signature = mk_ssh_string(key.label) + mk_ssh_string(signature);
        else
          signature = mk_ssh_string(key.alg) + mk_ssh_string(signature);

        payload += mk_ssh_string(signature);
      }
      else
      {
        if(key.alg == "ecdsa-sha2-nistp256")
          hash = SHA256(to_hash);
        else if(key.alg == "ecdsa-sha2-nistp384")
          hash = SHA384(to_hash);
        else if(key.alg == "ecdsa-sha2-nistp521")
          hash = SHA512(to_hash);
        else
          return set_auth_failure_error(user:user, port:this.port, msg:"Unknown ECDSA key algorithm: " + key.type);

        signature = ecdsa_sign(
            priv   : key.priv,
            nid    : key.nid,
            digest : hash
        );

        if(isnull(signature))
          return set_auth_failure_error(user:user, port:this.port, msg:"Failed to compute ECDSA signature.");

        payload += mk_ssh_string(mk_ssh_string(key.alg) + mk_ssh_string(signature));
      }

      dbg_log(lvl:2, src:fn, msg:'Sending publickey authentication payload...');
      sshsend(data:payload, code:PROTO_SSH_MSG_USERAUTH_REQUEST);
      cur_state.set("USERAUTH_REQUEST");

      sshrecv_until(end_states:make_list("USERAUTH_SUCCESS", "USERAUTH_FAILURE", "SOC_CLOSED"));

      # Default failure message, more details may be appended
      fail_msg = 'Failed to authenticate using publickey authentication.';

      # Support for scanning targets with MFA which has been disabled for
      # the scanning account. MFA products such as Duo and Dell Defender
      # still prompt for the second factor, even though it's expected
      # to be blank.
      if (
        cur_state.val == "USERAUTH_FAILURE" &&
        get_ssh_string(buffer:last_packet.payload, pos:0) == 'keyboard-interactive'
      )
      {
        dbg_log(lvl:2, src:fn, msg:
          'The remote server prompted for a second "keyboard-interactive" authentication factor.\n' +
          'This behavior is supported if multi-factor authentication (MFA) has been disabled for the scanning account.\n' +
          'Attempting empty "keyboard-interactive" authentication.');
        if (!this.handle_disabled_mfa(username:user))
          fail_msg +=
            '\nThe remote server prompted for a second "keyboard-interactive" authentication factor, which failed for the following reason :\n' +
            last_error +
            '\nNote that multi-factor authentication is not supported and must be disabled for the scanning account.';
      }

      if(cur_state.val == "USERAUTH_SUCCESS")
        return TRUE;

      set_auth_failure_error(user:user, port:this.port, msg:fail_msg);
      return FALSE;
    }

    ##
    # Parses an SSH key and returns the key cryptographic parameters.
    #
    # @param [privatekey:string] The private key to parse.
    # @param [passphrase:string] Passphrase for passphrase protected keys.
    # @param [cert:string] An optional digital certificate for public key parameters.
    #
    # @return [array|NULL] Returns crytographic parameters for the supplied private key or NULL if an error happens.
    #
    # @remark
    # The structure of the returned array will depend on the alg used to derive the key.
    ##
    private function parse_ssh_keys(privatekey, passphrase, cert)
    {
      var openssh_key, rsa_key, dsa_key, ecdsa_key, ed25519_key;
      var key = {};

      if('OPENSSH PRIVATE KEY' >< privatekey)
      {
        openssh_key = openssh_to_key(priv:privatekey, passphrase:passphrase, session:this);
        if(!isnull(openssh_key))
        {
          if("ecdsa-sha2-nistp" >< openssh_key.type)
            ecdsa_key = openssh_key;
          else if(openssh_key.type == "ssh-ed25519")
            ed25519_key = openssh_key;
          else if(openssh_key.type == "ssh-rsa")
            rsa_key = openssh_key;
          else if(openssh_key.type == "ssh-dss")
            dsa_key = openssh_key;
          else
            return set_auth_failure_error(user:user, port:this.port, msg:"Unknown type of OpenSSH key provided.");
        }
      }

      if (isnull(cert))
      {
        if(empty_or_null(ed25519_key) && empty_or_null(rsa_key) && empty_or_null(ecdsa_key) && empty_or_null(dsa_key))
          rsa_key = pem_to_rsa2(priv:privatekey, passphrase:passphrase);

        if(empty_or_null(ed25519_key) && empty_or_null(rsa_key) && empty_or_null(ecdsa_key) && empty_or_null(dsa_key))
          ecdsa_key = pem_to_ecdsa(priv:privatekey, passphrase:passphrase, session:this);

        if(empty_or_null(ed25519_key) && empty_or_null(rsa_key) && empty_or_null(ecdsa_key) && empty_or_null(dsa_key))
          dsa_key = pem_to_dsa2(priv:privatekey, passphrase:passphrase);

        if (!isnull(rsa_key))
        {
          key.e = normalize_mpint(rsa_key.e);
          key.n = normalize_mpint(rsa_key.n);
          key.priv = rsa_key.d;
          key.type = "ssh-rsa";
          key.alg = "ssh-rsa";
          key.pub =
            mk_ssh_string('ssh-rsa') +
            mk_ssh_mpint(key.e) +
            mk_ssh_mpint(key.n);
        }

        if(!isnull(dsa_key))
        {
          key.p = normalize_mpint(dsa_key.p);
          key.q = normalize_mpint(dsa_key.q);
          key.g = normalize_mpint(dsa_key.g);
          key.y = normalize_mpint(dsa_key.pub_key);
          key.priv = dsa_key.priv_key;
          key.type = "ssh-dss";
          key.alg = "ssh-dss";
          key.pub =
            mk_ssh_string("ssh-dss") +
            mk_ssh_mpint(key.p) +
            mk_ssh_mpint(key.q) +
            mk_ssh_mpint(key.g) +
            mk_ssh_mpint(key.y);
        }

        if(!isnull(ecdsa_key))
          key = ecdsa_key;

        if(!isnull(ed25519_key))
          key = ed25519_key;

        if (empty_or_null(key))
          return set_auth_failure_error(user:user, port:this.port, msg:"Failed to parse the given key information.");
      }
      else
      {
        var priv_params;
        key = parse_public_key_only(pub:cert);

        if(isnull(key))
          return set_auth_failure_error(user:user, port:this.port, msg:"Failed to parse the given certificate information.");

        if('OPENSSH PRIVATE KEY' >< privatekey)
        {
          if("ssh-rsa" >< key.type)
            key.priv = rsa_key.d;
          else if("ssh-dss" >< key.type)
            key.priv = dsa_key.priv_key;
          else if("ecdsa" >< key.type)
          {
            key.priv = ecdsa_key.priv;
            key.nid = ecdsa_key.nid;
          }
          else if("sign-rsa" >< key.type)
          {
            key.e = rsa_key.e;
            key.n = rsa_key.n;
            key.priv = rsa_key.d;
          }
          else if("ssh-ed25519" >< key.type)
          {
            key.priv = ed25519_key.priv;
          }
        }
        else
        {
          if("ssh-rsa" >< key.type)
            key.priv = pem_to_rsa(priv:privatekey, passphrase:passphrase);
          else if("ssh-dss" >< key.type)
            key.priv = pem_to_dsa(priv:privatekey, passphrase:passphrase);
          else if("ecdsa" >< key.type)
          {
            priv_params = pem_to_ecdsa(priv:privatekey, passphrase:passphrase, session:this);
            key.priv = priv_params.priv;
            key.nid = priv_params.nid;
          }
          else if("sign-rsa" >< key.type)
          {
            var tmp_rsa_key = pem_to_rsa2(priv:privatekey, passphrase:passphrase);
            key.e = tmp_rsa_key["e"];
            key.n = tmp_rsa_key["n"];
            key.priv = tmp_rsa_key["d"];
          }
        }
      }

      if (!key.priv)
        return set_auth_failure_error(user:user, port:this.port, msg:"Failed to get private key information.");

      return key;
    }

    ##
    # Parses a public key or certificate and returns the associated cryptographic parameters.
    #
    # @param [pub:string] A public key or certificate.
    #
    # @return [array|NULL] A dictionary of the key parameters or the return value of
    #         `sshlib::session.set_auth_failure_error()`_ or `sshlib::session.set_error()`_ if an error occurs.
    #
    # @remark
    # The structure of the returned array will depend on the alg used to derive the key.
    ##
    public function parse_public_key_only(pub)
    {
      var blob, errmsg, line, lines, next, nonce, tmp;
      var key = {};
      var fn = this.objname + FUNCTION_NAME;

      # SSH Public Key File Format
      if ("---" >< pub)
      {
        blob = '';
        lines = split(pub, sep:'\n');

        foreach line (lines)
        {
          if ("---" >< line || ':' >< line) continue;
          if ('\r' >< line) line -= '\r';

          blob += line;
        }
      }
      # OpenSSH Public Key File Format
      else
      {
        blob = ereg_replace(pattern:"[^ ]* ([^ ]*)( .*)?$", string:chomp(pub), replace:"\1");
      }

      # Convert to workable encoding
      if (strlen(blob))
        blob = base64_decode(str:blob);
      if (strlen(blob) == 0)
        return set_auth_failure_error(user:user, port:this.port, msg:"Failed to parse the given certificate.");

      # Start adding key data
      key.pub = blob;

      if(pub =~ "^x509v3-sign-rsa")
        key.type = "x509v3-sign-rsa";
      else
      {
        key.type = get_ssh_string(buffer:blob, pos:0);
        next = 4 + strlen(key.type);
      }

      # Skip nonce field
      # if v00, not necessary, the nonce is after relevant data
      # if v01, nonce immediately follows the key type
      if (
        key.type !~ "-cert-v00@openssh.com$" &&
        (
          key.type == 'ssh-rsa-cert-v01@openssh.com' ||
          key.type == 'ssh-dss-cert-v01@openssh.com' ||
          key.type == 'ecdsa-sha2-nistp256-cert-v01@openssh.com' ||
          key.type == 'ecdsa-sha2-nistp384-cert-v01@openssh.com' ||
          key.type == 'ecdsa-sha2-nistp521-cert-v01@openssh.com' ||
          key.type == 'ssh-ed25519-cert-v01@openssh.com'
        )
      )
      {
        nonce = get_ssh_string(buffer:blob, pos:next);
        next += 4 + strlen(nonce);
      }
      # Set remaining key data
      if ("ssh-rsa" >< key.type)
      {
        key.alg = "ssh-rsa";

        tmp = get_ssh_mpint(buffer:blob, pos:next);
        if(isnull(tmp))
        {
          return set_error(src:fn, err_msg:'Could not get ssh-rsa key e value.');
        }
        key.e = tmp['value'];
        next += int(tmp['length']);

        tmp = get_ssh_mpint(buffer:blob, pos:next);
        if(isnull(tmp))
        {
          return set_error(src:fn, err_msg:'Could not get ssh-rsa key n value.');
        }
        key.n = tmp['value'];
        next += int(tmp['length']);
      }
      else if ("ssh-dss" >< key.type)
      {
        key.alg = "ssh-dss";

        tmp = get_ssh_mpint(buffer:blob, pos:next);
        if(isnull(tmp))
        {
          return set_error(src:fn, err_msg:'Could not get ssh-dss key p value.');
        }
        key.p = tmp['value'];
        next += int(tmp['length']);

        tmp = get_ssh_mpint(buffer:blob, pos:next);
        if(isnull(tmp))
        {
          return set_error(src:fn, err_msg:'Could not get ssh-dss key q value.');
        }
        key.q = tmp['value'];
        next += int(tmp['length']);

        tmp = get_ssh_mpint(buffer:blob, pos:next);
        if(isnull(tmp))
        {
          return set_error(src:fn, err_msg:'Could not get ssh-dss key g value.');
        }
        key.g = tmp['value'];
        next += int(tmp['length']);

        tmp = get_ssh_mpint(buffer:blob, pos:next);
        if(isnull(tmp))
        {
          return set_error(src:fn, err_msg:'Could not get ssh-dss key g value.');
        }
        key.y = tmp['value'];
      }
      else if("x509v3-sign-rsa" >< key.type)
      {
        key.alg = "x509v3-sign-rsa";
      }
      else if("ecdsa" >< key.type)
      {
        key.alg = ereg_replace(string:key.type, pattern: "(ecdsa-.*)-cert-.*@openssh.com", replace: "\1");
      }
      else if("ed25519" >< key.type)
      {
        key.alg = "ssh-ed25519";
      }
      else
      {
        errmsg = "Invalid or unsupported certificate";
        if (key.type =~ "^[A-Za-z0-9-@.]+$")
          errmsg += " with a key type of " + key.type;
        return set_auth_failure_error(user:user, port:this.port, msg:errmsg + '.');
      }

      return key;
    }

    ##
    # Retrieves a list of supported authentication methods from the remote server.
    #
    # @param [username:string] The user name for which to gather possible auth methods.
    # @param [force:boolean] A flag to force re-checking supported auth methods even if
    #        they were already gathered (optional, defaults to FALSE).
    #
    # @return [boolean|NULL] TRUE if the function succeeds or the return
    #         value of `sshlib::session.set_error()`_ if there was an error.
    #
    # @remark
    # This function works by first requesting the authentication service with a ``SSH_MSG_SERVICE_REQUEST``.
    # If the request succeeds the function will attempt a "none" authentication
    # for the supplied user (may also try without a user if none was supplied).
    #
    # If the "none" method fails then the function will gather the list of supported
    # auth methods and store them in the KB as a comma-separated list.
    ##
    public function get_supported_auth_methods(username, force)
    {
      var payload, supported_auth, user_supported_auth_methods, err;
      var fn = this.objname + FUNCTION_NAME;

      dbg_log(src:fn, msg:"Entering get_supported_auth_methods()");

      # If a username wasn't passed, try to set it using the 'user'
      # global var that may have already been set
      # If 'user' is still empty, the server will still return a
      # list of supported auth methods, but subsequent login attempts
      # in the same session will fail if the username is different
      # than what is set here
      if(!username)
      {
        dbg_log(src:fn, msg:'No username passed, using username "'+user+'".');
        username = user;
      }

      # If we already have the list of supported_auth_methods, return
      user_supported_auth_methods = get_kb_item(SSH_LIB_KB_PREFIX + get_kb_connection_id() + "/"+username+"/supported_login_methods");
      if(!isnull(user_supported_auth_methods) && !force)
      {
        supported_auth_methods = split(user_supported_auth_methods, sep:",", keep:FALSE);
        dbg_log(
          src:fn,
          msg:'This function has already run and set the supported_auth_methods for user "'+username+'".',
          msg_details:
            {"Supported auth methods":{"lvl":3, "value":serialize(supported_auth_methods)}});
        return TRUE;
      }

      if(cur_state.val == "SOC_CLOSED")
        return set_error(src:fn, err_msg:"SSH socket closed, unable to log in.");

      # If the session has just been opened, wait for KEX to complete
      if(!complete_kex())
        return NULL;

      # Request ssh-userauth service
      sshsend(code:PROTO_SSH_MSG_SERVICE_REQUEST, data:mk_ssh_string("ssh-userauth"));

      sshrecv_until(end_states:make_list("SERVICE_REQUEST_SUCCESS", "SOC_CLOSED"));

      if(cur_state.val != "SERVICE_REQUEST_SUCCESS")
        return set_error(src:fn, err_msg:"Did not receive SERVICE_REQUEST_SUCCESS for ssh-userauth service request.");

      # Request 'none' authentication method
      payload =
        mk_ssh_string(username) +
        mk_ssh_string("ssh-connection") +
        mk_ssh_string("none");
      sshsend(code:PROTO_SSH_MSG_USERAUTH_REQUEST, data:payload);
      cur_state.set("USERAUTH_REQUEST");

      sshrecv_until(end_states:make_list("USERAUTH_SUCCESS", "USERAUTH_FAILURE", "SOC_CLOSED"));

      # If the 'none' authentication method was accepted, we expect
      # SSH_MSG_USERAUTH_SUCCESS
      # The server sends only the code with no list of authentications
      # that can continue
      if(cur_state.val == "USERAUTH_SUCCESS")
      {
        supported_auth = get_ssh_string(buffer:last_packet.payload, pos:0);
        if (isnull(supported_auth))
        {
          supported_auth_methods[0] = "none";
          replace_kb_item(name:SSH_LIB_KB_PREFIX + get_kb_connection_id() + "/"+username+"/supported_login_methods", value:"none");
          return TRUE;
        }
        else
        {
          err = "Server accepted the 'none' authentication method but there was "+
                "an unexpected value for authentications that can continue: " + supported_auth;
          return set_error(src:fn, err_msg:err);
        }
      }

      # Unexpected code; we expect either SSH_MSG_USERAUTH_SUCCESS or
      # SSH_MSG_USERAUTH_FAILURE
      if(cur_state.val != "USERAUTH_FAILURE")
      {
        err = "Server did not accept or reject the 'none' authentication method. Received code was : " + last_packet.type + ".";
        return set_error(src:fn, err_msg:err);
      }

      # If we got this far, the 'none' authentication method was
      # rejected with SSH_MSG_USERAUTH_FAILURE
      # The server MAY have included a list of supported auth methods
      # that can continue in the response
      supported_auth = get_ssh_string(buffer:last_packet.payload, pos:0);
      if(empty_or_null(supported_auth))
      {
        supported_auth_methods[0] = "unknown";
        replace_kb_item(name:SSH_LIB_KB_PREFIX + get_kb_connection_id() + "/"+username+"/supported_login_methods", value:"unknown");

        err = "Server rejected the 'none' authentication method but did not provide a list of authentications that can continue.";
        return set_error(src:fn, err_msg:err);
      }

      # Split the list of auth methods and store in the supported_auth_methods list
      # The empty_or_null() check above should ensure there is at least one list item,
      # so the else here is just a failsafe
      supported_auth_methods = split(supported_auth, sep:',', keep:FALSE);
      if(max_index(supported_auth_methods) > 0)
      {
        replace_kb_item(name:SSH_LIB_KB_PREFIX + get_kb_connection_id() + "/"+username+"/supported_login_methods", value:supported_auth);
        dbg_log(
          src:fn,
          msg:'Server returned supported auth methods for user "'+username+'".',
          msg_details:
            {"Supported auth methods":{"lvl":3, "value":serialize(supported_auth_methods)}});
        return TRUE;
      }
      else
      {
        err = "Unable to parse authentication methods from authentications that can continue: " + supported_auth;
        return set_error(src:fn, err_msg:err);
      }
    }


    ##
    # Checks if a given authentication method is supported for a given user on the remote system.
    #
    # @param [method:string] The authentication method: "none", "password", "keyboard-interactive", "gssapi", or "publickey".
    # @param [username:string] The username for which the auth method should be checked.
    #
    # @return [boolean] TRUE if the authentication method is supported, FALSE if it isn't.
    #
    # @remark
    # This function will always call `sshlib::session.get_supported_auth_methods()`_ **without** forcing a re-check.
    ##
    public function auth_method_supported(method, username)
    {
      var supported_auth_method;
      var fn = this.objname + FUNCTION_NAME;

      # This will set global supported_auth_methods to the values for the
      # specified user
      if(!get_supported_auth_methods(username:username) || supported_auth_methods[0] == "unknown" || supported_auth_methods[0] == "none")
      {
        dbg_log(lvl:1, src:fn, msg:'Unable to determine supported authentication methods.');
        return TRUE;
      }

      foreach supported_auth_method (supported_auth_methods)
      {
        if (method >< supported_auth_method)
        {
          dbg_log(src:fn, msg:'The authentication method "'+method+'" is supported.');
          return TRUE;
        }
      }
      dbg_log(lvl:1, src:fn, msg:'The authentication method "'+method+'" is not supported.');
      return FALSE;
    }


    ##
    # Handles an error on the current SSH socket by retrieving the error code,
    # crafting and logging a message for the error and closing the socket.
    #
    # @return [integer|NULL] Returns ``NOERR`` (a Nessus built-in that equals 0) if there is no error,
    #         the return value of `sshlib::session.set_error()`_ otherwise.
    ##
    function handle_socket_error()
    {
      var socket_error, socket_error_message;
      var fn = 'session.handle_socket_error';

      if(cur_state.val == "SOC_CLOSED")
      {
        dbg::detailed_log(lvl:1, src:fn, msg:"Socket has already been closed.");
        return NULL;
      }

      if(TAP_MODE)
        socket_error = tap_mode_get_socket_error(socket);
      else
        socket_error = socket_get_error(socket);
      socket_error_message = "Socket error: ";

      switch(socket_error)
      {
        case NOERR:
          return NOERR;
          break;
        case ETIMEDOUT:
          return set_error(src:fn, err_msg:"Connection timed out (probably ok)");
          break;
        case ECONNRESET:
          socket_error_message += "Connection reset by peer";
          break;
        case EUNREACH:
          socket_error_message += "Host or network unreachable";
          break;
        case ESSL:
          socket_error_message += "No such device";
          break;
        case EINPROGRESS:
          socket_error_message += "Operation in progress";
          break;
        case ECONNREFUSED:
          socket_error_message += "Connection refused";
          break;
        case ENOBUFS:
          socket_error_message += "No buffer space available";
          break;
        case EACCES:
          socket_error_message += "Permission denied";
          break;
        case EUNKNOWN:
        default:
          socket_error_message += "Unknown error";
          break;
      }

      # Call close_socket() so that objects are properly cleaned up
      close_socket();
      return set_error(src:fn, err_msg:socket_error_message);
    }


    ##
    # Provides access to private functions for unit testing.
    #
    # @param [name:string] Name of a private function to call
    # @param [args:array] A dictionary of arguments names and values for the private function to test.
    #
    # @return [any] The return value of the private function being tested or NULL if an error happens.
    ##
    public function test_private_function(name, args)
    {
      var fn = 'test_private_function';

      if(empty_or_null(name))
      {
        dbg::detailed_log(lvl:1, src:fn, msg:"Missing 'name' argument");
        return NULL;
      }

      switch (name)
      {
        case "parse_ssh_keys":
          return parse_ssh_keys(
            privatekey : args['privatekey'],
            passphrase : args['passphrase'],
            cert       : args['cert']
          );
        default:
          dbg::detailed_log(lvl:1, src:fn, msg:"'name' argument '"+name+"' has not been implemented for testing with this function.");
          return NULL;
      }
    }

    ##
    # Sets the post login error flag.
    ##
    public function found_post_login_error()
    {
      post_login_error = TRUE;
      return NULL;
    }

    ##
    # Clears the post login error flag.
    ##
    public function clear_post_login_error()
    {
      post_login_error = FALSE;
      return NULL;
    }

    ##
    # Gets the RSA connection label value for the session.
    #
    # @remark
    # This is used for RSA type public keys, which may need specific values such as
    # ssh-rsa, rsa-sha2-256, and rsa-sha2-512
    #
    # @return [string] The RSA connection label.
    ##
    public function get_rsa_connection_label()
    {
      return this.rsa_connection_label;
    }

    ##
    # Sets the RSA connection label for the session.
    #
    # @remark
    # This is used for RSA type public keys, which may need specific values such as
    # ssh-rsa, rsa-sha2-256, and rsa-sha2-512
    #
    # @anonparam [rsa_connection_label:string] Label to use during rsa key connections.
    ##
    public function set_rsa_connection_label()
    {
      this.rsa_connection_label = _FCT_ANON_ARGS[0];
      return NULL;
    }
  }

  ##
  # Determines whether the supplied public key will be accepted by the remote SSH server by
  # attempting to authenticate the supplied user using the key.
  #
  # @param [login:string] The user name to use to auth.
  # @param [pub:string] A public key to test.
  # @param [session:object] The ``sshlib::session`` object to use to connect.
  #
  # @return [boolean|NULL] Returns TRUE if the server will accept the key,
  #         NULL or the return value of `sshlib::session.set_error()`_ if an error occurred.
  ##
  function ssh_public_key_accepted(login, pub, &session)
  {
    var payload;

    var key = session.parse_public_key_only(pub:pub);
    if(!key)
      return session.set_error(src:FUNCTION_NAME, err_msg:"Unable to parse public key.");

    # If the session has just been opened, wait for KEX to complete
    if(!session.complete_kex())
      return NULL;

    # Request service
    session.sshsend(code:PROTO_SSH_MSG_SERVICE_REQUEST, data:mk_ssh_string("ssh-userauth"));
    session.sshrecv_until(end_states:make_list("SERVICE_REQUEST_SUCCESS", "SOC_CLOSED"));
    if(session.cur_state.val != "SERVICE_REQUEST_SUCCESS")
      return session.set_error(src:FUNCTION_NAME, err_msg:"Did not receive SERVICE_ACCEPT for ssh-userauth authentication.");

    key.label = key.type;
    if (key.label == "ssh-rsa" && session.get_rsa_connection_label())
    {
      if (defined_func('rsa_sign_ex'))
      {
        key.label = session.get_rsa_connection_label();
      }
      else
      {
        dbg::detailed_log(lvl:1, src:FUNCTION_NAME, msg:'Function rsa_sign_ex() does not exist, defaulting to use of ssh-rsa alg.');
      }
    }
    # Create connection request with public key only
    payload =
      mk_ssh_string(login) +
      mk_ssh_string("ssh-connection") +
      mk_ssh_string("publickey") +
      mkbyte(0) +
      mk_ssh_string(key.label) +
      mk_ssh_string(key.pub);

    session.sshsend(code:PROTO_SSH_MSG_USERAUTH_REQUEST, data:payload);
    session.cur_state.set("USERAUTH_PK_REQUEST");
    session.sshrecv_until(end_states:make_list("SOC_CLOSED", "USERAUTH_INFO_REQ", "USERAUTH_FAILURE", "USERAUTH_PK_OK"));

    if (session.last_packet.type != PROTO_SSH_MSG_USERAUTH_PK_OK)
      return session.set_error(src:FUNCTION_NAME, err_msg:"Server did not reply with SSH_MSG_USERAUTH_PK_OK.");
    else
      return TRUE;
  }


  ##
  # Parses the keyboard-interactive login instruction and prompts from the ``USERAUTH_INFO_REQUEST`` packet.
  #
  # @param [payload:data] Payload of the packet to parse.
  #
  # @return [array] Instruction and prompts parsed from ``USERAUTH_INFO_REQUEST`` packet.
  ##
  function interactive_login_parse_userauth_info_request(payload)
  {
    var pos = 0;

    # name
    var name = get_ssh_string(buffer:payload, pos:pos);
    pos += 4 + strlen(name);

    # instruction
    var inst = get_ssh_string(buffer:payload, pos:pos);
    pos += 4 + strlen(inst);

    # language
    var language = get_ssh_string(buffer:payload, pos:pos);
    pos += 4 + strlen(language);

    # Parse number of prompts.
    var num_prompts = getdword(blob:payload, pos:pos, order:BYTE_ORDER_BIG_ENDIAN);
    pos += 4;

    if (num_prompts == 0) return { name:name, instruction:inst, language:language, prompts:[] };

    var prompts = [];
    for (var i = 0; i < num_prompts; i++)
    {
      prompts[i] = get_ssh_string(buffer:payload, pos:pos);
      pos += 4 + strlen(prompts[i]) + 1; # 4-byte string length + prompt + 1-byte boolean for echo
    }

    return { name:name, instruction:inst, language:language, prompts:prompts };
  }

  ##
  # Checks a keyboard-interactive login prompt for known disclaimers that must be accepted before authentication.
  #
  # @param [prompt:string] The keyboard-interactive prompt string to check.
  #
  # @return [string|NULL] Expected response for disclaimer if found, NULL otherwise.
  ##
  function interactive_login_get_disclaimer_response(prompt)
  {
    # Define supported disclaimer prompts and expected responses
    var prompts_and_responses = [
      {
        type     : "general",
        prompt   : "\(?[yY]/[nN]\)?\??\s*$",
        compare  : "=~",
        response : "y"
      },
      {
        type     : "PAN-OS",
        prompt   : "Do you accept and acknowledge the statement above ? (yes/no) : ",
        compare  : "==",
        response : "yes"
      }
    ];

    var match, data;
    foreach var set (prompts_and_responses)
    {
      switch (set.compare)
      {
        case "==":
          match = (prompt == set.prompt);
          break;
        case "=~":
          match = (prompt =~ set.prompt);
          break;
        default:
          match = FALSE;
          err_print('API error in function sshlib::interactive_login_handle_disclaimer() - ',
            'invalid set.compare value "' + set.compare + '"');
      }
      if (match)
      {
        dbg::detailed_log(lvl:2, src:FUNCTION_NAME, msg:'Found keyboard-interactive prompt matching disclaimer type : ' + set.type);
        replace_kb_item(name:SSH_LIB_KB_PREFIX + 'login_disclaimer/' + set.type, value:TRUE);
        return set.response;
      }
    }
    return NULL;
  }


  ##
  # Checks a keyboard-interactive login prompt and instruction string for known password prompts.
  #
  # @param [prompt:string]         The keyboard-interactive prompt string from the userauth info request packet.
  # @param [instruction:string]    The instruction string from the userauth info request packet
  # @param [username:string]       The name of the login account
  # @param [custom_prompt:string]  A custom password prompt string to add to the list of known password prompts
  #
  # @return [bool] TRUE if a password prompt is found, FALSE otherwise.
  ##
  function interactive_login_password_prompt_found(prompt, instruction, username, custom_prompt)
  {
    var test_prompts = make_list(
      # Strange prompts
      'Enter PASSCODE:',
      "Password for "+username+"@",
      'Enter password for '+username+':',
      'Please Enter Authentication Password',
      'Passcode:',
      # Language variants of "password:" we should add more here in the future
      # this is the most common
      'password:',
      'contrase'+'\xc3\xb1'+'a:', # Spanish UTF-8 for password
      'contrase'+'\x11'+'a:' # Spanish ISO-8859-1 for password
    );

    if(!empty_or_null(custom_prompt))
    {
      dbg::detailed_log(lvl:2, src:FUNCTION_NAME, msg:
        'Adding the custom value: "' + custom_prompt + '" to the list of recognized password prompts.\n');
      append_element(var:test_prompts, value:custom_prompt);
    }

    foreach var test_prompt (test_prompts)
    {
      if (tolower(test_prompt) >< tolower(prompt))
        return TRUE;
    }
    if (prompt == " " && "'s password for keyboard-interactive method:" >< instruction)
      return TRUE;

    return FALSE;
  }


  ##
  # Default generic interactive login handler, designed to handle interactive
  # authentication that prompts for passwords on most devices.
  #
  # @param [session:object] The ``sshlib::session`` object to use.
  # @param [username:string] The user name to use to auth.
  # @param [password:string] The password to send aafter the login prompt.
  # @param [custom_prompt:string] A non-standard password prompt supplied by the credential. (optional)
  #
  # @return [boolean|NULL] Returns TRUE if login succeeds, FALSE if it fails
  #         and the return value of `sshlib::session.set_auth_failure_error()`_ if an error happens.
  ##
  function default_interactive_login_cb(session, username, password, custom_prompt)
  {
    var type_label, prompts, prompt, max_requests, request_num, disclaimer_response, send_data, parsed_info_req, msg;
    var err;

    # Maximum number of SSH_MSG_USERAUTH_INFO_REQUEST packets to handle to avoid an infinite loop
    max_requests = 5;

    # Initiate keyboard-interactive authentication
    send_data =
        mk_ssh_string(username) +
        mk_ssh_string("ssh-connection") +
        mk_ssh_string("keyboard-interactive") +
        mk_ssh_string("en-US") +
        mk_ssh_string("");

    session.sshsend(data:send_data, code:PROTO_SSH_MSG_USERAUTH_REQUEST);
    session.cur_state.set("USERAUTH_REQUEST");

    session.sshrecv_until(end_states:make_list("SOC_CLOSED", "USERAUTH_INFO_REQ", "USERAUTH_FAILURE", "USERAUTH_SUCCESS"));

    # Handle up to <max_requests> SSH_MSG_USERAUTH_INFO_REQUEST packets
    # Check for known disclaimers and automatically accept them if scan policy allows
    # Look for known password prompts and break when one is found
    var found_password_prompt = FALSE;
    for (request_num = 0; request_num < max_requests; request_num++)
    {
      # Check session state before proceeding
      if (session.cur_state.val == "SOC_CLOSED")
      {
        err = 'Connection was closed during keyboard-interactive authentication. Last error :\n' + last_error;
        return session.set_auth_failure_error(user:username, port:session.get_port(), msg:err);
      }

      # If an empty password was provided and we received PROTO_SSH_MSG_USERAUTH_SUCCESS
      # without sending a password, return TRUE
      if (
        session.cur_state.val == "USERAUTH_SUCCESS" &&
        ((!isnull(password) && strlen(password) == 0) || isnull(password))
      )
        return TRUE;

      # Return an authentication failure if the expected state wasn't achieved
      if (session.cur_state.val != "USERAUTH_INFO_REQ")
      {
        err = "Server did not reply with SSH_MSG_USERAUTH_INFO_REQUEST during keyboard-interactive exchange.";
        return session.set_auth_failure_error(user:username, port:session.get_port(), msg:err);
      }

      # Process the info request from the server
      dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:
        'Processing SSH_MSG_USERAUTH_INFO_REQUEST ' + request_num + '/' + max_requests + ' (max)');

      parsed_info_req = interactive_login_parse_userauth_info_request(payload:session.last_packet.payload);

      dbg::detailed_log(
        lvl:3,
        src:FUNCTION_NAME,
        msg:'Parsed USERAUTH_INFO_REQUEST packet',
        msg_details:{'Info':{'lvl':3, 'value':parsed_info_req}});

      if (len(parsed_info_req.prompts) <= 0)
      {
        err = "Remote server sent SSH_MSG_USERAUTH_INFO_REQUEST with no prompts during keyboard-interactive authentication.";
        return session.set_auth_failure_error(user:username, port:session.get_port(), msg:err);
      }

      # We currently only handle one prompt at a time. This isn't RFC compliant and should be updated.
      prompt = parsed_info_req.prompts[0];
      dbg::detailed_log(
        lvl:3,
        src:FUNCTION_NAME,
        msg:'Keyboard-interactive login prompt.',
        msg_details:{'Prompt':{'lvl':3, 'value':prompt}});

      # Check for a known disclaimer prompt that must be accepted before interactive authentication and handle it as
      # configured in the scan policy
      disclaimer_response = interactive_login_get_disclaimer_response(prompt:prompt);
      if (disclaimer_response)
      {
        # If scan policy allows, accept the disclaimer
        if (get_one_kb_item("Settings/automatically_accept_disclaimer"))
        {
          dbg::detailed_log(lvl:2, src:FUNCTION_NAME, msg:'Automatically accepting disclaimer per scan policy setting.');

          send_data = mkdword(1, order:BYTE_ORDER_BIG_ENDIAN) + mk_ssh_string(disclaimer_response);
          session.sshsend(data:send_data, code:PROTO_SSH_MSG_USERAUTH_INFO_RESPONSE);

          session.cur_state.set("USERAUTH_INFO_RES");
          session.sshrecv_until(end_states:make_list("SOC_CLOSED", "USERAUTH_INFO_REQ", "USERAUTH_FAILURE", "USERAUTH_SUCCESS"));
          # Loop back around to check response and look for password prompt
          continue;
        }
        # If scan policy is not configured to accept SSH disclaimers, send an empty response to trigger USERAUTH_FAILURE
        # per RFC 4256 Section 3.4 before returning authentication failure
        msg = 'Received the following keyboard-interactive authentication prompt :\n  "' +
          prompt + '"\n' +
          'The prompt appears to require acceptance of a disclaimer before login,\n' +
          'but the scan policy is not configured to automatically accept detected\n' +
          'SSH disclaimer prompts. This advanced setting must be enabled in order\n' +
          'to authenticate to this target via SSH.';

        session.sshsend(data:mkdword(0), code:PROTO_SSH_MSG_USERAUTH_INFO_RESPONSE);
        session.cur_state.set("USERAUTH_INFO_RES");
        session.sshrecv_until(end_states:make_list("SOC_CLOSED", "USERAUTH_FAILURE"));

        return session.set_auth_failure_error(user:username, port:session.get_port(), msg:msg);
      }

      # Check for a known password prompt, break if found
      if (interactive_login_password_prompt_found(
            prompt        : prompt,
            instruction   : parsed_info_req.instruction,
            username      : username,
            custom_prompt : custom_prompt)
      )
      {
        found_password_prompt = TRUE;
        break;
      }

      # If an unexpected prompt was received, send an empty response to trigger USERAUTH_FAILURE per RFC 4256 Section 3.4
      # before returning authentication failure
      msg = 'An unexpected SSH_MSG_USERAUTH_INFO_REQUEST prompt was received from\n' +
        'the server during keyboard-interactive authentication :\n' +
        serialize(parsed_info_req) + '\n' +
        'This prompt was not recognized as a known password or disclaimer\n' +
        'acceptance prompt. If it is a password prompt, configure the SSH\n' +
        'credential in the scan policy with the expected custom prompt. If it\n' +
        'is a prompt to accept a disclaimer, contact Tenable to request support.';

      session.sshsend(data:mkdword(0, order:BYTE_ORDER_BIG_ENDIAN), code:PROTO_SSH_MSG_USERAUTH_INFO_RESPONSE);
      session.sshrecv_until(end_states:make_list("SOC_CLOSED", "USERAUTH_FAILURE"));

      return session.set_auth_failure_error(user:username, port:session.get_port(), msg:msg);
    }

    if(!found_password_prompt)
    {
      err = "Did not find expected password prompt using keyboard-interactive authentication.";
      return session.set_auth_failure_error(user:username, port:session.get_port(), msg:err);
    }

    # Send password
    session.set_redact(TRUE);
    send_data = mkdword(1, order:BYTE_ORDER_BIG_ENDIAN) + mk_ssh_string(password);
    session.sshsend(data:send_data, code:PROTO_SSH_MSG_USERAUTH_INFO_RESPONSE);
    session.set_redact(FALSE);
    session.cur_state.set("USERAUTH_INFO_RES");

    # Get response
    session.sshrecv_until(end_states:make_list("SOC_CLOSED", "USERAUTH_INFO_REQ", "USERAUTH_SUCCESS", "USERAUTH_FAILURE"));

    # If there is an additional request, it may be an empty request requiring an empty response
    # Otherwise, it's an unsupported additional request such as a prompt to change the user's password
    if (session.cur_state.val == "USERAUTH_INFO_REQ")
    {
      parsed_info_req = interactive_login_parse_userauth_info_request(payload:session.last_packet.payload);
      dbg::detailed_log(
        lvl:3,
        src:FUNCTION_NAME,
        msg:'Parsed USERAUTH_INFO_REQUEST packet',
        msg_details:{"Info":{"lvl":3, "value":parsed_info_req}});

      # Empty request
      if (len(parsed_info_req.prompts) == 0)
      {
        # Send an empty response to satisfy the empty request
        session.sshsend(data:mkdword(0, order:BYTE_ORDER_BIG_ENDIAN), code:PROTO_SSH_MSG_USERAUTH_INFO_RESPONSE);
        session.sshrecv_until(end_states:make_list("SOC_CLOSED", "USERAUTH_SUCCESS", "USERAUTH_FAILURE"));
      }

      # Additional requests are unsupported - respond with 0 responses to trigger USERAUTH_FAILURE per RFC 4256
      else
      {
        if (
          "Changing password for " >< session.last_packet.payload ||                    # HPUX
          "Password change requested" >< session.last_packet.payload ||                 # SuSE 10
          "Password changing requested" >< session.last_packet.payload ||               # SuSE 9
          "Your password has expired" >< session.last_packet.payload ||                 # Solaris
          "New Password" >< session.last_packet.payload ||                              # FreeBSD
          "You are required to change your password" >< session.last_packet.payload     # Gentoo
        )
        {
          msg = "The password for the user '" + username + "' must be changed.";
        }
        else
        {
          msg = 'An unexpected additional SSH_MSG_USERAUTH_INFO_REQUEST packet was' +
            '\nreceived from the server during keyboard-interactive authentication :\n' +
            serialize(parsed_info_req);
        }
        # Send an empty response to trigger a USERAUTH_FAILURE from the server before returning the authentication failure
        session.sshsend(data:mkdword(0, order:BYTE_ORDER_BIG_ENDIAN), code:PROTO_SSH_MSG_USERAUTH_INFO_RESPONSE);
        session.sshrecv_until(end_states:make_list("SOC_CLOSED", "USERAUTH_FAILURE"));

        return session.set_auth_failure_error(user:username, port:session.get_port(), msg:msg);
      }
    }

    # Check response
    if (session.cur_state.val == "USERAUTH_SUCCESS")
      return TRUE;

    if (session.cur_state.val == "USERAUTH_FAILURE")
    {
      err = "Failed to authenticate with supplied password using keyboard-interactive authentication.";
      session.set_auth_failure_error(user:username, port:session.get_port(), msg:err);
      return FALSE;
    }

    # Unexpected response
    if (!isnull(session.last_packet.type))
      type_label = ssh2_packet_type_labels[session.last_packet.type];
    else
      type_label = ssh2_packet_type_labels[-1];

    if (isnull(type_label))
      type_label = session.last_packet.type;

    err = "Received unexpected response during interactive authentication [" + type_label + "]";
    return session.set_auth_failure_error(user:username, port:session.get_port(), msg:err);
  }


  ##
  # Run all pre-checks for a shell handler to see if any are applicable.
  #
  # @param [shell_session:object] The session object to use, passed by reference.
  # @param [shell_handler:string] The shell handler object name to test.
  # @param [checks:list]          A list of arrays of commands and callbacks for checking various host types.
  #
  # @return [boolean] TRUE if at least one check is applicable, FALSE otherwise.
  #
  # @remark
  # If one of the checks in ``checks`` does **not** have a pre-check callback the function will return TRUE.
  #
  # @remark
  # The list given in ``checks`` must be such that:
  # ```
  # [
  #   {
  #     'pre_check_fail_cb' : <reference to function to perform pre-checks>,
  #     'test_cmd'          : <string command to run>,
  #     'test_cmd_regex'    : <regex to check against output of test_cmd>,
  #     'cmd_success_cb'    : <reference to function to call if test_cmd_regex matches>,
  #     'cmd_fail_cb'       : <reference to function to call if test_cmd_regex doesn't match>
  #   },
  #   ...
  # ]
  # ```
  # However, in this function only the ``pre_check_fail_cb`` and ``test_cmd`` entries are used.
  ##
  function shell_handler_checks_applicable(&shell_session, shell_handler, checks)
  {
    dbg::detailed_log(lvl:2, src:FUNCTION_NAME, msg:
      'Running pre-checks for shell handler "' + shell_handler + '" to see if any may be applicable to the target.');

    var cmd_set, tmp_cb;
    var max_checks = max_index(checks);
    for (var j = 0; j < max_checks && !isnull(shell_session.channel_manager); j++)
    {
      cmd_set = checks[j];

      tmp_cb = cmd_set['pre_check_fail_cb'];
      if (isnull(tmp_cb))
      {
        dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:
          'No pre-check provided for command "' + cmd_set['test_cmd'] + '", returning TRUE.');
        return TRUE;
      }
      if(!tmp_cb())
      {
        dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:
          'Pre-check passed for command "' + cmd_set['test_cmd'] + '", returning TRUE.');
        return TRUE;
      }
      dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'Pre-check failed for command "' + cmd_set['test_cmd']);
      continue;
    }
    dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'All pre-checks failed.');
    return FALSE;
  }

  ##
  # Executes all of the command checks declared for a given shell type.
  #
  # @param [shell_session:object]      The session object to use, passed by reference.
  # @param [shell_channel:object]      The channel object to use, passed by reference.
  # @param [shell_handler:object]      The shell handler object to use, passed by reference.
  # @param [shell_handler_name:string] The name of the shell handler object referenced.
  # @param [checks:list]               A list of arrays of commands and callbacks for checking various host types.
  # @param [kb_id:string]              String prefix of KB keys to read.
  # @param [escl_type:string]          String designates the type of privilege escalation configured.
  # @param [escl_extra:array]          An array containing extra information for the escalation method given.
  #
  # @return [list|NULL] NULL if an error occurred, or a list containing the success status and extra information when successful.
  #
  # @remark
  # In case of success the returned list is such that:
  # ```
  # [
  #   TRUE,
  #   <string with more information on the success>,
  #   <even more information>,
  #   ...
  # ]
  # ```
  # The extra information is optional.
  #
  # @remark
  # The list given in ``checks`` must be such that:
  # ```
  # [
  #   {
  #     'pre_check_fail_cb' : <reference to function to perform pre-checks>,
  #     'test_cmd'          : <string command to run>,
  #     'test_cmd_regex'    : <regex to check against output of test_cmd>,
  #     'cmd_success_cb'    : <reference to function to call if test_cmd_regex matches>,
  #     'cmd_fail_cb'       : <reference to function to call if test_cmd_regex doesn't match>
  #   },
  #   ...
  # ]
  # ```
  ##
  function run_shell_checks(shell_session, shell_channel, shell_handler, shell_handler_name, checks, kb_id, escl_type, escl_extra)
  {
    var j, cmd_set, tmp_cb, res, err_msg, escl_failed, item;

    var fn = 'run_shell_checks';
    var escl_hexstr = hexstr(MD5(serialize(escl_extra)));
    var tmp_bad_escl_kb = "tmp/" + kb_id + "/ssh_bad_priv_escl/" + escl_type;

    var max_checks = max_index(checks);
    for (j = 0; j < max_checks && !isnull(shell_session.channel_manager); j++)
    {
      cmd_set = checks[j];

      tmp_cb = cmd_set['pre_check_fail_cb'];
      if (tmp_cb)
        dbg::detailed_log(lvl:3, src:fn, msg:"Calling pre-check callback for next check.");

      if(!isnull(tmp_cb) && tmp_cb())
      {
        dbg::detailed_log(lvl:3, src:fn, msg:"Pre-check failed for command '"+ cmd_set['test_cmd'] +"', skipping check.");
        continue;
      }

      # Run test_cmd
      dbg::detailed_log(
        lvl:3,
        src:fn,
        msg:'Running the shell check test command.',
        msg_details:{
          "Command":{"lvl":3, "value":cmd_set['test_cmd']},
          "Shell handler": {"lvl":3, "value":shell_handler_name},
          "Regex": {"lvl":3, "value":cmd_set['test_cmd_regex']}});

      if(shell_channel == NOSETUP)
        res = shell_session.run_shell_command(command:cmd_set['test_cmd']);
      else
        res = shell_session.run_shell_command(channel:shell_channel, command:cmd_set['test_cmd']);

      escl_failed = FALSE;
      var old_res = res;
      var old_err = shell_session.cmd_error;
      if(empty_or_null(old_res) && empty_or_null(old_err))
        old_err = "Unknown error";

      # If res doesn't match the test_cmd_regex and we were testing
      # with escalation, retry without escalation
      if(res !~ cmd_set['test_cmd_regex'] && !isnull(escl_type))
      {
        if (get_kb_item(tmp_bad_escl_kb) == escl_hexstr)
        {
          dbg::detailed_log(lvl:2, src:fn, msg:"Privilege escalation failed, retrying without privilege escalation.");
          shell_handler.unset_priv_escalation();
          escl_failed = TRUE;
          err_msg = old_res + old_err;

          if(shell_channel == NOSETUP)
            res = shell_session.run_shell_command(command:cmd_set['test_cmd']);
          else
            res = shell_session.run_shell_command(channel:shell_channel, command:cmd_set['test_cmd']);
        }
      }

      # If res matches the test_cmd_regex, set KB items and return TRUE
      if(res =~ cmd_set['test_cmd_regex'])
      {
        tmp_cb = cmd_set['cmd_success_cb'];

        replace_kb_item(name:SSH_LIB_KB_PREFIX + "cmd_method", value:"shell_handler");
        replace_kb_item(name:SSH_LIB_KB_PREFIX + "shell_handler", value:shell_handler_name);

        dbg::detailed_log(
          lvl:2,
          src:fn,
          msg:'The following check was successful.',
          msg_details:{
            "Command":{"lvl":2, "value":cmd_set['test_cmd']},
            "Shell handler": {"lvl":2, "value":shell_handler_name},
            "Regex": {"lvl":2, "value":cmd_set['test_cmd_regex']},
            "Response": {"lvl":3, "value":res}});

        if(!isnull(tmp_cb))
        {
          tmp_cb(session:shell_session, use_shell_handler:TRUE, channel:shell_channel, cmd_res:res);
        }
        else
        {
          dbg::detailed_log(lvl:3, src:fn, msg:"cmd_success_cb function is NULL.");
        }
        shell_session.close_connection();


        if (!escl_failed && get_kb_item(tmp_bad_escl_kb) == escl_hexstr)
        {
          dbg::detailed_log(lvl:1, src:fn, msg:"Privilege escalation failed.");
          shell_handler.unset_priv_escalation();
          escl_failed = TRUE;
          err_msg = old_err;
        }

        if(!escl_failed)
          return make_list(TRUE);

        rm_kb_item(name:SSH_LIB_KB_PREFIX + kb_id + "/escalation_type");
        foreach item (keys(escl_extra))
          rm_kb_item(name:"Secret/" + SSH_LIB_KB_PREFIX + kb_id + "/escalation_extra/" + item);

        if(isnull(err_msg))
          err_msg = "";

        return make_list(TRUE, "Privilege escalation failed, but the command was successful without privilege escalation.", err_msg);
      }
      # If res does not match test_cmd_regex, call the cmd_fail_cb
      else
      {
        dbg::detailed_log(
          lvl:3,
          src:fn,
          msg:'Command response does not match expected regex.',
          msg_details:{
            "Command":{"lvl":3, "value":cmd_set['test_cmd']},
            "Regex": {"lvl":3, "value":cmd_set['test_cmd_regex']},
            "Response": {"lvl":3, "value":res}});

        tmp_cb = cmd_set['cmd_fail_cb'];
        if(!isnull(tmp_cb))
          tmp_cb(session:shell_session, use_shell_handler:TRUE, channel:shell_channel, cmd_res:res);
      }

      # Clear any existing errors before trying next command
      shell_session.clear_cmd_error();
    }

    dbg::detailed_log(lvl:2, src:FUNCTION_NAME, msg:'None of the checks for "' + shell_handler_name + '" were successful.');
    return NULL;
  }

  ##
  # Tests a command wrapper shell to see if it works.
  #
  # @param [shell_session:object] The session object to use, passed by reference.
  # @param [shell_channel:object] The channel object to use, passed by reference.
  # @param [shell_handler:object] The shell handler object to use, passed by reference.
  #
  # @return [boolean] Returns FALSE if the wrapper fails, TRUE otherwise.
  ##
  function is_shell_right_for_handler(shell_channel, shell_session, shell_handler)
  {
    var res, cmd;


    if(typeof_ex(shell_handler) == 'sshlib::sh_shell_handler')
    {
      cmd = 'printf "command_start_%s" "TEST"';
      dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:"Sending a command wrapper to the shell to see if it supports them.");

      if(shell_channel == NOSETUP)
        res = shell_session.run_shell_command(command:cmd);
      else
        res = shell_session.run_shell_command(channel:shell_channel, command:cmd);

      if(res != "command_start_TEST")
        return FALSE;
    }

    # Assume other shell handlers are appropriate
    return TRUE;
  }

  ##
  # Attempts to find a shell handler that will work with the target host.
  #
  # @remark
  # This function works by:
  #
  # 1. Looping over the supplied shell handler classes
  # 2. Instantiating the handler and running each of the supplied checks against the host
  # 3. If a handler produces the expected result for a given check then that
  #    becomes the shell handler for this connection.
  #
  # @param [host:string]         The target host (optional, only required if different from scan target).
  # @param [port:integer]        SSH listening port on target host.
  # @param [shell_handlers:list] A list of strings each representing a shell handler object name.
  # @param [cmd_list:array]      An array of lists of shell handlers and associated commands
  #                              and callbacks for checking various host types.
  #
  # @return [list] The list returned contains the success status of the function, and
  #         strings giving more information in the success/failure.
  #
  # @remark
  # The array given in ``cmd_list`` should be such that:
  # ```
  # {
  #   <shell handler object name> :
  #     [
  #       {
  #         'pre_check_fail_cb' : <reference to function to perform pre-checks>,
  #         'test_cmd'          : <string command to run>,
  #         'test_cmd_regex'    : <regex to check against output of test_cmd>,
  #         'cmd_success_cb'    : <reference to function to call if test_cmd_regex matches>,
  #         'cmd_fail_cb'       : <reference to function to call if test_cmd_regex doesn't match>
  #       },
  #       ...
  #     ],
  #   'sshlib::sh_shell_handler' :
  #     [
  #       {
  #         'pre_check_fail_cb' : @linux_pre_check_fail,
  #         'test_cmd'          : 'uname -a',
  #         'test_cmd_regex'    : "^Linux\s",
  #         'cmd_success_cb'    : @handle_linux_os,
  #         'cmd_fail_cb'       : @handle_not_linux_os
  #       },
  #       ...
  #     ],
  #     ...
  # }
  # ```
  #
  # The list given in ``shell_handlers`` should be an ordered list of the shell handler names
  # appearing the ``cmd_list`` array. The order in ``shell_handlers`` will determine the order
  # in which the shell handlers will be checked so the most commons or most problematic should come first.
  #
  # The list returned by the function is such that:
  # ```
  # [
  #   <TRUE if successful, FALSE otherwise>,
  #   <string with more information on the success>,
  #   <even more information>,
  #   ...
  # ]
  # ```
  # The extra information is optional.
  ##
  function try_ssh_shell_handlers(host, port, shell_handlers, cmd_list)
  {
    var tmp_session, tmp_channel, tmp_channel1, escl_type, escl_extra, tmp_sh;
    var i, shell_handler, fn, kb_id, checks, res;

    fn = 'try_ssh_shell_handlers';

    # Open connection and retrieve/set escalation information
    tmp_session = new("sshlib::session");
    if(!tmp_session.open_connection(host:host, port:port))
    {
      if(!empty_or_null(tmp_session.error))
        return make_list(FALSE, tmp_session.error);
      else
        return make_list(FALSE, "open_connection() failed.");
    }

    kb_id = tmp_session.get_kb_connection_id();

    escl_type = get_kb_item(SSH_LIB_KB_PREFIX + kb_id + "/escalation_type");

    if(!isnull(escl_type))
    {
      escl_extra = get_kb_args(kb_prefix:("Secret/" + SSH_LIB_KB_PREFIX + kb_id + "/escalation_extra"));
    }

    for (i = 0; i < max_index(shell_handlers); i++)
    {
      sleep(2);
      shell_handler = shell_handlers[i];
      checks = cmd_list[shell_handler];

      if (!shell_handler_checks_applicable(shell_session:tmp_session, shell_handler:shell_handler, checks:checks))
      {
        dbg::detailed_log(lvl:3, src:fn, msg:'Skipping shell handler "' + shell_handler + '", no applicable checks.');
        continue;
      }

      dbg::detailed_log(lvl:2, src:fn, msg:"Trying shell handler: "+shell_handler+".");

      if(!tmp_session.login())
      {
        tmp_session.close_connection();
        if(!empty_or_null(tmp_session.error))
          return make_list(FALSE, tmp_session.error);
        else
          return make_list(FALSE, "login() failed.");
      }

      tmp_sh = new(shell_handler);
      if(!isnull(escl_type))
        tmp_sh.set_priv_escalation(type:escl_type, extra:escl_extra);

      tmp_channel = tmp_session.open_shell(shell_handler:tmp_sh);
      if(isnull(tmp_channel))
      {
        tmp_session.close_connection();
        return make_list(FALSE, "unable to open channel for shell handler.");
      }

      #Initial shell handler commands can cause a server to disconnect
      #deleting the session's channel manager
      if(!isnull(tmp_session.channel_manager))
        tmp_session.channel_manager.set_default_channel(tmp_channel);

      if(is_shell_right_for_handler(shell_channel:tmp_channel, shell_session:tmp_session, shell_handler:tmp_sh))
      {
        res = run_shell_checks(shell_session:tmp_session, shell_channel:tmp_channel,
                               shell_handler:tmp_sh, shell_handler_name:shell_handler, checks:checks, kb_id:kb_id,
                               escl_type:escl_type, escl_extra:escl_extra);
        if(!isnull(res))
          return res;
      }

      # If there are more shell handlers to try, close and re-open the
      # connection in case previous shell handler left the connection
      # in a bad state
      if(i+1 < len(shell_handlers) && tmp_channel != NOSETUP)
      {
        tmp_session.close_connection();
        tmp_session = new("sshlib::session");

        if(!tmp_session.open_connection(host:host, port:port))
        {
          if(!empty_or_null(tmp_session.error))
            return make_list(FALSE, tmp_session.error);
          else
            return make_list(FALSE, "open_connection() failed.");
        }
      }
    }

    tmp_session.close_connection();
    return make_list(FALSE, "unable to identify host.");
  }


  ##
  # Tries to identify the target host using SSH exec.
  #
  # @remark
  # This function works by:
  #
  # 1. Looping over the supplied command list , executing checks
  # 2. If a command result matches the expected regular expression the host
  #    will be identified as the type associated with that check.
  #
  # @param [host:string]   The target host (optional, only required if different from scan target).
  # @param [port:integer]  SSH listening port on target host.
  # @param [cmd_list:list] A list of arrays of commands and callbacks for checking various host types.
  #
  # @return [list] The list returned contains the success status of the function, and
  #         strings giving more information in the success/failure.
  #
  # @remark
  # The list given in ``cmd_list`` must be such that:
  # ```
  # [
  #   {
  #     'pre_check_fail_cb' : <reference to function to perform pre-checks>,
  #     'test_cmd'          : <string command to run>,
  #     'test_cmd_regex'    : <regex to check against output of test_cmd>,
  #     'cmd_success_cb'    : <reference to function to call if test_cmd_regex matches>,
  #     'cmd_fail_cb'       : <reference to function to call if test_cmd_regex doesn't match>
  #   },
  #   {
  #     'pre_check_fail_cb' : @linux_pre_check_fail,
  #     'test_cmd'          : 'uname -a',
  #     'test_cmd_regex'    : "^Linux\s",
  #     'cmd_success_cb'    : @handle_linux_os,
  #     'cmd_fail_cb'       : @handle_not_linux_os
  #   },
  #   ...
  # ]
  # ```
  #
  # The list returned by the function is such that:
  # ```
  # [
  #   <TRUE if successful, FALSE otherwise>,
  #   <string with more information on the success>,
  #   <even more information>,
  #   ...
  # ]
  # ```
  # The extra information is optional.
  ##
  function try_ssh_exec(host, port, cmd_list)
  {
    var cmd_set, tmp_session, res, tmp_cb;
    var fn = 'try_ssh_exec';

    tmp_session = new("sshlib::session");

    if(!tmp_session.open_connection(host:host, port:port))
    {
      if(!empty_or_null(tmp_session.error))
        return make_list(FALSE, tmp_session.error);
      else
        return make_list(FALSE, "open_connection() failed.");
    }

    if(!tmp_session.login())
    {
      tmp_session.close_connection();
      if(!empty_or_null(tmp_session.error))
        return make_list(FALSE, tmp_session.error);
      else
        return make_list(FALSE, "login() failed.");
    }

    foreach cmd_set(cmd_list)
    {
      tmp_cb = cmd_set['pre_check_fail_cb'];
      if (tmp_cb)
        dbg::detailed_log(lvl:3, src:fn, msg: "Calling pre-check callback for next check.");
      if(!isnull(tmp_cb) && tmp_cb())
      {
        dbg::detailed_log(lvl:3, src:fn, msg:"Pre-check failed for command '" + cmd_set['test_cmd'] + "', skipping check.");
        continue;
      }

      dbg::detailed_log(
        lvl:3,
        src:fn,
        msg:'Running the exec check test command.',
        msg_details:{
          "Command":{"lvl":3, "value":cmd_set['test_cmd']},
          "Regex": {"lvl":3, "value":cmd_set['test_cmd_regex']}});

      res = tmp_session.run_exec_command(command:cmd_set['test_cmd'], inactivity_timeout_min:60);

      if(res =~ cmd_set['test_cmd_regex'])
      {
        dbg::detailed_log(
          lvl:2,
          src:fn,
          msg:'The following check was successful.',
          msg_details:{
            "Command":{"lvl":2, "value":cmd_set['test_cmd']},
            "Regex": {"lvl":2, "value":cmd_set['test_cmd_regex']},
            "Response": {"lvl":3, "value":obj_rep(res)}});

        # Setting the KB item before calling the callback
        # in case it wants to set the KB item differently, e.g. use a shell handler
        replace_kb_item(name:SSH_LIB_KB_PREFIX + "cmd_method", value:"exec");

        tmp_cb = cmd_set['cmd_success_cb'];
        if(!isnull(tmp_cb))
          tmp_cb(session:tmp_session, use_shell_handler:FALSE, cmd_res:res);

        tmp_session.close_connection();

        return make_list(TRUE);
      }
      else
      {
        dbg::detailed_log(
          lvl:3,
          src:fn,
          msg:'Command response does not match expected regex.',
          msg_details:{
            "Command":{"lvl":3, "value":cmd_set['test_cmd']},
            "Regex": {"lvl":3, "value":cmd_set['test_cmd_regex']},
            "Response": {"lvl":3, "value":res}});

        tmp_cb = cmd_set['cmd_fail_cb'];
        if(!isnull(tmp_cb))
          tmp_cb(session:tmp_session, use_shell_handler:FALSE, cmd_res:res);

        if(tmp_session.last_cmd_interrupted())
        {
          dbg::detailed_log(lvl:1, src:fn, msg:"Command interrupted in exec mode. Moving on.");
          tmp_session.reset_cmd_interrupted();
          break;
        }
      }
    }
    tmp_session.close_connection();
    return make_list(FALSE, "unable to identify host.");
  }

  ##
  # Wrapper function to run `sshlib::session.open_connection()`_ on current session.
  #
  # @param [session:object] The session object to use, passed by reference.
  # @param [fn:string] Function name from caller (unused).
  # @param [host:string] The host for which to open the connection.
  # @param [port:integer] The SSH port on which the connection should be opened.
  #
  # @return [boolean] The return value of `sshlib::session.open_connection()`_.
  ##
  function open_connection_wrapper(&session, fn, host, port)
  {
    var ret;
    if (empty_or_null(fn))
      fn = FUNCTION_NAME;

    # Open connection
    if(!empty_or_null(host))
    {
      ret = session.open_connection(host:host, port:port);
    }
    else
    {
      ret = session.open_connection(port:port);
    }
    return ret;
  }

  ##
  # Wrapper function to reconnect session.
  #
  # @param [session:object] The session object to use, passed by reference.
  # @param [fn:string] Function name from caller (optional, use for logging).
  # @param [host:string] The host for which to re-open the connection.
  # @param [port:integer] The SSH port on which the connection should be re-opened.
  # @param [sleep_value:integer] Number of seconds to sleep before starting new session (optional, defaults to 2).
  #
  # @return [boolean] TRUE if successful, FALSE otherwise.
  #
  # @remark
  # This will close the session and delete the associated object
  # before creating a brand new session object and re-opening the connection.
  ##
  function reconnect_wrapper(&session, fn, host, port, sleep_value)
  {
    var ret;
    if (empty_or_null(fn))
      fn = FUNCTION_NAME;

    # reconnect session since we opened a channel before
    # and we want to ensure other credential methods can be tried on this connection.
    dbg::detailed_log(lvl:2, src:fn, msg:'Reconnecting SSH session.');
    session.close_connection();
    delete(session);

    if(isnull(sleep_value))
      sleep_value = 2;
    sleep(sleep_value);

    session = new("sshlib::session");
    # Open connection
    ret = open_connection_wrapper(session:session, fn:fn, host:host, port:port);
    # If for some reason the session state is still SOC_CLOSED or connection failed, remove the creds.
    if(session.cur_state.val == "SOC_CLOSED" || !ret)
    {
      dbg::detailed_log(lvl:1, src:fn, msg:'Unable to re-establish SSH session.');
      session.clear_saved_login_info();
      session.close_connection();
      return FALSE;
      # The calling function will have to do something based on ret value
      # such as calling continue or break in credentials loop in try_ssh_kb_settings_login().
    }
    return TRUE;
  }

  ##
  # Attempt SonicWall "none" authentication.
  #
  # @param [tmp_session:object] The session object to use, passed by reference.
  # @param [new_channel:any]    A variable in which a new channel object will be stored, passed by reference.
  # @param [fn:string]          Function name from caller (optional, use for logging).
  # @param [cred_kb_index:integer]     Index value of the credential set to use (the credential set index from the KB).
  # @param [username:string]    Username from current credential set.
  # @param [host:string]        The host name on which to attempt the auth.
  # @param [port:integer]       The SSH port on which to connect.
  # @param [sh:object]          The shell handler object to use to run commands.
  #
  # @return [string] String to tell calling function whether to "break" or "continue" in the loop over credentials.
  #
  # @remark
  # The returned string "break" means the device is a Sonicwall device and login succeeded or
  # the target notified the creds must be changed. Otherwise the string "continue" is returned.
  #
  # @remark
  # Unless authentication succeeded and the device is Sonicwall, the channel in ``new_channel`` will be closed.
  ##
  function sonicwall_none_auth(&tmp_session, &new_channel, fn, cred_kb_index, username, host, port, sh)
  {
    var password, ret_recon_wrapper;
    if (empty_or_null(fn))
      fn = FUNCTION_NAME;

    password = get_kb_item("Secret/SSH"+cred_kb_index+"password");
    if(isnull(password))
      password = "";

    new_channel = tmp_session.open_shell(shell_handler:sh, skip_check_shell:TRUE);
    if(new_channel)
    {
      tmp_session.sshrecv_until(
        end_states     : make_list("SOC_CLOSED"),
        channel        : new_channel,
        check_callback : @rate_limiting_check_password_prompt_cb,
        cmd_timeout    : 40,
        track_keepalives : FALSE
      );

      if("sonicwall, inc." >< tolower(new_channel.data_buf))
      {
        dbg::detailed_log(lvl:2, src:fn, msg:'Detected SonicWall device using "none" authentication.');
        IS_SONICWALL = TRUE; # global session var
        new_channel.clear_data_buf();
        new_channel.window_send_data(data:password + '\n', redact:TRUE);
        tmp_session.sshrecv_until(
          end_states     : make_list("SOC_CLOSED"),
          channel        : new_channel,
          check_callback : @sonicwall_is_password_success_cb,
          cmd_timeout    : 40,
          track_keepalives : TRUE # track keepalive messages that we see
                                  # on sonicwall devices as a failsafe timeout feature.
        );
        # incorrect login - break out of credentials loop and report login failure
        if("must be changed" >< tolower(new_channel.data_buf))
        {
          dbg::detailed_log(lvl:1, src:fn, msg:'Login failed to SonicWall device because password must be changed.');
          tmp_session.clear_saved_login_info();
          new_channel.close();
          tmp_session.close_connection();
          sleep(3); # sleep a few seconds to allow sonicwall devices to register that the connection is closed
          return "break";
        }
        # incorrect login - clear saved info so other login attempts can be made and continue trying credentials
        else if("access denied" >< tolower(new_channel.data_buf))
        {
          dbg::detailed_log(lvl:1, src:fn, msg:'Login failed to SonicWall device due to incorrect credentials.');
          tmp_session.clear_saved_login_info();
          new_channel.close();
          tmp_session.close_connection();
          sleep(3); # sleep a few seconds to allow sonicwall devices to register that the connection is closed
          return "continue";
        }
        # Successful login to SonicWall
        # login_res is already TRUE so break out of loop to report success
        else if("@" >< new_channel.data_buf && "access denied" >!< tolower(new_channel.data_buf))
        {
          dbg::detailed_log(
            lvl:2,
            src:fn,
            msg:'Login to SonicWall device successful using "none" authentication method.',
            msg_details:{'User':{'lvl':3, 'value':username}});
          set_kb_item(name:SSH_LIB_KB_PREFIX + "sonicwall/none", value:TRUE);
          return "break";
        }
      }
      # not a sonicwall device but it's accepting "none" auth.
      # ignore this and continue trying to authenticate with other methods
      else
      {
        dbg::detailed_log(lvl:3, src:fn, msg:'"none" authentication accepted but not identified as SonicWall device. ' +
          'Proceed to trying different auth method.');
        tmp_session.clear_saved_login_info();
        new_channel.close();
        ret_recon_wrapper = reconnect_wrapper(session:tmp_session, fn:fn, host:host, port:port);
        if(!ret_recon_wrapper)
        {
          return "continue"; # if reconnect failed continue trying next credential set
        }
      }
    }
    # Failed to open a channel for rate limit check
    else
    {
      dbg::detailed_log(lvl:2, src:fn, msg:'Failed to open channel in rate limit check for "none" authentication.');
      tmp_session.clear_saved_login_info();
      # reconnect session
      ret_recon_wrapper = reconnect_wrapper(session:tmp_session, fn:fn, host:host, port:port);
      if(!ret_recon_wrapper)
      {
        return "continue"; # if reconnect failed continue trying next credential set
      }
    }
  }

  ##
  # Authenticate and identify a rate-limited device using a
  # non "none" authentication method (password / public key).
  #
  # @param [tmp_session:object] The session object to use, passed by reference.
  # @param [new_channel:any]    A variable in which a new channel object will be stored, passed by reference.
  # @param [fn:string]          Function name from caller (optional, use for logging).
  # @param [username:string]    Username from current credential set.
  # @param [host:string]        The host name on which to attempt the auth.
  # @param [port:integer]       The SSH port on which to connect.
  # @param [sh:object]          The shell handler object to use to run commands.
  #
  # @return [boolean] TRUE if login success, FALSE if failed.
  #                   The calling function should use this returned value as the login result.
  #
  # @remark
  # Unless authentication succeeded and the device is rate-limited, the channel in ``new_channel`` will be closed.
  ##
  function rate_limited_device_auth(&tmp_session, &new_channel, fn, username, host, port, sh)
  {
    var login_check, ret_recon_wrapper, login_res, lowered_data_buf;
    if (empty_or_null(fn))
      fn = FUNCTION_NAME;

    login_res = TRUE;
    dbg::detailed_log(lvl:2, src:fn, msg:'Checking for rate limited devices.');
    new_channel = tmp_session.open_shell(shell_handler:sh, skip_check_shell:TRUE);
    if(new_channel)
    {
      dbg::detailed_log(lvl:3, src:fn, msg:'Successfully opened channel for rate limit check.');
      tmp_session.sshrecv_until(
        end_states     : make_list("SOC_CLOSED"),
        channel        : new_channel,
        check_callback : @rate_limiting_check_cb,
        cmd_timeout    : 40
      );

      lowered_data_buf = tolower(new_channel.data_buf);

      if(("sonicwall" >< lowered_data_buf) || ("sonic" >< lowered_data_buf && "open networking" >< lowered_data_buf))
      {
        dbg::detailed_log(lvl:2, src:fn, msg:'Detected SonicWall device.');

        IS_SONICWALL = TRUE;
        set_kb_item(name:SSH_LIB_KB_PREFIX + "sonicwall_prompt", value:new_channel.data_buf);
        set_kb_item(name:SSH_LIB_KB_PREFIX + "sonicwall/passwordauth", value: TRUE);

        if ("access denied" >< lowered_data_buf)
        {
          dbg::detailed_log(lvl:1, src:fn, msg:'Login failed to SonicWall device due to incorrect credentials.');
          tmp_session.clear_saved_login_info();
          login_res = FALSE;
          new_channel.close();
          if(!isnull(tmp_session.channel_manager))
            tmp_session.channel_manager.remove_channel(channel:new_channel);
        }
      }
      else if ("starting the pcli" >< lowered_data_buf || "session smart networking platform" >< lowered_data_buf)
      {
        dbg::detailed_log(lvl:2, src:fn, msg:'Detected the Juniper Session Smart Networking Platform.');

        IS_JUNOS = TRUE;
        set_kb_item(name:SSH_LIB_KB_PREFIX + "JuniperSSR/auth", value:TRUE);
        if ("starting the pcli" >< lowered_data_buf)
          set_kb_item(name:SSH_LIB_KB_PREFIX + "JuniperSSR/is_PCLI", value:TRUE);
      }
      else if("junos" >< lowered_data_buf || "juniper" >< lowered_data_buf)
      {
        dbg::detailed_log(lvl:2, src:fn, msg:'Detected JUNOS device.', msg_details:{'User':{'lvl':3, 'value':username}});

        IS_JUNOS = TRUE;
        set_kb_item(name:SSH_LIB_KB_PREFIX + "junos_prompt", value:new_channel.data_buf);
        set_kb_item(name:SSH_LIB_KB_PREFIX + "junos/auth", value:TRUE);

        # Checking for Junos CLI shell
        login_check = sh.run_command(channel:new_channel, command:"uname -a", raw:TRUE, cmd_timeout_min:40);

        if("unknown command" >< tolower(login_check) || "syntax error, expecting <command>" >< tolower(login_check))
        {
          dbg::detailed_log(lvl:3, src:fn, msg:"Junos shell mode not detected. Using cli mode.");
        }
        else if("junos" >< tolower(login_check) || "juniper" >< tolower(login_check) || "freebsd" >< tolower(login_check))
        {
          # JUNOS shell prompt (%) so set KB item to tell ssh_rate_limiting.nasl to use shell commands
          dbg::detailed_log(lvl:3, src:fn, msg:"Junos shell mode detected.");
          set_kb_item(name:"Host/Juniper/JUNOS/shell", value:TRUE);
          replace_kb_item(name:"Host/uname", value:login_check);
        }
      }
      else if("omniswitch" >< lowered_data_buf)
      {
        dbg::detailed_log(lvl:2, src:fn, msg:'Detected Alcatel-Lucent OmniSwitch device.');

        IS_AOS = TRUE; # global session var
        set_kb_item(name:SSH_LIB_KB_PREFIX + "omniswitch/banner", value:new_channel.data_buf);
        set_kb_item(name:SSH_LIB_KB_PREFIX + "omniswitch/auth", value:TRUE);
      }
      else
      {
        dbg::detailed_log(lvl:2, src:fn, msg:'Host is not identified as a rate limited device.');
        new_channel.close();
        if(!isnull(tmp_session.channel_manager))
          tmp_session.channel_manager.remove_channel(channel:new_channel);
      }
    }
    else
    {
      dbg::detailed_log(lvl:1, src:fn, msg:'Failed to open channel for rate limit check.');
    }
    # reconnect session if needed
    if(tmp_session.cur_state.val == "SOC_CLOSED")
    {
      ret_recon_wrapper = reconnect_wrapper(session:tmp_session, fn:fn, host:host, port:port);
      if(!ret_recon_wrapper)
        login_res = FALSE;
    }

    if(login_res)
      return TRUE;
    else
      return FALSE;
  }

  ##
  # Attempt Cisco WLC "none" authentication.
  #
  # @param [session:object]  The session object to use, passed by reference.
  # @param [channel:any]     A variable in which a new channel object will be stored, passed by reference.
  # @param [fn:string]       Function name from caller (optional, use for logging).
  # @param [cred_kb_index:integer]  Index value of the credential set to use (the credential set index from the KB).
  # @param [username:string] Username from current credential set.
  # @param [host:string]     The host name on which to attempt the auth.
  # @param [port:integer]    The SSH port on which to connect.
  #
  # @return [boolean] TRUE if login was successful, FALSE otherwise.
  #
  # @remark
  # The channel in ``channel`` is not closed after failures.
  ##
  function cisco_wlc_none_auth(&session, &channel, fn, cred_kb_index, username, host, port)
  {
    if (empty_or_null(fn))
      fn = FUNCTION_NAME;

    var password = get_kb_item('Secret/SSH' + cred_kb_index + 'password');
    if(isnull(password))
      password = '';

    channel = session.open_shell(shell_handler:new('sshlib::basic_shell_handler'));
    if(!channel)
    {
      dbg::detailed_log(lvl:1, src:fn, msg:'Login to Cisco WLC device failed to open shell');
      return FALSE;
    }
    session.sshrecv_until(
      end_states     : make_list('SOC_CLOSED'),
      channel        : channel,
      check_callback : @cisco_wlc_user_prompt_cb,
      cmd_timeout    : 40
    );

    if(channel.data_buf =~ "\nUser:\s?$")
    {
      channel.clear_data_buf();
      channel.window_send_data(data:username + '\n');
      session.sshrecv_until(
        end_states : make_list('SOC_CLOSED'),
        channel: channel,
        check_callback : @cisco_wlc_password_cb,
        cmd_timeout: 40
      );

      if(channel.data_buf =~ "\nPassword:\s?$")
      {
        channel.clear_data_buf();
        channel.session.set_redact(TRUE);
        channel.window_send_data(data:password + '\n');
        channel.session.set_redact(FALSE);
        session.sshrecv_until(
          end_states : make_list('SOC_CLOSED'),
          channel: channel,
          check_callback : @cisco_wlc_login_cb,
          cmd_timeout: 40
        );
      }

      # Check if the credentials succeeded
      if(channel.data_buf =~ "\nUser:\s?$")
      {
        dbg::detailed_log(lvl:1, src:fn, msg:'Login to Cisco WLC device failed due to incorrect credentials.');
        session.clear_saved_login_info();
        return FALSE;
      }
    }

    # Check if we are at a Cisco Controller Prompt
    if('Cisco Controller' >!< channel.data_buf)
    {
      dbg::detailed_log(lvl:3, src:fn, msg:'"none" authentication accepted but device not identified as Cisco WLC.');
      session.clear_saved_login_info();
      return FALSE;
    }

    dbg::detailed_log(
      lvl:2,
      src:fn,
      msg:'Login to Cisco WLC device successful using "none" authentication method.',
      msg_details:{'User':{'lvl':3, 'value':username}});
    replace_kb_item(name:'Host/Cisco/WLC/SSH', value:TRUE);

    return TRUE;
  }


  ##
  # Iterates through ``Secret/SSH/[0-9]+/*`` kb items (set by ssh settings plugin)
  # and tries to find a valid login method.
  #
  # @param [session:object]           The variable in which to store an sshlib session object to use if authentication is successful.
  # @param [accept_none_auth:boolean] If not true and 'none' auth succeeds, will cause the function to continuing trying other
  #                                   credentials and methods.
  # @param [rate_limit:boolean]       Login and check for rate-limited devices. (optional,
  #                                   only set to true if this is running with the SSH rate limiting plugin.)
  # @param [new_channel:object]       Channel object passed by reference to be used only when ``rate_limit`` is TRUE (optional).
  # @param [force_none_auth:boolean]  Forces function to recheck supported auth methods regardless of what is cached in KB.
  # @param [sd_auth_info:object]      structured_data_authentication_status_information logging if the structured_data_authentication_status_information
  #                                    object is passed into the parameter sd_auth_info. If it is not passed it then it will be ignored to prevent duplicate reporting
  #                                    of the SSH authentication information. The object is currently being passed in from ssh_rate_limiting.nasl and should not be
  #                                    passed in through any other source.
  #
  # @return [boolean|NULL] Returns TRUE if a login succeeds using stored credentials, FALSE if logging
  #         in was not possible using stored credential sets, and NULL if an error happens.
  #
  # @remark
  # ``rate_limit`` should only be set to TRUE when the function needs to check for rate-limited devices.
  # And checking for rate-limited devices should only be performed in ``ssh_rate_limiting.nasl``.
  #
  # If ``rate_limit`` is set to TRUE, this function will call `sshlib::rate_limited_device_auth()`_.
  # This will identify the device via post login banner and open a shell on the device and store
  # it in ``session`` and ``new_channel`` for further checks to be performed in the same shell.
  ##
  function try_ssh_kb_settings_login(&session, accept_none_auth, rate_limit, &new_channel, force_none_auth, sd_auth_info)
  {
    var ret, sleep_value, login_res;
    var tmp_session;
    var port, pref_port, ssh_ports, found_ports;
    var supported_auth_method, supported_methods_str;
    var cred_index, cred_kb_index;
    var auth_method, auth_method_check;
    var extra, ret_recon_wrapper;
    var username, password;
    var cert, privatekey, passphrase;
    var kdc_hostname, kdc_port, kdc_realm, kdc_transport;
    var escl_type, escl_extra, root, sulogin, supass, supath;
    var rsa1_priv_key_cred_set = make_array();
    var fn = "try_ssh_kb_settings_login";
    var tmp_channel;
    var open_connection_failed = FALSE;
    var kex_failed = FALSE;
    var port_closed = FALSE;
    var msg, long_log, sh, login_check;
    var ok_to_send_password, ret_rl_none, rate_limited_device_ret;
    var custom_prompt, cred_type, credential_order;
    var kb_func = SSH_LIB_KB_PREFIX + fn;
    var auth_success_state, using_none_auth, sd_auth_info_log, sd_auth_info_entry, sd_auth_info_cnt;

    # Inherit 'host' value for open_connection() calls
    var host;
    if(!empty_or_null(session.remote_host))
      host = session.remote_host;
    # If we don't have a hostname, we want to only pass the port to open_connection()
    else
      host = NULL;

    # If we ran this function before and failed, return FALSE
    if(get_kb_item(kb_func + "_failed"))
    {
      dbg::detailed_log(lvl:1, src:fn, msg:'This function has previously failed.');
      return FALSE;
    }

    # If we ran this function before and were successful, just log in and return
    if(get_kb_item(kb_func + "_success"))
    {
      dbg::detailed_log(lvl:3, src:fn, msg:'This function has previously succeeded. Opening the connection.');
      session = new("sshlib::session");

      port = get_kb_item(SSH_LIB_KB_PREFIX + "verified_login_port");
      ret = session.open_connection(host:host, port:port);
      if(!ret)
      {
        extra = get_kb_args(kb_prefix:"Secret/" + SSH_LIB_KB_PREFIX + session.get_kb_connection_id() + "/login_extra");
        msg = "open_connection() failed on previously successful connection: " + last_error;
        set_kb_item(name:kb_func + "/error", value:msg);
        session.set_auth_failure_error(user:extra["username"], port:port, msg:msg);
        return FALSE;
      }

      ret = session.login();
      if(!ret)
      {
        extra = get_kb_args(kb_prefix:"Secret/" + SSH_LIB_KB_PREFIX + session.get_kb_connection_id() + "/login_extra");
        msg = "Authentication failed on previously successful connection: " + last_error;
        set_kb_item(name:kb_func + "/error", value:msg);
        session.set_auth_failure_error(user:extra["username"], port:port, msg:msg);
      }
      return ret;
    }

    # If no user-supplied SSH credentials are available, return FALSE
    if (
      empty_or_null(get_kb_item("Secret/SSH/password")) &&
      empty_or_null(get_kb_item("Secret/SSH/kdc_hostname")) &&
      empty_or_null(get_kb_item("Secret/SSH/privatekey"))
    )
    {
      if(!isnull(session))
        session.set_error(src:fn, err_msg:"No user-supplied SSH credential sets were found.");
      return FALSE;
    }

    # Build list of ssh_ports to try, preferred port should be first in list
    ssh_ports = make_list(22);
    pref_port = get_kb_item('Secret/SSH/PreferredPort');
    if (pref_port)
      ssh_ports = make_list(pref_port, ssh_ports);

    found_ports = get_kb_list("Services/ssh");
    if (found_ports)
      ssh_ports = make_list(ssh_ports, found_ports);

    foreach port (list_uniq(ssh_ports))
    {
      dbg::detailed_log(lvl:3, src:fn, msg:'Attempting to log in on port '+port+'.');
      # Skip known closed ports and respect unscanned ports settings
      if (!get_port_state(port) && !rate_limit)
      {
        dbg::detailed_log(lvl:1, src:fn, msg:'Port '+port+' is closed.');
        set_kb_item(name:kb_func + "/error", value:'Port '+port+' is closed.');
        port_closed = TRUE;
        continue;
      }
      else
      {
        port_closed = FALSE;
      }

      long_log =
        'Reminder: Credential index -1 corresponds to the first credential with '+
        'no numerical index, example SSH/username. 0 and onward refer to numerical indexed credentials, example SSH/0/username.';
      dbg::detailed_log(lvl:2, src:fn, msg:long_log);
      # Determine which credential sets have this target as a priority target
      credential_order = determine_credential_order();

      # Reset the log for each port so we only log failures on the port that had a success
      # or only log failures a single time instead of the number of time per port. Without
      # this we could log (number of ports * number of ssh creds) failures which could be confusing.
      if (sd_auth_info)
      {
        sd_auth_info_log = {"success":[], "failed":[]};
      }

      # Iterate through credentials in the KB
      # will terminate when no more usernames can be found in the kb
      foreach cred_index (credential_order)
      {
        cred_kb_index = kb_index(cred_index);
        dbg::detailed_log(lvl:3, src:fn, msg:'Attempting SSH credential set ' + cred_index);
        # Retrieve the username from the credential set
        username = get_kb_item("Secret/SSH"+cred_kb_index+"login");
        # The UI will not allow an SSH credential to be saved without a username
        # If there are no more credentials to try, exit loop
        if(!username)
        {
          if (cred_index >= 0)
            dbg::detailed_log(lvl:2, src:fn, msg:'All available credential sets have been tried.');
          else
            dbg::detailed_log(lvl:1, src:fn, msg:'No SSH credential sets were found.');
          break;
        }

        # Try 'none' auth
        dbg::detailed_log(lvl:3, src:fn, msg:'Creating new temporary session to test \'none\' authentication.');
        tmp_session = new("sshlib::session");

        # Open connection
        ret = open_connection_wrapper(session:tmp_session, fn:fn, host:host, port:port);
        # if we are in "rate limit" mode and the connection failed retry the connection.
        # reconnect on first credential set in case previous scan or manual connection
        # triggered rate limit failure.
        if(!ret && rate_limit)
        {
          if(cred_index == -1)
            sleep_value = 30; # first credential set sleep value
          else
            sleep_value = 65; # second+ credential set sleep value higher
          dbg::detailed_log(lvl:3, src:fn, msg:'Failed to open the initial SSH connection. sleeping '+sleep_value+' seconds.');
          sleep(sleep_value);
          ret_recon_wrapper = reconnect_wrapper(session:tmp_session, fn:fn, host:host, port:port);
          # reconnect failed so break out of credentials loop
          if(!ret_recon_wrapper)
          {
            dbg::detailed_log(
              lvl:1,
              src:fn,
              msg:'Error attempting session reconnect.',
              msg_details:{'Error':{'lvl':1, 'value':tmp_session.error}});

            set_kb_item(name:kb_func + "/error", value:"open_connection failed: " + last_error);
            open_connection_failed = TRUE;
            break;
          }
          # reconnect worked - continue with function
          else
          {
            dbg::detailed_log(lvl:2, src:fn, msg:'Successfully opened a connection on port '+port+'.');
            open_connection_failed = FALSE;
          }
        }
        # connection failed and we are NOT in "rate limit" mode
        else if(!ret)
        {
          dbg::detailed_log(
            lvl:1,
            src:fn,
            msg:'Error calling open_connection.',
            msg_details:{'Error':{'lvl':1, 'value':tmp_session.error}});

          set_kb_item(name:kb_func + "/error", value:"open_connection failed: " + last_error);
          open_connection_failed = TRUE;
          break;
        }
        else
        {
          dbg::detailed_log(lvl:2, src:fn, msg:'Successfully opened a connection on port '+port+'.');
          open_connection_failed = FALSE;
        }

        # Check for KEX errors
        if (!tmp_session.complete_kex())
        {
          dbg::detailed_log(lvl:1, src:fn, msg:'Error calling complete_kex().');
          set_kb_item(name:kb_func + "/error", value:last_error);
          kex_failed = TRUE;
          break;
        }
        else
        {
          kex_failed = FALSE;
        }

        # Determine authentication method and set ok_to_send_password to FALSE if we are using
        # non username/password authentication. This will prevent the rate_limit check from sending
        # the wrong password.
        password      = get_kb_item("Secret/SSH"+cred_kb_index+"password");
        kdc_hostname  = get_kb_item("Secret/SSH"+cred_kb_index+"kdc_hostname");
        custom_prompt = get_kb_item("SSH"+cred_kb_index+"custom_password_prompt");
        cred_type     = get_kb_item("SSH"+cred_kb_index+"cred_type");
        privatekey    = hex2raw(s:get_kb_item("Secret/SSH"+cred_kb_index+"privatekey"));
        ok_to_send_password = TRUE;
        # The order is important because gssapi also includes a password
        if (kdc_hostname)
          auth_method_check = "gssapi";
        else if(password)
          auth_method_check = "keyboard-interactive";
        else if(privatekey)
          auth_method_check = "publickey";
        else
          auth_method_check = "na";

        # Do not send password in rate_limit check for sonicwall devices if the cred set is non username/password
        if(auth_method_check != "keyboard-interactive")
          ok_to_send_password = FALSE;

        # Attempt 'none' authentication
        dbg::detailed_log(lvl:2, src:fn, msg:"Trying 'none' authentication.");
        login_res = tmp_session.login(
          method          : "none",
          extra           : make_array("username",username),
          save_login      : TRUE,
          force_none_auth : force_none_auth,
          cred_type       : cred_type
        );

        if (max_index(tmp_session.supported_auth_methods) > 0)
        {
          supported_methods_str = join(tmp_session.supported_auth_methods, sep:",");
          replace_kb_item(
            name :SSH_LIB_KB_PREFIX + tmp_session.get_kb_connection_id() + "/" + username + "/supported_login_methods",
            value:supported_methods_str
          );
        }
        # If the host accepted 'none' auth
        if(login_res)
        {
          dbg::detailed_log(lvl:2, src:fn, msg:'The \'none\' authentication method was accepted for user \''+username+'\'');
          # if accept_none_auth is true, break for success
          if(accept_none_auth)
          {
            using_none_auth = TRUE;

            dbg::detailed_log(lvl:2, src:fn, msg:'Using \'none\' authentication method.');
            # rate limit mode enabled and username/password auth is used so attempt to connect to sonicwall "none" auth
            if(rate_limit && ok_to_send_password)
            {
              sh = new("sshlib::sh_shell_handler_misc");
              ret_rl_none = sonicwall_none_auth(
                tmp_session : tmp_session,
                new_channel : new_channel,
                fn          : fn,
                cred_kb_index      : cred_kb_index,
                username    : username,
                host        : host,
                port        : port,
                sh          : sh
              );
              if(ret_rl_none == "break")
                break;
              else if(ret_rl_none == "continue")
                continue;
            }
            # if device is a Cisco Wireless LAN Controller (WLC) device
            else if (get_kb_item('Host/Cisco/WLC/none_auth'))
            {
              ret_rl_none = cisco_wlc_none_auth(
                session  : tmp_session,
                channel  : new_channel,
                fn       : fn,
                cred_kb_index   : cred_kb_index,
                username : username,
                host     : host,
                port     : port
              );
              if(ret_rl_none)
                break;
              else
                continue;
            }
            # rate_limit option not selected but "none" auth succeeded
            else
            {
              dbg::detailed_log(lvl:2, src:fn, msg:'Using \'none\' authentication method.');
              break;
            }
          }
          # if accept_none_auth is false, call tmp_session.clear_saved_login_info() and proceed to trying credentials
          else
          {
            using_none_auth = FALSE;
            dbg::detailed_log(lvl:2, src:fn, msg:'Not using \'none\' authentication method because \'accept_none_auth\' is FALSE.');
            tmp_session.clear_saved_login_info();
            # This tells session::login() that we've already been granted
            # the "ssh-userauth" service
            tmp_session.cur_state.set("USERAUTH_FAILURE");
          }
        }
        else
        {
          using_none_auth = FALSE;
          dbg::detailed_log(lvl:2, src:fn, msg:'The \'none\' authentication method was not accepted');
        }

        # Check socket state
        if(tmp_session.cur_state.val == "SOC_CLOSED")
        {
          dbg::detailed_log(lvl:1, src:fn, msg:'The socket has been closed. Trying next credential set.');
          continue;
        }

        # Determine authentication method
        # using KB items set before "none" auth section above
        # The order is important because gssapi also includes a password
        if (kdc_hostname)
          auth_method = "gssapi";
        else if(password)
          auth_method = "keyboard-interactive";
        else if (privatekey)
        {
          # If the private key is in RSA1 format, skip this credential set
          # RSA1 is only supported by SSHv1, this library only supports SSHv2
          if ('SSH PRIVATE KEY FILE FORMAT 1.1\n\0' >< privatekey)
          {
            long_log =
              'The private key type for credential set '+cred_index+
              ' is RSA1, which is only supported by SSHv1. This library only supports SSHv2. Trying next credential set.';
            dbg::detailed_log(lvl:1, src:fn, msg:long_log);
            rsa1_priv_key_cred_set[cred_index] = TRUE;
            tmp_session.close_connection();
            continue;
          }
          auth_method = "publickey";
        }
        else
        {
          long_log =
            'The authentication method was unable to be determined for credential set '+cred_index+
            '. Trying next credential set.';
          dbg::detailed_log(lvl:1, src:fn, msg:long_log);
          tmp_session.close_connection();

          if (sd_auth_info)
          {
            auth_method = "n/a";
            append_element(var:sd_auth_info_log.failed, value:{"username":username, "method":auth_method});
          }

          continue;
        }

        # Verify login method is supported
        if(auth_method == "keyboard-interactive")
        {
          if(!tmp_session.auth_method_supported(method:auth_method, username:username))
          {
            auth_method = "password";
            if(!tmp_session.auth_method_supported(method:auth_method, username:username))
            {
              long_log =
                'Neither "keyboard-interactive" nor "password" authentication methods for credential set '+cred_index+
                ' is supported. Trying next credential set.';
              dbg::detailed_log(lvl:3, src:fn, msg:long_log);
              tmp_session.close_connection();

              if (sd_auth_info)
              {
                append_element(var:sd_auth_info_log.failed, value:{"username":username, "method":auth_method});
              }

              continue;
            }
          }
        }
        else if(!tmp_session.auth_method_supported(method:auth_method, username:username))
        {
          long_log =
            'The authentication method "'+auth_method+'" for credential set '+cred_index+
            ' is not supported. Trying next credential set.';
          dbg::detailed_log(lvl:3, src:fn, msg:long_log);
          tmp_session.close_connection();

          if (sd_auth_info)
          {
            append_element(var:sd_auth_info_log.failed, value:{"username":username, "method":auth_method});
          }

          continue;
        }

        # Check socket state
        if(tmp_session.cur_state.val == "SOC_CLOSED")
        {
          dbg::detailed_log(lvl:1, src:fn, msg:'The socket has been closed. Trying next credential set.');

          if (sd_auth_info)
          {
            append_element(var:sd_auth_info_log.failed, value:{"username":username, "method":auth_method});
          }

          continue;
        }

        # Retrieve extra args from KB depending on auth method
        extra = make_array();
        extra["username"] = username;
        if(auth_method == "keyboard-interactive" || auth_method == "password")
        {
          extra["password"] = password;
          if(!isnull(custom_prompt))
            extra["custom_prompt"] = custom_prompt;
        }
        else if (auth_method == "gssapi")
        {
          kdc_realm = get_kb_item("Kerberos/SSH"+cred_kb_index+"realm");

          extra["password"] = password;
          extra["realm"]    = kdc_realm;

          # Settings used by engine function nasl_open_sock_ex()
          # These should be removed if login fails
          replace_kb_item(name:"Secret/SSH/kdc_hostname", value:kdc_hostname);

          kdc_port = get_kb_item("Secret/SSH"+cred_kb_index+"kdc_port");
          replace_kb_item(name:"Secret/SSH/kdc_port", value:kdc_port);

          if(get_kb_item("Kerberos/SSH"+cred_kb_index+"kdc_use_tcp"))
            replace_kb_item(name:"Kerberos/SSH/kdc_use_tcp", value:TRUE);
        }
        else if (auth_method == "publickey")
        {
          cert = get_kb_item("Secret/SSH"+cred_kb_index+"certificate");
          passphrase = get_kb_item("Secret/SSH"+cred_kb_index+"passphrase");

          extra["privatekey"]   = privatekey;
          if(!isnull(passphrase))
            extra["passphrase"] = passphrase;
          if(!isnull(cert))
            extra["cert"]       = cert;
        }

        # Attempt login
        login_res = tmp_session.login(method:auth_method, extra:extra, save_login:TRUE, cred_type:cred_type);

        # If auth failed with keyboard-interactive but password auth is also
        # supported, try password auth
        if(!login_res && auth_method == "keyboard-interactive" &&
           tmp_session.cur_state.val != "SOC_CLOSED" &&
           tmp_session.auth_method_supported(method:"password", username:username))
        {
          dbg::detailed_log(
            lvl:2,
            src:fn,
            msg:'Login failed for keyboard-interactive authentication with credential set '+cred_index+
                ' on port '+port+'. Trying password authentication.',
            msg_details:{"Error": {"lvl":2, "value": tmp_session.error}});

          auth_method = "password";
          login_res = tmp_session.login(method:auth_method, extra:extra, save_login:TRUE, cred_type:cred_type);
        }

        # if login is successful and "rate limit" mode is enabled attempt to identify and
        # authenticate to junos or sonicwall device. Using non-none authentication methods.
        if(login_res && rate_limit)
        {
          sh = new("sshlib::sh_shell_handler_misc");
          rate_limited_device_ret = rate_limited_device_auth(
            tmp_session : tmp_session,
            new_channel : new_channel,
            username    : username,
            host        : host,
            port        : port,
            sh          : sh
          );

          if(!rate_limited_device_ret)
            login_res = FALSE;
        }

        # When pubkey authentication is used with AWS instances, an
        # authentication attempt appears successful, but really isn't.
        # This also catches other post-login errors such as password
        # expiration.
        if(login_res && !IS_SONICWALL && !IS_JUNOS && !IS_AOS &&
           !get_one_kb_item(SSH_LIB_KB_PREFIX + 'known_ssh_confirm_prompt'))
        {
          dbg::detailed_log(lvl:3, src:fn, msg:'Opening a channel to check for post-login errors.');
          tmp_channel = tmp_session.get_channel();

          if(tmp_channel)
          {
            tmp_channel.make_request(type:"shell", want_reply:FALSE);
            var cb = @client_cb_post_login_error;
            tmp_session.sshrecv_until(channel:tmp_channel, check_callback:cb, cmd_timeout:10);

            if(tmp_session.cur_state.val == "SOC_CLOSED")
            {
              # If the response to the error shell request is a closed connection, reopen it.
              dbg::detailed_log(
                lvl:3,
                src:fn,
                msg:'client_cb_post_login_error caused a connection close. Reopening connection.'
              );

              if(reconnect_wrapper(session:tmp_session, fn:fn, host:host, port:port))
              {
                # reconnect successful
                login_res = tmp_session.login(method:auth_method, extra:extra, save_login:TRUE, cred_type:cred_type);
              }
              else
              {
                # reconnect failed
                dbg::detailed_log(
                  lvl:3,
                  src:fn,
                  msg:'Unable to re-establish connection after post-login error check. Trying next credential set.'
                );
                tmp_session.clear_saved_login_info();
                tmp_session.close_connection();
                login_res = FALSE;
              }
            }
            if(tmp_session.post_login_error)
            {
              var login_error = tmp_channel.stderr;
              if (!login_error)
                login_error = tmp_channel.data_buf;

              replace_kb_item(name:SSH_LIB_KB_PREFIX + "disallowed_login_id", value:TRUE);
              if(login_error)
                set_kb_item(name:SSH_LIB_KB_PREFIX + "disallowed_login_id" + "/error", value:login_error);

              msg = "Login failed after authentication: " + login_error;
              set_kb_item(name:kb_func + "/error", value:msg);
              tmp_session.set_auth_failure_error(user:extra["username"], port:port, msg:msg);

              if(tmp_session.cur_state.val == "SOC_CLOSED")
                dbg::detailed_log(lvl:3, src:fn, msg:'The socket has been closed. Trying next credential set.');
              else
                dbg::detailed_log(
                  lvl:3,
                  src:fn,
                  msg:'Login failed with credential set '+cred_index+' on port '+port+'. Trying next credentials set.',
                  msg_details:{"Error": {"lvl":2, "value": tmp_session.error}}
                );

              tmp_session.clear_saved_login_info();
              tmp_session.close_connection();
              set_support_level(level: SSH_LIB_LOGIN_ERROR);
              login_res = FALSE;
            }
            tmp_channel.close();

            if(!isnull(tmp_session.channel_manager))
              tmp_session.channel_manager.remove_channel(channel:tmp_channel);
          }
        }
        # If login failed, close the session and continue looping through credentials
        if(!login_res)
        {
          if(tmp_session.cur_state.val == "SOC_CLOSED")
            dbg::detailed_log(lvl:2, src:fn, msg:'The socket has been closed. Trying next credential set.');
          else
            dbg::detailed_log(
              lvl:2,
              src:fn,
              msg:'Login failed with credential set '+cred_index+' on port '+port+'. Trying next credentials set.',
              msg_details:{"Error": {"lvl":2, "value": tmp_session.error}}
            );

          if (auth_method == "gssapi")
          {
            rm_kb_item(name:"Secret/SSH/kdc_hostname");
            rm_kb_item(name:"Secret/SSH/kdc_port");
            rm_kb_item(name:"Kerberos/SSH/kdc_use_tcp");
          }

          tmp_session.close_connection();
          # sleep a few seconds if rate limited option is passed.
          # sonicwall needs time after the connection closes to register that the connection is closed
          if(rate_limit)
            sleep(3);

          if (sd_auth_info)
          {
            append_element(var:sd_auth_info_log.failed, value:{"username":username, "method":auth_method});
          }

          continue;
        }

        # Login succeeded
        dbg::detailed_log(lvl:1, src:fn, msg:'Login succeeded for credential set '+cred_index+' on port '+port+'.');

        if (sd_auth_info)
        {
          if (using_none_auth)
            append_element(var:sd_auth_info_log.success, value:{"username":username, "method":'SSH none' });
          else
            append_element(var:sd_auth_info_log.success, value:{"username":username, "method":auth_method});
        }

        # Set Port here to escape a race condition in service detection between other plugins
        # that run at the same time. This is needed in cases where the syn scanner for some reason fails to
        # detection port ssh on port 22 at least or some other potentially custom port.
        replace_kb_item(name:'Ports/tcp/'+port, value:TRUE);

        # Store escalation settings
        escl_type = get_kb_item("Secret/SSH"+cred_kb_index+"sudo_method");

        if (escl_type == "Nothing" || escl_type == "none")
        {
          dbg::detailed_log(lvl:3, src:fn, msg:'No privilege escalation configured.');
          escl_type = NULL;
        }
        else if(get_kb_item("Secret/SSH"+cred_kb_index+"sudo"))
        {
          sulogin   = get_kb_item("Secret/SSH"+cred_kb_index+"su-login");
          supass    = get_kb_item("Secret/SSH"+cred_kb_index+"sudo-password");
          supath    = get_kb_item("Secret/SSH"+cred_kb_index+"sudo_path");
          root      = get_kb_item("Secret/SSH"+cred_kb_index+"root");
          if (isnull(supath))
            supath = "";

          escl_extra = make_array();

          if(escl_type == "su")
          {
            escl_extra["su_user"] = root;
            escl_extra["su_pass"] = supass;
            escl_extra["su_dir"]  = supath;
          }
          else if(escl_type == "sudo")
          {
            escl_extra["sudo_user"] = root;
            escl_extra["sudo_pass"] = supass;
            escl_extra["sudo_dir"]  = supath;
          }
          else if (escl_type == "su+sudo")
          {
            escl_type = "su_sudo";
            escl_extra["su_user"]   = sulogin;
            escl_extra["su_pass"]   = supass;
            escl_extra["su_dir"]    = supath;
            escl_extra["sudo_user"] = root;
            escl_extra["sudo_dir"]  = supath;
            escl_extra["sudo_pass"] = supass;
          }
          else if(escl_type == "pbrun")
          {
            escl_extra["pbrun_user"] = root;
            escl_extra["pbrun_pass"] = supass;
            escl_extra["pbrun_dir"]  = supath;
          }
          else if(escl_type == "dzdo")
          {
            escl_extra["dzdo_user"] = root;
            escl_extra["dzdo_pass"] = supass;
            escl_extra["dzdo_dir"]  = supath;
          }
          else
          {
            escl_type = NULL;
            dbg::detailed_log(lvl:1, src:fn, msg:'Unknown escalation type '+escl_type+'.');
          }
        } # End escalation settings

        # looking at enable-admin escalataions that don't support sudo
        else if(escl_type == "Cisco 'enable'")
        {
          escl_type = "cisco_enable";

          # extra array does not exist, create it
          if(isnull(escl_extra))
            escl_extra = {};

          # add enable-pass to the extra array, it will be sent
          # to shell handler using set_priv_escalation later
          escl_extra["enable_pass"] = get_kb_item("Secret/SSH"+cred_kb_index+"enable-password");
        }

        # looking at expert mode escalation
        else if(escl_type == "Checkpoint Gaia 'expert'")
        {
          escl_type = "gaia_expert";

          # extra array does not exist, create it
          if(isnull(escl_extra))
            escl_extra = make_array();

          # add expert-pass to the extra array, it will be sent
          # to shell handler using set_priv_escalation later
          escl_extra["expert_pass"] = get_kb_item("Secret/SSH"+cred_kb_index+"expert-password");
        }

        # Break out of credentials loop
        break;

      } # End credentials loop

      # If we were able to log in successfully, break out of ports loop
      if(login_res)
        break;

    } # End ports loop


    if (sd_auth_info)
    {
      sd_auth_info_cnt = 0;
      foreach sd_auth_info_entry (sd_auth_info_log.success)
      {
        sd_auth_info.insert_auth_status(auth_type:"SSH", user_id:sd_auth_info_entry.username, method:sd_auth_info_entry.method, status:sd_auth_info.SUCCESS);
        sd_auth_info_cnt++;
      }

      foreach sd_auth_info_entry (sd_auth_info_log.failed)
      {
        sd_auth_info.insert_auth_status(auth_type:"SSH", user_id:sd_auth_info_entry.username, method:sd_auth_info_entry.method, status:sd_auth_info.FAILED);
        sd_auth_info_cnt++;
      }

      # We don't want to report if there are no success or failures
      if (sd_auth_info_cnt > 0)
      {
        sd_auth_info.report_internal();
      }

      dbg::detailed_log(lvl:1, src:fn, msg:'structured_data_authentication_status_information logging added.');
    }
    else
    {
      dbg::detailed_log(lvl:1, src:fn, msg:'structured_data_authentication_status_information logging NOT enabled.');
    }

    # If we were able to log in, save settings
    if(login_res && !tmp_session.post_login_error)
    {
      session = tmp_session;

      replace_kb_item(name:SSH_LIB_KB_PREFIX + fn + "_success", value:TRUE);
      replace_kb_item(name:SSH_LIB_KB_PREFIX + "verified_login_port", value:port);

      if(escl_type)
        session.save_escalation_info(type:escl_type, args:escl_extra);

      replace_kb_item(name:"Host/Auth/SSH/" + port + "/Success", value:username);
      lcx::log_auth_success(proto:lcx::PROTO_SSH, port:port, user:username, clear_failures:TRUE);

      auth_success_state = TRUE;
    }

    # Otherwise, note the failure in the KB and return FALSE
    else
    {
      replace_kb_item(name:SSH_LIB_KB_PREFIX + fn + "_failed", value:TRUE);
      if (!open_connection_failed && !kex_failed && !port_closed)
        set_kb_item(name:kb_func + "/error", value:"No supplied credential sets succeeded on any of the ssh ports");

      auth_success_state = FALSE;
    }


    return auth_success_state;
  }

  ##
  # Retrieves all keys and values in the KB stored under the supplied
  # prefix as a dictionary.
  #
  # @param [kb_prefix:string] String prefix of KB keys to read. Without the trailing ``/*``.
  #
  # @return [array] Dictionary of KB keys and values.
  ##
  function get_kb_args(kb_prefix)
  {
    var extra, tmp_list, key, val;
    extra = make_array();

    tmp_list = get_kb_list(kb_prefix + "/*");

    foreach key (keys(tmp_list))
    {
      val = tmp_list[key];
      key -= (kb_prefix + "/");
      extra[key] = val;
    }
    return extra;
  }


  ##
  # Iterates through a dictionary of keys and values saving them in the KB.
  #
  # @param [kb_prefix:string] First part of key to save under, without the trailing ``/``.
  # @param [args:array] Dictionary of keys/values to save in the KB.
  ##
  function save_kb_args(kb_prefix, args)
  {
    var key;
    foreach key (keys(args))
    {
      if(isnull(get_kb_item(kb_prefix + "/" + key)))
        if(!isnull(args[key]))
          set_kb_item(name:kb_prefix + "/" + key, value:args[key]);
    }

    return NULL;
  }

  ##
  # Return the shell handler object name stored in the KB.
  #
  # @return [string] String object name.
  ##
  function get_kb_shell_handler()
  {
    var handler;
    var fn = 'get_kb_shell_handler';
    var handler_string = get_kb_item(SSH_LIB_KB_PREFIX + 'shell_handler');
    if (isnull(handler_string))
      handler_string = 'sshlib::sh_shell_handler';
    handler = new(handler_string);
    return handler;
  }

  ##
  # Sets the current SSH library support level to indicate that local checks are supported.
  #
  # @remark
  # This function should only be called after running a command and its output has been somewhat validated.
  ##
  function enable_local_checks()
  {
    replace_kb_item(name:'Host/local_checks_enabled', value: TRUE);
    replace_kb_item(name:'debug/Host/local_checks_enabled_source/includes/ssh_lib.static', value: 5650);

    if (defined_func('report_xml_tag'))
      report_xml_tag(tag:"Credentialed_Scan", value:"true");

    if(!info_t || info_t == INFO_SSH)
    {
      replace_kb_item(name:SSH_LIB_KB_PREFIX + "sshlib_local_checks", value:TRUE);
      set_support_level(level:SSH_LIB_SUPPORTS_LOCAL_CHECKS);
    }

    return NULL;
  }

  ##
  # Sets the current SSH library support level to the 'level' parameter
  # both in the KB and as a global variable.
  #
  # @param [level:integer] SSH library support level.
  #
  # @remark
  # Valid levels are defined in `ssh_lib_util.static`_, e.g. ``sshlib::SSH_LIB_SUPPORTS_LOCAL_CHECKS``.
  ##
  function set_support_level(level)
  {
    HOST_SUPPORT_LEVEL = level;
    if(!info_t || info_t == INFO_SSH)
      replace_kb_item(name:SSH_LIB_KB_PREFIX + "support_level", value:level);

    return NULL;
  }

  ##
  # Retrieves the current SSH library support level.
  #
  # @return [integer] Integer value of current SSH support level.
  #
  # @remark
  # Valid levels are defined in `ssh_lib_util.static`_, e.g. ``sshlib::SSH_LIB_SUPPORTS_LOCAL_CHECKS``.
  # And the value returned by this function is the one stored in the KB, not the global variable.
  ##
  function get_support_level()
  {
    return get_kb_item(SSH_LIB_KB_PREFIX + "support_level");
  }

  ##
  # Retrieves the status of local checks.
  #
  # @return [boolean|NULL] TRUE if local checks are enabled, NULL otherwise.
  ##
  function local_checks_enabled()
  {
    return get_kb_item(SSH_LIB_KB_PREFIX + "sshlib_local_checks");
  }

  ##
  # Retrieves the SSH client version of the target host.
  #
  # @return [string] SSH client version string
  ##
  function get_ssh_client_ver()
  {
    var ver = get_kb_item("SSH/clientver");
    if(!empty_or_null(ver))
      ver = "SSH-2.0-" + ver;
    else
      ver = "SSH-2.0-" + default_local_version;

    return ver;
  }

  ##
  # Retrieves the SSH listening port of the target host.
  #
  # @return [integer] The SSH port.
  ##
  function kb_ssh_transport()
  {
    var port, pref, ssh_ports;

    port = get_kb_item(SSH_LIB_KB_PREFIX + "verified_login_port");
    if(port)
      return port;

    pref = get_kb_item("Secret/SSH/PreferredPort");
    ssh_ports = get_kb_list("Services/ssh");
    if(!isnull(ssh_ports))
    {
      ssh_ports = make_list(ssh_ports);

      # Try to use the PreferredPort (if specified)
      if (pref > 0)
      {
        foreach port (ssh_ports)
        {
          if (port == pref)
            return port;
        }
      }

      # Try to use port 22
      foreach port (ssh_ports)
      {
        if (port == 22)
          return port;
      }

      # Otherwise, use the first port available
      port = ssh_ports[0];
      if (port)
        return port;
    }

    if ( pref && get_port_state(pref) )
      return pref;
    return 22; #Default
  }

  ##
  # Wrapper for `sshlib::Channel.usable_for_shell_command()`_ that handles input
  # validation and error generation, for use by other objects and
  # functions outside Channel.
  #
  # @param [channel:object]     A channel object.
  # @param [nosetup_ok:boolean] TRUE if NOSETUP shell is ok.
  #
  # @return [boolean] TRUE if channel is usable, FALSE otherwise.
  #
  # @nessus 6.0
  ##
  function channel_usable_for_shell_command(&channel, nosetup_ok)
  {
    if (nosetup_ok && channel == NOSETUP)
      return TRUE;
    if (!isnull(channel) && channel.usable_for_shell_command())
      return TRUE;
    return FALSE;
  }

  ##
  # Wrapper for `sshlib::session.replace_shell()`_ that handles input validation
  # and error generation, for use by other objects and functions
  # outside session.
  #
  # @param [session:object] An sshlib session object, used for reconnection if necessary (passed by reference).
  # @param [channel:object] A channel object for the passed session (passed by reference).
  #
  # @return [boolean] TRUE if channel is ok or replaced successfully, FALSE otherwise.
  ##
  function session_replace_shell(&session, &channel)
  {
    # Call session.replace_shell() using session passed as a reference,
    # not channel.session
    if (!session)
    {
      session.set_error(
        src     : FUNCTION_NAME,
        err_msg : 'The passed channel is NULL or unusable, but a session object ' +
                  'was not passed. Unable to replace shell.'
      );
      return FALSE;
    }
    if (session.replace_shell(channel:channel))
      return TRUE;

    return FALSE;
  }
}
