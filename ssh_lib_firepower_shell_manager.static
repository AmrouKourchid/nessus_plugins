#TRUSTED 8620e5a3033074f81188e021248d05b2c0c025f678be239bd6301979aee9dfd1f98619a3f4fd814fce80437614c7d94eccb585d731e45907156711dc58565e7ae04514470106cc2fa01c569c9d5b1f485228fd8d0e52f978a7b34c2f481abd671d680b5bce1410c73b798c650bd596928c5a056d37c848603cac30e1acbd5917a8a283ffe656c15cef2cc0295e0ab4465bf0e925dbbc022760333a203857f2a4f0257a639b000b9837aa55d18af85dacc1bec027a2eb4065b7fcadafa0a135766f42aaaec6c4e5fa21eb8aeb8ca19b6ab6b7efe814d576ee45e27a188a08304be41bad2593ecf8f30e24578b86991015dc41bdeda1d4295f0512c2ee220f85630985a631b638978c495ed019a5699307bbe6f4a5a1786b8ae6397f9b91b4e2a22237413edf50a5cddf224a889bb04f1d2d8eb2dcc9a79e51c07f5ac7e961ace36d4866d23be6a665b7116622d283fc6058a5ca45f9176739d7f925a1c2967bd3022810517adf0aa9a6e56b68e2afc02368b69dc9683d094efdf3a3e60aa44ab388bf796f87ad2a74ee31ef0788c84320c03599176efb7138a6aec8c13118fbf4af41cec7904cfb103406e45b768157b73f4bc20b0ca69d9f667f8f757e0756ec5813acdbbdc1238dd4eab984564f7e27813aa62d528cebb52074bee241526316456cb18bfcd1bd8120525bd089abc12e9f521b44183f7926598c8e5b02659a9e
#TRUST-RSA-SHA256 15dc523eb4228d107234a9e76e496af36ca50c25ba6d0695bee7a8619aef54de4d2a1f39a15966bbe9b7c31d15f0d2f14c466694a5d062699d2a63cd9bd9a82fecf4b49533c281f875d018129f5406784d78fd0a8d63f403d00b4d961c1d4ce7b7755ad578661c5af8a5b6c8542d7f808e2d1d761f36572820502761784581555e4eabdb71390fdd004eb96fa1e52f8589efc945cad152d71f1323816594234b41789715a77a7329a3e16e1697760013926cfa8b2b74faf022711a3b6123d347b5b74f09a8da39db48872fb1cd6bfbe2279e6e62793fc4de188a04ec620dc9e6180920476bb14e22dcfaa140b1408fbc041ce4e8117ea7759b735f19d3021244c9cf6d7b3d47f1dc93cb7771e325db23250b0aad0e2d29cdafd84cd5cbaa51aa230b2cab8da635224a4dcc87b0ebf3ae494599ce4124c06dced817b1794e5b508ab97a682d0671bfd8087d1de2bcdb89205c9c8b8cd88128f73b25f90fe22e8f8d4fec54b423f2c6784380cf75fd45bcdef63265500b933d64ddfd95e69d453fe967fddb0b438f4fa8f827a76d6f0958e1c13bd2d60373cc7acc959ce4e3bcb821099fe2b76617b2bb228afcd34eecb51127ae3e0e31c782a5532dd6cd72bdc980b343a4e267062fe90bb15ca5f111d45eecf5b10bfad05fe9cf282e84c3e05380258efdf17ed2526e91c8306f92c7eae55f54ebee6877838e4f2252774d9a3e
###
# (C) Tenable Network Security, Inc.
#
# This script is released under one of the Tenable Script Licenses and may not
# be used from within scripts released under another license without the
# authorization from Tenable Network Security Inc.
#
# @NOGPL@
#
# Revision: 1.21
#
# This shell handler is more of a wrapper around the basic shell handler.
# The idea is that the handler will manage a stack of layers that the shell
# can be in; what layer it entered at, what layer it is in, how to change
# between the layers.
#
# The handler will obtain a specified shell, and remain at that shell for
# future calls.
#
# A revert() was added to be able to revert to the original entry shell.
#
# A close() is included to properly revert and close the channel.  This does
# not appear to be necessary, but provided to give a better close out in the
# session.  The technical challenge of using a desconstructor is the required
# access to 'channel'.
#
###

namespace sshlib
{
  global_var _FP_SH_DEFAULT_INACTIVITY_TIMEOUT = 60;
  global_var _FP_SH_INITIAL_INACTIVITY_TIMEOUT = 5;

  ##
  # Firepower shells
  ##
  var FP_SH_CHASSIS = 'Firepower_FX-OS';
  var FP_SH_MODULE  = 'Firepower_bootCLI';
  var FP_SH_FTD     = 'Firepower_FTD_App';
  var FP_SH_EXPERT  = 'Firepower_expert';

  ##
  # callback function that checks to see if module has been
  # successfully entered
  #
  # @param session session handle for ssh session
  # @param channel channel for ssh session
  #
  # @return TRUE if timeout reached
  # @category SSH
  ##
  function cb_fp_sh_entered_module_or_timeout(&session, &channel)
  {
    if(!channel.shell_handler) return channel_closed_return_true(channel:channel);
    return channel.shell_handler.cb_entered_module_or_timeout(channel:channel);
  }

  ##
  # callback function that checks to see if ftd has been
  # successfully entered
  #
  # @param session session handle for ssh session
  # @param channel channel for ssh session
  #
  # @return TRUE if timeout reached
  # @category SSH
  ##
  function cb_fp_sh_entered_ftd_or_timeout(&session, &channel)
  {
    if(!channel.shell_handler) return channel_closed_return_true(channel:channel);
    return channel.shell_handler.cb_entered_ftd_or_timeout(channel:channel);
  }

  ##
  # callback function that checks to see if expert mode has been
  # successfully entered
  #
  # @param session session handle for ssh session
  # @param channel channel for ssh session
  #
  # @return TRUE if timeout reached
  # @category SSH
  ##
  function cb_fp_sh_entered_expert_or_timeout(&session, &channel)
  {
    if(!channel.shell_handler) return channel_closed_return_true(channel:channel);
    return channel.shell_handler.cb_entered_expert_or_timeout(channel:channel);
  }

  # Firepower shell manager, handles 3 firepower shells and switching
  # between them while wrapping basic_shell_handler to run commands
  object firepower_shell_manager : sshlib::basic_shell_handler
  {
    var objname = 'firepower_shell_manager::';
    var default_shell;
    var last_shell_used;
    var last_module_used;
    var cmd_prompts = {};
    var kb_cmd_prompts = {};
    var kb_id;

    ##
    # Shell that channel is currently in
    ##
    var current_shell;

    # Shell handler initialization caller
    # @category SSH
    ##
    function firepower_shell_manager()
    {
      this.init();

      this.kb_cmd_prompts[FP_SH_CHASSIS] = '/fp_cmd_prompt_chassis';
      this.kb_cmd_prompts[FP_SH_MODULE] = '/fp_cmd_prompt_module';
      this.kb_cmd_prompts[FP_SH_FTD] = '/fp_cmd_prompt_ftd';
      this.kb_cmd_prompts[FP_SH_EXPERT] = '/fp_cmd_prompt_expert';

      this.initial_prompt_timeout_count = get_kb_item(SSH_LIB_KB_PREFIX + "cmd_prompt_timeouts");
    }

    ##
    # Initialize cmd_prompts from KB
    # @category SSH
    ##
    function get_cmd_prompts()
    {
      var key, module, modules, val;
      foreach var layer ([FP_SH_CHASSIS, FP_SH_MODULE, FP_SH_FTD, FP_SH_EXPERT])
      {
        key = this.kb_id + this.kb_cmd_prompts[layer];
        this.cmd_prompts[layer] = get_kb_blob(this.kb_id + this.kb_cmd_prompts[layer]);
        modules = get_kb_blob_list(key + '/*');
        foreach module (keys(modules))
        {
          val = modules[module];
          module -= key + '/';
          this.cmd_prompts[layer + module] = val;
        }
      }
    }

    ##
    # Set a command prompt in the KB
    # @param layer Shell layer
    # @param module Module number if applicable
    # @param cmd_prompt Command prompt to set
    # @category SSH
    ##
    function set_fp_cmd_prompt(layer, module, cmd_prompt)
    {
      this.cmd_prompts[layer + module] = cmd_prompt;
      var key = this.kb_id + this.kb_cmd_prompts[layer];
      if (!isnull(module)) key += '/' + module;
      return replace_kb_blob(name:key, value:cmd_prompt);
    }

    ##
    # Get a command prompt from the KB
    # @param layer Shell layer
    # @param module Module number if applicable
    # @param cmd_prompt Command prompt to set
    # @category SSH
    ##
    function get_fp_cmd_prompt(layer, module)
    {
      if (this.cmd_prompts[layer + module])
        return this.cmd_prompts[layer + module];
      var key = this.kb_id + this.kb_cmd_prompts[layer];
      if (!isnull(module)) key += '/' + module;
      return get_kb_blob(key);
    }

    ##
    # callback function that checks to see if module has been
    # successfully entered
    #
    # @param channel channel for ssh session
    #
    # @return TRUE if timeout reached
    # @category SSH
    ##
    public function cb_entered_module_or_timeout(&channel)
    {
      var fn = objname + FUNCTION_NAME;
      var session = channel.session;

      if ("Cisco Security Services Platform" >< channel.data_buf)
      {
        this.current_shell = FP_SH_MODULE;
        return TRUE;
      }
      else if ("No connectivity to module" >< channel.data_buf)
      {
        dbg::detailed_log(lvl:1, src:fn, msg:'No connectivity to module.');
        return TRUE;
      }

      return this.check_inactivity_timeout(channel:channel);
    }

    ##
    # callback function that checks to see if ftd has been
    # successfully entered
    #
    # @param channel channel for ssh session
    #
    # @return TRUE if timeout reached
    # @category SSH
    ##
    public function cb_entered_ftd_or_timeout(&channel)
    {
      ### needed for 9300 when slot has no FTD
      if ("ftd is not running." >< channel.data_buf)
      {
        dbg::detailed_log(lvl:1, src:FUNCTION_NAME, msg:'FTD not running.  Unable to connect.');
        # Return TRUE to stop looping and receiving
        return TRUE;
      }
      if ("enter exit to return to bootCLI" >< channel.data_buf)
      {
        this.current_shell = FP_SH_FTD;
        return TRUE;
      }
      return this.check_inactivity_timeout(channel:channel);
    }

    ##
    # callback function that checks to see if expert has been
    # successfully entered
    #
    # @param channel channel for ssh session
    #
    # @return TRUE if timeout reached
    # @category SSH
    ##
    public function cb_entered_expert_or_timeout(&channel)
    {
      if (":~$" >< channel.data_buf)
      {
        this.current_shell = FP_SH_EXPERT;
        return TRUE;
      }

      if ('\x07' >< channel.data_buf)
      {
        dbg::detailed_log(lvl:1, src:FUNCTION_NAME, msg:"Failed to enter expert mode due to insufficient privileges");
        return TRUE;
      }
      return this.check_inactivity_timeout(channel:channel);
    }

    ##
    # Opens a new shell and runs "show version" to determine the
    # default shell
    #
    # @param channel channel for ssh session
    # @param cmd_timeout_min The total number of seconds that may elapse
    #                      waiting for the command response. (optional)
    # @param inactivity_timeout_min The number of seconds that may
    #                             elapse with no data received from
    #                             the target. (optional)
    # @param init bool set to FALSE to NOT set the default shell, defaults to TRUE if NULL
    #
    # @return TRUE if successful, FALSE otherwise
    ##
    public function determine_firepower_shell(&channel, cmd_timeout_min,
        inactivity_timeout_min, init)
    {
      if (isnull(init))
        init = TRUE;

      var fn = objname + FUNCTION_NAME;
      var session = channel.session;
      if (!this.kb_id)
        this.kb_id = SSH_LIB_KB_PREFIX + session.get_kb_connection_id();
      dbg::detailed_log(lvl:3, src:fn, msg:'Running "show version" to determine the Firepower shell.');
      var res = super.run_command(
        command                : "show version",
        channel                : channel,
        cmd_timeout_min        : cmd_timeout_min,
        inactivity_timeout_min : inactivity_timeout_min);
      if (!res)
      {
        dbg::detailed_log(lvl:1, src:fn,
          msg:'The shell does not appear to be a Firepower shell because command "show version" failed to return results.');
        return FALSE;
      }

      if ('Version:' >< res && 'Startup-Vers:' >< res)
      {
        this._set_shell_values(shell: channel.shell_handler, layer: FP_SH_CHASSIS, init: init);
      }
      else if ('Image type' >< res && 'Key Version' >< res)
      {
        this._set_shell_values(shell: channel.shell_handler, layer: FP_SH_MODULE, init: init);
      }
      else if ('Threat Defense' >< res || 'VDB version' >< res)
      {
        this._set_shell_values(shell: channel.shell_handler, layer: FP_SH_FTD, init: init);
      }
      else
      {
        dbg::detailed_log(lvl:1, src:fn, msg:'The shell does not appear to be a Firepower shell',
          msg_details:{'"show version" Result':{"lvl":1, "value":res}});
        return FALSE;
      }

      if (init)
      {
        dbg::detailed_log(lvl:2, src:fn, msg:'Setting default shell to: ' + this.default_shell);
        replace_kb_item(name:this.kb_id + '/Firepower/default_shell', value:this.default_shell);
        replace_kb_item(name:this.kb_id + '/Firepower/default_shell/showver', value:res);
      }
      return TRUE;
    }

    ##
    # Helper function to set the default values for the identified shell.
    #
    # @param layer name of shell to use
    # @param shell shell handler object
    # @param init bool set to FALSE to NOT set the default shell, defaults to TRUE if NULL
    #
    # @return TRUE if successful, FALSE otherwise
    ##
    protected function _set_shell_values(layer, shell, init)
    {
      if (isnull(layer))
        return FALSE;

      if (isnull(shell) && isnull(this.cmd_prompts[layer]))
        return FALSE;

      if (isnull(init))
        init = TRUE;

      this.current_shell = layer;
      if (shell) this.cmd_prompts[layer] = shell.cmd_prompt;
      if (!get_kb_item(this.kb_id + this.kb_cmd_prompts[layer]))
        set_kb_blob(name:this.kb_id + this.kb_cmd_prompts[layer], value:this.cmd_prompts[layer]);
      if (init)
      {
        this.default_shell = layer;
        this.last_shell_used = this.default_shell;
      }
      else
        this.last_shell_used = this.current_shell;

      return TRUE;
    }

    ##
    # Switches the shell handler between the different posible shells
    #
    # @param channel channel for ssh session
    # @param source  The source shell changing from
    # @param destination  The destination shell changing to
    # @param module  The module number associated with the destination (if applicable)
    # @param command The command to use to change the shell (optional, default 'exit')
    # @param callback The callback function to use (optional, default @basic_shell_handler_at_prompt3_or_timeout)
    #
    # @return TRUE if successful, FALSE otherwise
    ##
    protected function _change_shell_layer(&channel, source, destination, module, command, callback)
    {
      var fn = objname + FUNCTION_NAME;
      var session = channel.session;
      var msg = NULL;
      var default_callback = FALSE;

      # verify the environment is setup as needed
      if (this.current_shell != source)
      {
        dbg::detailed_log(lvl:1, src:fn, msg:'Current shell is not "' + source + '".');
        return FALSE;
      }

      if (isnull(command))
      {
        dbg::detailed_log(lvl:1, src:fn, msg:'No command provided.');
        return FALSE;
      }

      if (!channel_usable_for_shell_command(channel:channel))
        return FALSE;

      if (isnull(callback))
      {
        dbg::detailed_log(lvl:3, src:fn, msg:'Using default callback.');
        default_callback = TRUE;
        callback = @basic_shell_handler_at_prompt3_or_timeout;
      }

      dbg::detailed_log(lvl:3, src:fn, msg:'Changing "' + source + '" to "' + destination + '".');
      dbg::detailed_log(lvl:1, src:fn, msg:'command: ' + command);

      # Null out and set the cmd prompt if known
      var orig_cmd_prompt = this.cmd_prompt;
      this.cmd_prompt = this.get_fp_cmd_prompt(layer:destination, module:module);
      var check_len = 3;
      if (this.cmd_prompt)
      {
        if (strlen(this.cmd_prompt) < 3) check_len = strlen(this.cmd_prompt);
        dbg::detailed_log(lvl:2, src:fn, msg:'Expecting command prompt: ' + this.cmd_prompt);
      }

      # run command to get change layer
      channel.clear_data_buf();
      channel.window_send_data(data:command + '\n');
      this.timeout_check = _FP_SH_DEFAULT_INACTIVITY_TIMEOUT;
      channel.session.sshrecv_until(
        end_states     : make_list("SOC_CLOSED"),
        check_callback : callback,
        channel        : channel,
        timeout        : this.recv_timeout);

      # If using the default callback and did not time out, then the
      # shell was gained with the expected command prompt
      if (default_callback && !this.timed_out)
      {
        this.current_shell = destination;
      }
      # Custom call backs will change the shell on their own
      else if (this.current_shell != destination)
      {
        msg = 'Failed to obtain shell "' + destination + '"';
        if (module) msg += ', module ' + module;
        session.set_cmd_error(msg);
        # Try to get back to source cmd_prompt
        if (orig_cmd_prompt)
        {
          this.cmd_prompt = orig_cmd_prompt;
          check_len = 3;
          if (strlen(this.cmd_prompt) < 3) check_len = strlen(this.cmd_prompt);
          dbg::detailed_log(lvl:2, src:fn, msg:'Getting command prompt',
            msg_details:{"Expected Commang Prompt":{"lvl":1, "value":this.cmd_prompt}});
          channel.window_send_data(data:'\x03');
          this.timeout_check = _FP_SH_INITIAL_INACTIVITY_TIMEOUT;
          channel.session.sshrecv_until(
            end_states     : make_list("SOC_CLOSED"),
            check_callback : @basic_shell_handler_at_prompt2_or_timeout,
            channel        : channel,
            timeout        : this.recv_timeout);

          # If we got back to the original command prompt, don't set
          # last_cmd_error
          if (!this.timed_out)
          {
            return FALSE;
          }

          session.set_cmd_error('Timed out waiting for expected command prompt: ' + this.cmd_prompt);
        }
        this.last_cmd_error = TRUE;
        return FALSE;
      }
      # Try to receive the command prompt if we haven't already
      else if (isnull(this.cmd_prompt) || !super.at_cmd_prompt(buf:channel.data_buf, check_len:check_len))
      {
        if (!channel_usable_for_shell_command(channel:channel))
          return FALSE;

        dbg::detailed_log(lvl:2, src:fn, msg:'Getting command prompt');
        channel.window_send_data(data:'\x03');
        this.timeout_check = _FP_SH_INITIAL_INACTIVITY_TIMEOUT;
        channel.session.sshrecv_until(
          end_states     : make_list("SOC_CLOSED"),
          check_callback : @basic_shell_handler_at_prompt2_or_timeout,
          channel        : channel,
          timeout        : this.recv_timeout);

        if (this.cmd_prompt && this.timed_out)
        {
          session.set_cmd_error('Timed out waiting for expected command prompt: ' + this.cmd_prompt);
          this.last_cmd_error = TRUE;
          return FALSE;
        }
        if (!this.cmd_prompt)
        {
          # originally
          #var lines = split(channel.data_buf, sep:'\n', keep:FALSE);
          #this.cmd_prompts[destination] = lines[max_index(lines)-1];

          # changed to
          var lines = split(channel.data_buf, sep:'\n', keep:FALSE);
          var tmp_prompt = lines[max_index(lines)-1];
          dbg::detailed_log(lvl:3, src:fn, msg:'Found tmp_prompt: ' + tmp_prompt);
          if (tmp_prompt =~ '^\xA0')
          {
            tmp_prompt = substr(tmp_prompt, 1);
            dbg::detailed_log(lvl:3, src:fn, msg:'Massaging tmp_prompt: ' + tmp_prompt);
          }
          if (tmp_prompt =~ '^\\^C')
          {
            tmp_prompt = substr(tmp_prompt, 2);
            dbg::detailed_log(lvl:3, src:fn, msg:'Massaging tmp_prompt: ' + tmp_prompt);
          }
          this.cmd_prompt = tmp_prompt;
          this.cmd_prompts[destination] = this.cmd_prompt;

          this.set_fp_cmd_prompt(layer:destination, module:module, cmd_prompt:this.cmd_prompt);
          dbg::detailed_log(lvl:1, src:fn, msg:'Found command prompt: ' + this.cmd_prompt);
        }
      }
      dbg::detailed_log(lvl:1, src:fn, msg:'Successfully obtained shell "' + destination + '"');

      this.fresh_shell = FALSE;
      this.timed_out = FALSE;
      this.last_cmd_error = FALSE;
      this.last_shell_used = destination;
      if (module) this.last_module_used = module;
      channel.clear_data_buf();

      return TRUE;
    }

    ##
    # Utility functions to request a shell change to chassis
    #
    # @param channel channel for ssh session
    #
    # @return TRUE if successful, FALSE otherwise
    ##
    public function get_sh_chassis(&channel)
    {
      # make sure the change can happen
      if (this.default_shell == FP_SH_FTD)
        return FALSE;

      if (this.default_shell == FP_SH_MODULE)
        return FALSE;

      # change the shells
      if (this.current_shell == FP_SH_FTD)
        this._change_shell_layer(
          channel:channel,
          source:FP_SH_FTD,
          destination:FP_SH_MODULE,
          module:this.last_module_used,
          command:'exit');

      if (this.current_shell == FP_SH_MODULE)
        this._change_shell_layer(
          channel:channel,
          source:FP_SH_MODULE,
          destination:FP_SH_CHASSIS,
          command:'exit');

      # check that ending shell is the correct shell
      if (this.current_shell == FP_SH_CHASSIS)
        return TRUE;

      return FALSE;
    }

    ##
    # Utility functions to request a shell change to module
    #
    # @param channel channel for ssh session
    # @param module module number to use
    #
    # @return TRUE if successful, FALSE otherwise
    ##
    public function get_sh_module(&channel, module)
    {
      # make sure the change can happen
      if (this.default_shell == FP_SH_FTD)
        return FALSE;

      # change the shells
      if (this.current_shell == FP_SH_CHASSIS)
        this._change_shell_layer(
          channel:channel,
          source:FP_SH_CHASSIS,
          destination:FP_SH_MODULE,
          module:module,
          command:this._get_module_connect(module: module),
          callback:this._get_module_callback());

      if (this.current_shell == FP_SH_FTD)
        this._change_shell_layer(
          channel:channel,
          source:FP_SH_FTD,
          destination:FP_SH_MODULE,
          module:module,
          command:'exit');

      # check that ending shell is the correct shell
      if (this.current_shell == FP_SH_MODULE)
        return TRUE;

      return FALSE;
    }

    ##
    # Utility functions to request a shell change to threat defense
    #
    # @param channel channel for ssh session
    # @param module module number to use
    #
    # @return TRUE if successful, FALSE otherwise
    ##
    public function get_sh_ftd(&channel, module)
    {
      # change the shells 
      if (this.current_shell == FP_SH_CHASSIS)
        this._change_shell_layer(
          channel:channel,
          source:FP_SH_CHASSIS,
          destination:FP_SH_MODULE,
          module:module,
          command:this._get_module_connect(module:module),
          callback:this._get_module_callback(module:module));

      if (isnull(module)) module = this.last_module_used;
      if (this.current_shell == FP_SH_MODULE)
        this._change_shell_layer(
          channel:channel,
          source:FP_SH_MODULE,
          destination:FP_SH_FTD,
          module:module,
          command:'connect ftd',
          callback:this._get_ftd_callback(module:module));

      # check that ending shell is the correct shell
      if (this.current_shell == FP_SH_FTD)
        return TRUE;

      return FALSE;
    }

    ##
    # Utility functions to request a shell change to expert mode
    #
    # @param channel channel for ssh session
    # @param module module number to use
    #
    # @return TRUE if successful, FALSE otherwise
    ##
    public function get_sh_expert(&channel, module)
    {
      # change the shells 
      if (this.current_shell == FP_SH_CHASSIS)
        this._change_shell_layer(
          channel:channel,
          source:FP_SH_CHASSIS,
          destination:FP_SH_MODULE,
          module:module,
          command:this._get_module_connect(module:module),
          callback:this._get_module_callback(module:module));

      if (isnull(module)) module = this.last_module_used;
      if (this.current_shell == FP_SH_MODULE)
        this._change_shell_layer(
          channel:channel,
          source:FP_SH_MODULE,
          destination:FP_SH_FTD,
          module:module,
          command:'connect ftd',
          callback:this._get_ftd_callback(module:module));

      if (isnull(module)) module = this.last_module_used;
      if (this.current_shell == FP_SH_FTD)
        this._change_shell_layer(
          channel:channel,
          source:FP_SH_FTD,
          destination:FP_SH_EXPERT,
          module:module,
          command:'expert',
          callback:this._get_expert_callback(module:module));


      # check that ending shell is the correct shell
      if (this.current_shell == FP_SH_EXPERT)
        return TRUE;

      return FALSE;
    }

    ##
    # Determine command to connect to the module.
    #
    # @param module module number to connect to
    #
    # @return command string command to connect to module
    ##
    protected function _get_module_connect(module)
    {
      if (isnull(module))
        if (isnull(this.last_module_used))
          module = 1;
        else
          module = this.last_module_used;

      return 'connect module ' + module + ' telnet';
    }

    ##
    # Determine command to connect to the module.
    #
    # @param module Module number
    # @return function reference
    ##
    protected function _get_module_callback(module)
    {
      if (isnull(this.get_fp_cmd_prompt(layer:FP_SH_MODULE, module:module)))
        return @cb_fp_sh_entered_module_or_timeout;
      else
        return NULL;
    }

    ##
    # Determine command to connect to the module.
    #
    # @param module Module number
    # @return function reference
    ##
    protected function _get_ftd_callback(module)
    {
      #if (isnull(this.cmd_prompts[FP_SH_FTD]))
      if (
        isnull(this.get_fp_cmd_prompt(layer:FP_SH_FTD, module:module)) ||
        strlen(this.cmd_prompts[FP_SH_FTD]) < 3
      )
        return @cb_fp_sh_entered_ftd_or_timeout;
      else
        return NULL;
    }

    ##
    # Determine command to connect to the module.
    #
    # @param module Module number
    # @return function reference
    ##
    protected function _get_expert_callback(module)
    {
      if (
        isnull(this.get_fp_cmd_prompt(layer:FP_SH_EXPERT, module:module))
      )
        return @cb_fp_sh_entered_expert_or_timeout;
      else
        return NULL;
    }

    ##
    # Utility functions to check all valid FP shells
    #
    # @param shell shell string to check
    #
    # @return TRUE if successful, FALSE otherwise
    ##
    protected function _is_valid_shell(shell)
    {
      return
        shell == FP_SH_CHASSIS ||
        shell == FP_SH_MODULE ||
        shell == FP_SH_FTD ||
        shell == FP_SH_EXPERT;
    }

    ##
    # run given command
    #
    # @param session SSH session in case reconnection is needed
    # @param channel channel for ssh session
    # @param command cmd to run
    # @param force_priv_escl force priv escalation flag
    # @param cmd_timeout_min The total number of seconds that may elapse
    #                      waiting for the command response. (optional)
    # @param inactivity_timeout_min The number of seconds that may
    #                             elapse with no data received from
    #                             the target. (optional)
    # @param cmd_shell The global var for the Firepower shell that should
    #                  be used to run the command (optional, default FP_SH_FTD)
    # @param module    Module number to use (optional, default to 1)
    #
    # @return command result or NULL on failure
    # @category SSH
    ##
    public function run_command(&session, &channel, command, force_priv_escl,
        cmd_timeout_min, inactivity_timeout_min, cmd_shell, module)
    {
      var fn = objname + FUNCTION_NAME;
      var obj_ch_id = '[channel ' + channel.local_channel + ']: ';
      var msg, res;

      # Check channel and replace if necessary; replace_shell() will
      # set applicable error if it fails
      channel.set_shell_handler(shell_handler:this);
      if (!channel_usable_for_shell_command(channel:channel))
      {
        if (!session_replace_shell(session:session, channel:channel))
        {
          msg = 'Did not run command due to session error.\nCommand : ' + command + '\nSession error : "' + last_error + '"';
          session.set_error(msg);
          return msg;
        }
        this.fresh_shell = TRUE;
      }

      # Initialize variables
      set_timeouts(inactivity_timeout_min:inactivity_timeout_min,
          cmd_timeout_min:cmd_timeout_min);

      this.kb_id = SSH_LIB_KB_PREFIX + session.get_kb_connection_id();
      this.get_cmd_prompts();

      if (this.fresh_shell && !this._is_valid_shell(shell:this.default_shell))
      {
        dbg::detailed_log(lvl:3, src:fn, msg:'Checking default Firepower shell.');
        this.default_shell = get_kb_item(this.kb_id + '/Firepower/default_shell');
        if (this._is_valid_shell(shell:this.default_shell) && !this.cmd_prompts[this.default_shell])
        {
          this.determine_firepower_shell(
            channel                : channel,
            cmd_timeout_min        : cmd_timeout_min,
            inactivity_timeout_min : inactivity_timeout_min,
            init: FALSE);
          if (this.current_shell != this.default_shell)
            if(!this.revert(channel: channel))
              return NULL;
        }
        else
        {
          this.determine_firepower_shell(
            channel                : channel,
            cmd_timeout_min        : cmd_timeout_min,
            inactivity_timeout_min : inactivity_timeout_min);
        }
      }

      if (!this.default_shell)
      {
        session.set_cmd_error('Unable to run command. Failed to ' +
          'confirm that default shell is a Firepower shell.');
        return NULL;
      }

      # If fresh shell, assume current shell is default shell
      if (this.fresh_shell) this._set_shell_values(layer:this.default_shell);

      # Assume last shell used as shell to run in if not specified
      if (isnull(cmd_shell)) cmd_shell = this.last_shell_used;

      # Assume last module used as moudle to run in for escalation from chassis
      # to bootCLI
      if (isnull(module)) module = this.last_module_used;

      dbg::detailed_log(lvl:1, src:fn, msg:'Command to run : ' + command);
      dbg::detailed_log(lvl:1, src:fn, msg:'Firepower shell to use : ' + cmd_shell + ' (' + module + ')');

      # Verify the current and target shells are known shell before proceeding
      if (!this._is_valid_shell(shell: this.current_shell))
      {
        session.set_cmd_error('Unable to run command. Current shell "' +
          this.current_shell + '" is not a known Firepower shell.');
        return NULL;
      }
      if (!this._is_valid_shell(shell: cmd_shell))
      {
        session.set_cmd_error('Unable to run command. Target shell "' +
          cmd_shell + '" is not a known Firepower shell.');
        return NULL;
      }

      # If module is not the last module used, must return to chassis before
      # re-escalating to the application
      if (!isnull(this.last_module_used) && module != this.last_module_used)
      {
        if (!this.get_sh_chassis(channel:channel))
        {
          session.set_cmd_error('Unable to return to chassis to escalate to ' +
            'different module (' + this.last_module_used + ' -> ' + module + ').');
          return NULL;
        }
        # clear out upper layer cmd_prompts to allow for re-identification of
        # command prompts
        this.cmd_prompts[FP_SH_MODULE] = NULL;
        this.cmd_prompts[FP_SH_FTD] = NULL;
        this.cmd_prompts[FP_SH_EXPERT] = NULL;
      }

      # Set sh to the target shell for the command
      dbg::detailed_log(lvl:3, src:fn,
        msg:'Making sure the current shell ' + 'is the specified shell "' + cmd_shell + '" to run the command.');

      if (cmd_shell == this.current_shell)
      {
        res = TRUE;
      }
      else if (cmd_shell == FP_SH_CHASSIS)
      {
        res = this.get_sh_chassis(channel:channel);
      }
      else if (cmd_shell == FP_SH_MODULE)
      {
        res = this.get_sh_module(channel:channel, module:module);
      }
      else if (cmd_shell == FP_SH_FTD)
      {
        res = this.get_sh_ftd(channel:channel, module:module);
      }
      else if (cmd_shell == FP_SH_EXPERT)
      {
        res = this.get_sh_expert(channel:channel, module:module);
      }
      else
      {
        session.set_cmd_error('Unknown Firepower shell "' + cmd_shell + '".');
        return NULL;
      }

      if (!res)
      {
        session.set_cmd_error('Unable to obtain shell "' + cmd_shell +
          '" specified to run command.');
        return NULL;
      }

      dbg::detailed_log(lvl:1, src:fn, msg:'Running command "' + command + '" using Firepower shell "' + this.current_shell + '"');

      var ret = super.run_command(
        channel                : channel,
        command                : command,
        cmd_timeout_min        : cmd_timeout_min,
        inactivity_timeout_min : inactivity_timeout_min);

      # set last shell and last module after successful command run
      if (!isnull(ret))
      {
        this.last_shell_used = cmd_shell;
        this.last_module_used = module;
      }

      return ret;
    }

    ##
    # Revert to default shell
    #
    # @param channel channel for ssh session
    #
    # @return TRUE if successful, FALSE otherwise
    ##
    public function revert(&channel)
    {
      var fn = objname + FUNCTION_NAME;
      var session = channel.session;
      var res = TRUE;

      if (this.current_shell == this.default_shell)
        return TRUE;

      dbg::detailed_log(lvl:2, src:fn,
        msg:'Reverting current shell "' + this.current_shell + '" to default shell "' + this.default_shell + '".');

      if (this.default_shell == FP_SH_CHASSIS)
        res = this.get_sh_chassis(channel:channel);
      else if(this.default_shell == FP_SH_MODULE)
        res = this.get_sh_module(channel:channel);
      else if(this.default_shell == FP_SH_FTD)
        res = this.get_sh_ftd(channel:channel);

      if (!res)
      {
        session.set_cmd_error('Failed to revert to default Firepower shell.');
        return FALSE;
      }

      return TRUE;
    }


    ##
    # Close the shell by sending an 'exit'
    #
    # @param channel channel for ssh session
    #
    # @return TRUE if successful, FALSE otherwise
    ##
    public function close(&channel)
    {
      var fn = objname + FUNCTION_NAME;
      var session = channel.session;

      dbg::detailed_log(lvl:3, src:fn, msg:'Closing Firepower shell.');

      # Revert to default shell if necessary
      if (this.current_shell != this.default_shell)
      {
        this.revert(channel:channel);
      }

      super.run_command(
        channel                : channel,
        command                : 'exit');

      return TRUE;
    }

    ##
    # test private function
    #
    # @param name name of function to return
    # @param args args to pass to the function
    #
    # @return NULL on error / result of named function
    # @category SSH
    ##
    public function test_private_function(name, args)
    {
      var fn = 'sh_shell_handler.test_private_function';
      if (isnull(name))
      {
        dbg::detailed_log(lvl:1, src:fn, msg:'Missing name parameter');
        return;
      }
      switch (name)
      {
        default:
          dbg::detailed_log(lvl:1, src:fn, msg:'"'+name+'()" is not yet implemented for testing with this function');
          return NULL;
      }
    }
  }
}
