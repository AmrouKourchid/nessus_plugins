#TRUSTED 397e1645ec9465100a17a1f8f1f1afd842f88999d3972c7a9ce12894029dddbc2da5caae615ab0bcdb213abfe937508c15a5c73f24dd45db2cd810923c8148f0a00ab13678c0df07b6ace9f3bde5500f665bcacf7c53fafe369021f65c017635f78070e1916e7dde6c2a8fd343aaaaacf355e0453be8bda99506a975c82b5900cf513f7992eca55984c14aa52563b23c19f3369fb2b0fe2e9ee73aca0fa98c354e9566bfdb8b09ea9cf77a87317fa363f95dbd24587b44033c2f9f1a5fa2c532af065bebdf43fbc124154f8bbb30d5d4d0eeabb043f145b17a9351c40a7f25ff8ff164fee73fea887b6667ab8149ef247750ed21a3a67d3d574f1491ac68089033f182fbeef35dce316445b9be43654817f62a626f39b4e79e7a7fc8a066d5291a74db4be0507e2402eefa0b5cb2c8593a36fb598744deb43b30c70ddebff0a2657506471cca894727dafd37837cec87853e9ad2a94c0d85966822de2c0a61b5ebb802020e0d17c670b1a22b179c839ec3a37e65dbe140516eb101b16006aa1bb606ab25c8856ae8d16d79dd43f35e53f064e02a4eeb16a71c9e4b05f7547df844dce63d2f87fee809616103d36aa161cdbb547ba162a2b8b523d4617e9af25d039ff88d2e73662b6aa99cb913e0c69c30f890bbcacb949c5cd1ca48079bf2eb2416d7a1b15324ea71356e549f61067455ec9db45a8037f11d59347e9ffb16f5
#TRUST-RSA-SHA256 5f23a630813b8f1ec78cda9634d95aea4b667606679b9c81fa5b160804d012f9c08902cdabfa3b4679708612f84df434fd18a8a68a592d15e154a3567fcfefef8cb98cdcbed72dadef71ec93ad807b2e53f06d760eddbc7c09389570d45e5793176a5effeba9ec1a90ef4767ce3c7a9adbbd7b8538c7d45c3603969f6218eb7c359ba13f015ae02381b165eb05d7b96a62b1f905dad46ded6f16227b7595d3130127cdcc22844445a34d70cec0de710aa828c4e683477a54bb5c6fbe2178404470f2b8ab08a3faaf25542d1e08c85f2a546107a0cd5ff742ae6bc4c13461d90da18f40695e34b89ee6dde095d9818b858a7040bb79fff32578c04b7ce4d8b30ca51462fda21801c670c02ed6a1b05dcab5024b547f8033b59b7251de293d6770c94fc92d908cf37df9f130d5af3954f798d26e924335bc3b6824c1487eee02e168002d8dccb3c54b9d917859f99edbd675a0525d78b7f5632d9c1946db9ee0f19f5d05faae6112bf56de1f920f55afc901117fc0305086d4fe6825cda138125971c5bb2dda676a2257b670756d2f9442a880de386561ce3e0e6fa3fba73fb63baaa23ff9d6f10e8554a4340da8cefce25f4fd5a4d8ffe4c40565bb38ce741ad4b536b32020024595f19d131783620e7b47a652d320267ff6eb9042d07afb9e1731b268911f9a4bf0bcdbcec51e89b9b2a991a121ad102f3e8e5c10ba3ccda5d6
#------------------------------------------------------------------------------
#
# (C) Tenable Network Security, Inc.
#
# This script is released under one of the Tenable Script Licenses and may not
# be used from within scripts released under another license without the
# authorization from Tenable Network Security, Inc.
#
# @NOGPL@
#
# smb_lsa.inc
# Revision: 1.13
#

#==================================================================#
# Section 9. LSA API                                               #
#==================================================================#

#---------------------------------------------------------#
# Function    : LsaOpenPolicy                             #
# Description : Open LSA Policy                           #
# Note        : access mode is optional                   #
#---------------------------------------------------------#

function direct_LsaOpenPolicy (desired_access)
{
  var fid, ret, data, type, resp, rep, daccess;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Attempting LsaOpenPolicy');

  if (!isnull (desired_access))
    daccess = desired_access;
  else
    daccess = 0x000f0fff;

  fid = bind_pipe(pipe:"lsarpc", uuid:"12345778-1234-abcd-ef00-0123456789ab", vers:0);
  if (isnull (fid))
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'bind_pipe()');
    return NULL;
  }

  data = class_parameter (ref_id:0x00020000, name:"\\" + session_get_hostname ()) +
    # LSA_OBJECT_ATTRIBUTES (NULL)
    raw_dword (d:0)          + # length
    raw_dword (d:0)          + # RootDirectory (HANDLE)
    raw_dword (d:0)          + # ObjectName (NULL)
    raw_dword (d:0)          + # Attributes
    raw_dword (d:0)          + # SecurityDescriptor (NULL Pointer)
    raw_dword (d:0)          + # SecurityQualityOfService (NULL Pointer)
    # Desired Access
    raw_dword (d:daccess) ;
  data = dce_rpc_pipe_request(fid:fid, code:OPNUM_LSAOPENPOLICY, data:data);
  if (!data)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'dce_rpc_pipe_request()');
    return NULL;
  }

  # response structure :
  # Policy handle (20 bytes)
  # return code (dword)

  rep = dce_rpc_parse_response(fid:fid, data:data);
  if (!rep || (strlen (rep) != 24))
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:24);
    return NULL;
  }

  resp = get_dword (blob:rep, pos:20);
  if (resp != STATUS_SUCCESS)
  {
    _debug_smb_status_not_success(fname:FUNCTION_NAME);
    return NULL;
  }

  ret = NULL;
  ret[0] = substr (rep, 0, 19);
  ret[1] = fid;
  ret[2] = 1;

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Success');
  return ret;
}


#---------------------------------------------------------#
# Function    : LsaQueryInformationPolicy                 #
# Description : Query Policy Information                  #
#                                                         #
# Supports    : PolicyAccountDomainInformation            #
#               PolicyPrimaryDomainInformation            #
#                                                         #
# return      : ret[0] hostname/domain                    #
#               ret[1] raw sid                            #
#---------------------------------------------------------#

function direct_LsaQueryInformationPolicy (handle, level)
{
  var data, resp, rep, name, ret, len, ref_id, pad, length, size, i;
  var max_count, offset, actual_count, hostname, pos, count, sid, sid_ref_id, auditing;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Attempting LsaQueryInformationPolicy');

  data = handle[0]                     +  # Handle
         raw_word (w:level) ;             # Info level

  data = dce_rpc_pipe_request (fid:handle[1], code:OPNUM_LSAQUERYINFO, data:data);
  if (!data)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'dce_rpc_pipe_request()');
    return NULL;
  }

  rep = dce_rpc_parse_response (fid:handle[1], data:data);
  if (!rep || (strlen (rep) < 10))
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:10);
    return NULL;
  }

  resp = get_dword (blob:rep, pos:strlen(rep)-4);
  if (resp != STATUS_SUCCESS)
  {
    _debug_smb_status_not_success(fname:FUNCTION_NAME);
    return NULL;
  }

  ref_id = get_dword (blob:rep, pos:0);
  level = get_word (blob:rep, pos:4);

  if ((level == PolicyAccountDomainInformation) || (level == PolicyPrimaryDomainInformation))
  {
    if (strlen(rep) < 36)
    {
      _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:36);
      return NULL;
    }

    # POLICY_ACCOUNT_DOMAIN_INFO
    pad = get_word (blob:rep, pos:6);

    # size is the total size of the remote buffer, length is data length in the buffer
    length = get_word (blob:rep, pos:8);
    size = get_word (blob:rep, pos:10);

    # ref_id = get_dword (blob:rep, pos:12); # string refid
    sid_ref_id = get_dword (blob:rep, pos:16); # sid refid

    # LSA_UNICODE_STRING
    max_count = get_dword (blob:rep, pos:20);
    offset = get_dword (blob:rep, pos:24);
    actual_count = get_dword (blob:rep, pos:28);

    if (strlen(rep) < 36 + length)
    {
      _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:36+length);
      return NULL;
    }

    hostname = get_string2 (blob:rep, pos:32, len:length, _type:UNICODE_STRING);

    while ((length % 4) != 0)
      length ++;

    pos = 32 + length;

    if (sid_ref_id != 0)
    {
      # Domain SID
      count = get_dword (blob:rep, pos:pos);
      sid = substr (rep, pos+4, strlen(rep) - 5);
    }
    else
      sid = NULL;

    ret = NULL;
    ret[0] = hostname;
    ret[1] = sid;
    dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
      'Success on domain levels');
    return ret;
  }

  if (level == PolicyAuditEventsInformation)
  {
    if (strlen(rep) != 64)
    {
      _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:64, operator:'is not');
      return NULL;
    }

    # values are filled with 0 (no auditing) if auditing is set to 0
    auditing = get_dword (blob:rep, pos:8);
    #if (auditing == 0)
    #  return NULL;

    ref_id = get_dword (blob:rep, pos:12);
    actual_count = get_dword (blob:rep, pos:16);
    max_count = get_dword (blob:rep, pos:20);

    if (actual_count != 9)
    {
      dbg::detailed_log(lvl:1, family:'SMB', src:FUNCTION_NAME, msg:
        'actual_count is not 9!');
      return NULL;
    }

    ret = NULL;
    for (i=0; i<9; i++)
       ret[i] = get_dword (blob:rep, pos:24+i*4);
    
    dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
      'Success on audit event levels');
    return ret;
  }

  # PolicyDnsDomainInformation / LSA_POLICY_INFO_DNS (12)
  if (level == PolicyDnsDomainInformation)
  {
    data = direct_parse_PolicyDnsDomainInformation(rep:rep);
    if (empty_or_null(data))
      return NULL;

    ret[0] = data.domain_netbios_name.string; # Domain NetBIOS Name
    ret[1] = data.domain_fqdn.string;         # Domain FQDN
    ret[2] = data.forest_fqdn.string;         # Forest FQDN
    ret[3] = data.domain_guid;                # Domain GUID
    ret[4] = data.domain_sid.sid;             # Domain SID

    return ret;
  }

  # PolicyMachineAccountInformation / POLICY_MACHINE_ACCT_INFO (15)
  if (level == PolicyMachineAccountInformation)
  {
    data = direct_parse_PolicyMachineAccountInformation(rep:rep);
    if (empty_or_null(data))
      return NULL;

    ret[0] = data.rid; # Relative ID (RID)
    ret[1] = data.sid; # Security ID (SID) (including RID)

    return ret;
  }
}


##
# Parse the LSA PolicyDnsDomainInformation class for QueryInfoPolicy
#
# @param [rep:data] LSA PolicyDnsDomainInformation response
#
# @return array of the data from the PolicyDnsDomainInformation class if successful
#         NULL otherwise 
##
function direct_parse_PolicyDnsDomainInformation(rep)
{
  # Argument check
  if (!rep)
  {
    dbg::detailed_log(lvl:1, src:FUNCTION_NAME, msg:'Argument for parameter "rep" is empty or null.');
    return NULL;
  }

  # Check status
  var status = get_dword (blob:rep, pos:strlen(rep)-4);
  if (status != STATUS_SUCCESS)
  {
    _debug_smb_status_not_success(fname:FUNCTION_NAME);
    return NULL;
  }

  # Parse stub
  var info = {};
  var identifiers = [ 'domain_netbios_name', 'domain_fqdn', 'forest_fqdn'];

  ##
  # Parse the length, size, and referent ID for the DNS Name, Domain, and Forest
  #  - length: data length in the buffer
  #  - size: total size of the remote buffer
  #  - referent ID: pointer ID (not used here)
  #
  # Note: these values will always be present
  ##
  var pos = 8;
  foreach var identifier (identifiers)
  {
    info[identifier].length = get_word(blob: rep, pos: pos);
    info[identifier].size   = get_word(blob: rep, pos: pos+2);
    info[identifier].ref_id = get_dword(blob: rep, pos: pos+4);

    pos += 8;
  }

  # Domain GUID
  #  - Example: 3e0ca54f-0397-433b-9b71-c936dd905cab
  info.domain_guid = decode_uuid(uuid: substr(rep, 32, 47));

  # Pointer to Domain SID
  #  - More data captured below
  info.domain_sid.ref_id = get_dword(blob: rep, pos: 48);

  ##
  # DNS Name, Domain, Forest
  #  - Name should always be present
  #  - Domain and Forest will only be present if host is joined to a domain
  ##
  pos = 52;

  var len;

  foreach identifier (identifiers)
  {
    # Skip empty values
    if (!info[identifier].length || !info[identifier].size)
      continue;

    info[identifier].max_count    = get_dword(blob: rep, pos: pos);
    info[identifier].offset       = get_dword(blob: rep, pos: pos+4);
    info[identifier].actual_count = get_dword(blob: rep, pos: pos+8);

    pos += 12;
    len = info[identifier].actual_count*2;

    info[identifier].string = get_string2(blob: rep, pos: pos, len: len, _type: UNICODE_STRING);

    pos += info[identifier].length;

    # Padding for odd actual counts
    if ((info[identifier].actual_count*2)%4)
      pos += 2;
  }

  # Domain SID
  var data, sid;
  if (info.domain_sid.ref_id)
  {
    info.domain_sid.count = get_dword(blob: rep, pos: pos);
    data = substr(rep, pos+4, strlen(rep) - 5);
    if (data)
    {
      sid = sid2string(sid:data);
      if (!empty_or_null(sid))
        info.domain_sid.sid = 'S-' + sid;
    }
  }

  dbg::detailed_log(lvl:3, src:FUNCTION_NAME, msg:'Parsed data: ' + obj_rep(info));
  return info;
}


##
# Parse the LSA PolicyMachineAccountInformation class for QueryInfoPolicy
#
# @param [rep:data] LSA PolicyMachineAccountInformation response
#
# @return array of the data from the PolicyMachineAccountInformation class including objectSID if successful
#         NULL otherwise 
##
function direct_parse_PolicyMachineAccountInformation(rep)
{
  # Argument check
  if (!rep)
  {
    dbg::detailed_log(lvl:1, src:FUNCTION_NAME, msg:'Argument for parameter "rep" is empty or null.');
    return NULL;
  }

  # Check status
  var status = get_dword (blob:rep, pos:strlen(rep)-4);
  if (status != STATUS_SUCCESS)
  {
    _debug_smb_status_not_success(fname:FUNCTION_NAME);
    return NULL;
  }

  # Parse stub
  var info, data, sid;

  info = {};

  info.ref_id = get_dword(blob: rep, pos: 0);
  info.level  = get_word(blob: rep, pos: 4);

  # 2 NULL byte padding

  # Relative ID (RID)
  info.rid = sid_ltoa(l:get_dword(blob: rep, pos: 8));

  # Security ID (SID)
  info.sid_ref_id = get_dword(blob: rep, pos: 12);

  if (info.sid_ref_id)
  {
    info.sid_count = get_dword(blob: rep, pos: 16);

    data = substr(rep, 20, strlen(rep) - 5);
    if (data)
    {
      sid = sid2string(sid:data);
      if (!empty_or_null(sid))
        info.sid = 'S-' + sid;
    }
  }

  return info;
}

#---------------------------------------------------------#
# Function    : LsaQueryDomainInformationPolicy           #
# Description : Query Domain Policy Information           #
#                                                         #
# Supports    : PolicyDomainKerberosTicketInformation     #
#                                                         #
# return      : ret[0] - user logon restrictions          #
#               ret[1] - unknown                          #
#               ret[2] - service ticket lifetime (sec)    #
#               ret[3] - user ticket lifetime (sec)       #
#               ret[4] - user ticket renewal time (sec)   #
#               ret[5] - clock sync tolerance (sec)       #
#---------------------------------------------------------#

function direct_LsaQueryDomainInformationPolicy (handle, level)
{
  var data, rep, resp, ref_id, ret;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Trying LsaQueryDomainInformationPolicy');

  data = handle[0]                     +  # Handle
         raw_word (w:level) ;             # Info level

  data = dce_rpc_pipe_request (fid:handle[1], code:OPNUM_LSAQUERYDOMAININFO, data:data);
  if (!data)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'dce_rpc_pipe_request()');
    return NULL;
  }

  rep = dce_rpc_parse_response (fid:handle[1], data:data);
  if (!rep || (strlen (rep) < 10))
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:10);
    return NULL;
  }

  resp = get_dword (blob:rep, pos:strlen(rep)-4);
  if (resp != STATUS_SUCCESS)
  {
    _debug_smb_status_not_success(fname:FUNCTION_NAME);
    return NULL;
  }

  ref_id = get_dword (blob:rep, pos:0);
  level = get_word (blob:rep, pos:4);

  if (level == PolicyDomainKerberosTicketInformation)
  {
    if (strlen(rep) != 60)
    {
      _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:60, operator:'is not');
      return NULL;
    }

    ret = NULL;
    ret[0] = get_dword (blob:rep, pos:8);
    ret[1] = get_dword (blob:rep, pos:12);
    ret[2] = convert_time_to_sec(time:substr(rep, 16, 23), no_zero:TRUE);
    ret[3] = convert_time_to_sec(time:substr(rep, 24, 31), no_zero:TRUE);
    ret[4] = convert_time_to_sec(time:substr(rep, 32, 39), no_zero:TRUE);
    ret[5] = convert_time_to_sec(time:substr(rep, 40, 47), no_zero:TRUE);

    dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
      'Success');
    return ret;
  }

  dbg::detailed_log(lvl:1, family:'SMB', src:FUNCTION_NAME, msg:
    'Unhandled level ' + level + '!');
  return NULL;
}


#---------------------------------------------------------#
# Function    : LsaLookupSid                              #
# Description : Translate PSID to UserNames               #
#               array of sid (InformationPolicy sid)      #
#                                                         #
# Return      : array of sid_type + domain + name         #
#               sid_type = raw_dword                      #
#---------------------------------------------------------#

function direct_LsaLookupSid(handle, sid_array)
{
  var num_sids, names, curr_index, i, j;
  var batch_sids, batch_names, count, num_calls, MAX_SIDS;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Trying LsaQLookupSid');

  if (isnull(sid_array))
  {
   _debug_smb_null_return(fname:FUNCTION_NAME, label:'sid_array');
    return NULL;
  }

  # Maximum SIDs to send in one batch
  MAX_SIDS = 50;
  num_sids = max_index(sid_array);
  if (num_sids > MAX_SIDS)
  {
    names = make_list();
    num_calls = num_sids/MAX_SIDS;
    if (num_sids % MAX_SIDS != 0) ++num_calls;

    curr_index = 0;
    for(i=0; i < num_calls; ++i)
    {
      batch_sids = make_list();
      if (num_sids - curr_index < MAX_SIDS)
        count = num_sids - curr_index;
      else
        count = MAX_SIDS;
      for(j = 0; j < count; ++j)
      {
        batch_sids[j] = sid_array[curr_index++];
      }
      batch_names = _direct_LsaLookupSid(handle:handle, sid_array:batch_sids);
      if (isnull(batch_names))
      {
       _debug_smb_null_return(fname:FUNCTION_NAME, label:'_direct_LsaLookupSid()');
        return NULL;
      }
      names = make_list(names, batch_names);
    }
    dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
      'Returned batch of up to 50 names');
    return names;
  }
  else
  {
    dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
      'Returned batch of less than 50 names');
    return _direct_LsaLookupSid(handle:handle, sid_array:sid_array);
  }
}

function _direct_LsaLookupSid (handle, sid_array)
{
  var data, resp, rep, name, ret, len, ref_id, level, pad, length, size;
  var max_count, offset, actual_count, hostname, pos, count, sid, sid_ref_id;
  var names, ref_idm, name_length, name_size, name_ref_id, sid_type, index, unknown;
  var sid_count, i;
  var domain_names, dompt, ref_list;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Attempting actual SID lookups this time');
  domain_names = NULL;
  dompt = 0;

  ref_id = 0x00020000;
  if (isnull(sid_array) || !max_index(sid_array))
  {
   _debug_smb_null_return(fname:FUNCTION_NAME, label:'sid_array');
    return NULL;
  }

  data = handle[0]                     +  # Handle
        # PSID Array
        raw_dword (d:max_index (sid_array))  + # number of sid in PSID Array
        raw_dword (d:ref_id)                 + # Referent ID
        raw_dword (d:max_index (sid_array)) ;  # max_count

  ref_id++;

  # ref_id
  foreach sid (sid_array)
  {
    data += raw_dword (d:ref_id);

    ref_id++;
  }

  foreach sid (sid_array)
  {
    count = ord(sid[1]);

    data += raw_dword (d:count)   +
            sid ;
  }

  data += raw_dword (d:0)        + # count = 0
          raw_dword (d:0)        + # NULL pointer (LSA_TRANSLATED_NAMES)
          raw_dword (d:1)        + # Level (nothing else seems to work)
          raw_dword (d:0)        ; # Num mapped ?
  #        raw_dword (d:0)        + # Unknown
  #        raw_dword (d:2) ;        # Unknown

  data = dce_rpc_pipe_request(fid:handle[1], code:OPNUM_LSALOOKUPSID, data:data);
  if (!data)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'dce_rpc_pipe_request()');
    return NULL;
  }

  rep = dce_rpc_parse_response (fid:handle[1], data:data);
  if (!rep || (strlen (rep) < 20))
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:20);
    return NULL;
  }

  resp = get_dword (blob:rep, pos:strlen(rep)-4);
  if ((resp != STATUS_SUCCESS) && (resp != STATUS_SOME_NOT_MAPPED))
  {
    _debug_smb_status_not_success(fname:FUNCTION_NAME, status:'success or some_not_mapped');
    return NULL;
  }

  # LSA REF DOMAIN LIST Pointer
  ref_id = get_dword (blob:rep, pos:0);
  count = get_dword (blob:rep, pos:4);

  # Trust information array
  ref_id = get_dword (blob:rep, pos:8);
  max_count = get_dword (blob:rep, pos:12);
  count = get_dword (blob:rep, pos:16);

  pos = 20;

  # for each domain info
  pos = pos + count*12;

  for (i=0; i<count; i++)
  {
    if (strlen(rep) < pos + 12)
    {
      _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:pos+12);
      return NULL;
    }

    # name array
    max_count = get_dword (blob:rep, pos:pos+0);
    offset = get_dword (blob:rep, pos:pos+4);
    actual_count = get_dword (blob:rep, pos:pos+8);

    if (strlen(rep) < pos + 12 + actual_count*2)
    {
      _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:pos + 12 + actual_count*2);
      return NULL;
    }

    domain_names[dompt++] = get_string2 (blob:rep, pos:pos+12, len:actual_count*2, _type:UNICODE_STRING);

    pos = pos+12+actual_count*2;

    if ((actual_count*2)%4)
      pos += 2;

    # SID
    sid_count = get_dword (blob:rep, pos:pos);
    if (strlen(rep) < pos + 4+8+sid_count*4)
    {
      _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:pos + 4+8+sid_count*4);
      return NULL;
    }

    sid = substr (rep, pos+4, pos+4+8+sid_count*4-1);
    pos = pos+4+8+sid_count*4;
  }

  # LSA_TRANSLATED_NAME_EX pointer
  count = get_dword (blob:rep, pos:pos);
  ref_id = get_dword (blob:rep, pos:pos+4);
  max_count = get_dword (blob:rep, pos:pos+8);

  pos = pos + 12;

  names = NULL;

  # for each names
  ref_list = NULL;
  for (i=0; i<count; i++)
  {
    if (strlen(rep) < pos + 20)
    {
      _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:pos + 20);
      return NULL;
    }

    sid_type = get_word (blob:rep, pos:pos);
    names[i] = raw_dword (d:sid_type);
    length = get_word (blob:rep, pos:pos+4);
    size = get_word (blob:rep, pos:pos+6);
    ref_id = get_dword (blob:rep, pos:pos+8);
    index = get_dword (blob:rep, pos:pos+12);

    ref_list[i] = ref_id;

    if (index >= 0 && index < max_index(domain_names))
    {
      name = domain_names[index];
      names[i] += raw_dword (d:strlen(name)) + name;
    }

    pos = pos+16;
  }

  # we get names now
  for (i=0; i<count; i++)
  {
    if (ref_list[i] == 0)
    {
      name = sid2string(sid:sid_array[i]);
      names[i] += raw_dword(d:strlen(name)) + name;
      continue;
    }

    if (strlen(rep) < pos + 12)
    {
      _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:pos + 12);
      return NULL;
    }

    max_count = get_dword (blob:rep, pos:pos);
    offset = get_dword (blob:rep, pos:pos+4);
    actual_count = get_dword (blob:rep, pos:pos+8);

    if (strlen(rep) < pos + 12 + actual_count*2)
    {
      _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:pos + 12 + actual_count*2);
      return NULL;
    }

    name = get_string2 (blob:rep, pos:pos+12, len:actual_count*2, _type:UNICODE_STRING);
    names[i] += raw_dword (d:strlen(name)) + name;
    if ((actual_count*2)%4)
       pos +=2;

    pos = pos+12+actual_count*2;
  }
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Returning names');
  return names;
}



#---------------------------------------------------------#
# Function    : LsaLookupNames                            #
# Description : Translate UserNames to SID                #
#               array of usernames                        #
#                                                         #
# Return      : array of sid_type + rid                   #
#               sid_type = rid = raw_dword                #
#---------------------------------------------------------#

function direct_LsaLookupNames (handle, name_array)
{
  var data, resp, rep, name, ret, len, ref_id, level, pad, length, size;
  var max_count, offset, actual_count, hostname, pos, count, sid, sid_ref_id;
  var names, ref_idm, name_length, name_size, name_ref_id, sid_type, index, unknown;
  var sid_count, uname, i, rid, sid_tab, tmp_sid;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Running LsaLookupNames');

  ref_id = 0x00020000;

  data = handle[0]                     +  # Handle
    # Account array
    raw_dword (d:max_index (name_array))  + # number of sid in PSID Array
    raw_dword (d:max_index (name_array)) ;  # max_count

  ref_id++;

  # ref_id
  foreach name (name_array)
  {
    if (session_is_unicode() == 0)
    {
      session_set_unicode (unicode:1);
      uname = cstring (string:name,_null:1);
      session_set_unicode (unicode:0);
    }
    else
    {
      uname = cstring (string:name, _null:1);
    }

    data += raw_word (w:strlen(uname)) +
            raw_word (w:strlen(uname)) +
            raw_dword (d:ref_id);

    ref_id++;
  }

  foreach name (name_array)
  {
    if (session_is_unicode() == 0)
    {
      session_set_unicode (unicode:1);
      uname = cstring (string:name,_null:1);
      session_set_unicode (unicode:0);
    }
    else
    {
      uname = cstring (string:name,_null:1);
    }

    data += raw_dword (d:strlen(uname)/2)   +
            raw_dword (d:0)                 + # offset
            raw_dword (d:strlen(uname)/2);

    while ((strlen(uname)%4) != 0)
      uname += raw_byte (b:0);

    data += uname;
  }

  data += raw_dword (d:0)        + # count = 0
          raw_dword (d:0)        + # NULL pointer (LSA_TRANSLATED_NAMES)
          raw_dword (d:1)        + # Level (nothing else seems to work)
          raw_dword (d:0)        ; # Num mapped ?

  data = dce_rpc_pipe_request (fid:handle[1], code:OPNUM_LSALOOKUPNAMES, data:data);
  if (!data)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'dce_rpc_pipe_request()');
    return NULL;
  }

  rep = dce_rpc_parse_response (fid:handle[1], data:data);
  if (!rep || (strlen (rep) < 20))
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:20);
    return NULL;
  }

  resp = get_dword (blob:rep, pos:strlen(rep)-4);
  if ((resp != STATUS_SUCCESS) && (resp != STATUS_NONE_MAPPED))
  {
    _debug_smb_status_not_success(fname:FUNCTION_NAME, status:'success or none_mapped');
    return NULL;
  }

  # LSA REF DOMAIN LIST Pointer
  ref_id = get_dword (blob:rep, pos:0);
  count = get_dword (blob:rep, pos:4);

  # Trust information array
  ref_id = get_dword (blob:rep, pos:8);
  max_count = get_dword (blob:rep, pos:12);
  count = get_dword (blob:rep, pos:16);

  pos = 20;

  sid_tab = NULL;

  # for each domain info

  for (i=0; i < count; i++)
  {
    if (strlen(rep) < pos + 24)
    {
      _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:pos+24);
      return NULL;
    }

    name_length = get_word (blob:rep, pos:pos);
    name_size = get_word (blob:rep, pos:pos+2);  # max size of name buffer (we are happy to know that)
    name_ref_id = get_dword (blob:rep, pos:pos+4);
    sid_ref_id = get_dword (blob:rep, pos:pos+8);

    # name array
    max_count = get_dword (blob:rep, pos:pos+12);
    offset = get_dword (blob:rep, pos:pos+16);
    actual_count = get_dword (blob:rep, pos:pos+20);

    if (strlen(rep) < pos + 28 + name_length)
    {
      _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:pos + 28 + name_length);
      return NULL;
    }

    name = substr (rep, pos+24, pos+24+name_length-1);
    pos = pos+24+name_length;

    while (name_length%4)
    {
      pos++;
      name_length++;
    }

    # SID
    sid_count = get_dword (blob:rep, pos:pos);

    if (strlen(rep) < pos + 4+8+sid_count*4)
    {
      _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:pos + 4+8+sid_count*4);
      return NULL;
    }

    sid_tab[i] = substr (rep, pos+4, pos+4+8+sid_count*4-1);

    pos = pos+4+8+sid_count*4;
  }

  # LSA_TRANSLATED_SID
  count = get_dword (blob:rep, pos:pos);
  ref_id = get_dword (blob:rep, pos:pos+4);
  max_count = get_dword (blob:rep, pos:pos+8);

  pos = pos + 12;
  sid = NULL;

  # for each names
  for (i=0; i<count; i++)
  {
    if (strlen(rep) < pos + 12)
    {
      _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:pos + 12);
      return NULL;
    }

    sid_type = get_dword (blob:rep, pos:pos);
    rid = get_dword (blob:rep, pos:pos+4);
    index = get_dword (blob:rep, pos:pos+8);

    tmp_sid = sid_tab[i];
    sid[i] = tmp_sid[0] + raw_byte (b: ord(tmp_sid[1])+1) + substr(tmp_sid,2,strlen(tmp_sid)-1) + raw_dword (d:rid);

    pos = pos+12;
  }
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Returning SID ' + sid);
  return sid;
}


#---------------------------------------------------------#
# Function    : LsaEnumerateAccountsWithUserRight         #
# Description : Get SID of User with Right 'right'        #
#               (string)                                  #
# Return      : array of sid                              #
#---------------------------------------------------------#

function direct_LsaEnumerateAccountsWithUserRight (handle, right)
{
  var data, rep, code, ret, resp, ref_id, size, pt, sid_count, count, max_count, sid_tab, i, total_len, pos;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Running LsaEnumerateAccountsWithUserRight ');

  pt = raw_dword (d:0x20000) + # pointer ref id
       class_parameter (ref_id:0x00020000, name:right, size:TRUE, _null:FALSE);

  data = handle[0]                     +  # Handle
         pt ;                             # right pointer

  data = dce_rpc_pipe_request (fid:handle[1], code:OPNUM_LSAENUMERATEACCOUNTWITHUSERRIGHT, data:data);
  if (!data)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'dce_rpc_pipe_request()');
    return NULL;
  }

  rep = dce_rpc_parse_response (fid:handle[1], data:data);
  if (!rep || (strlen (rep) < 16))
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:16);
    return NULL;
  }

  total_len = strlen(rep);

  resp = get_dword (blob:rep, pos:total_len);
  if (resp != STATUS_SUCCESS)
  {
    _debug_smb_status_not_success(fname:FUNCTION_NAME);
    return NULL;
  }

  count = get_dword (blob:rep, pos:0);
  ref_id = get_dword (blob:rep, pos:4);
  max_count = get_dword (blob:rep, pos:8);

  pos= 12;
  for (i=0; i<count; i++)
  {
    if ((pos+4) > total_len)
    {
      _debug_smb_length(fname:FUNCTION_NAME, varname:'pos+4', length:total_len);
      return NULL;
    }

    ref_id = get_dword (blob:rep, pos:pos);
    pos += 4;
  }

  sid_tab = NULL;
  for (i=0; i<count; i++)
  {
    if ((pos+4) > total_len)
    {
      _debug_smb_length(fname:FUNCTION_NAME, varname:'pos+4', length:total_len);
      return NULL;
    }

    sid_count = get_dword (blob:rep, pos:pos);
    pos += 4;

    if ((pos+8+sid_count*4-1) > total_len)
    {
      _debug_smb_length(fname:FUNCTION_NAME, varname:'(pos+8+sid_count*4-1)', length:total_len);
      return NULL;
    }

    sid_tab[i] = substr (rep, pos, pos+8+sid_count*4-1);

    pos = pos+8+sid_count*4;
  }
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Found a SID');
  return sid_tab;
}


#---------------------------------------------------------#
# Function    : LsaQuerySecurityObject                    #
# Description : Return security ACLs of the object        #
# Return      : security descriptor                       #
#---------------------------------------------------------#

function direct_LsaQuerySecurityObject (handle, type)
{
  var data, rep, code, ret, resp, ref_id, size;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Running LsaQuerySecurityObject');

  data = handle[0]                     +  # Handle
         raw_dword (d:type) ;             # Info level

  data = dce_rpc_pipe_request(fid:handle[1], code:OPNUM_LSASECURITYOBJECT, data:data);
  if (!data)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'dce_rpc_pipe_request()');
    return NULL;
  }

  rep = dce_rpc_parse_response (fid:handle[1], data:data);
  if (!rep || (strlen (rep) < 16))
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:16);
    return NULL;
  }

  resp = get_dword (blob:rep, pos:strlen(rep)-4);
  if (resp != STATUS_SUCCESS)
  {
    _debug_smb_status_not_success(fname:FUNCTION_NAME);
    return NULL;
  }

  ref_id = get_dword (blob:rep, pos:0);
  if (isnull(ref_id))
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'ref_id');
    return NULL;
  }

  size = get_dword (blob:rep, pos:4);
  ref_id = get_dword (blob:rep, pos:8);
  if (isnull(ref_id))
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'ref_id 2nd dig');
    return NULL;
  }

  size = get_dword (blob:rep, pos:12);
  if (strlen(rep) < (size+16))
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'dce_rpc_parse_response() return', length:size+16);
    return NULL;
  }

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Parsing security descriptor to return');
  return parse_security_descriptor (blob:substr(rep, 16, strlen(rep)-5));
}


#---------------------------------------------------------#
# Function    : LsaClose                                  #
# Description : Close lsa handle                          #
# Return      : 1 on success                              #
#---------------------------------------------------------#

function direct_LsaClose (handle)
{
  var data, rep, code, ret;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Closing LSA');

  code = NULL;

  data = dce_rpc_pipe_request (fid:handle[1], code:OPNUM_LSACLOSE, data:handle[0]);
  if (data)
  {
    rep = dce_rpc_parse_response (fid:handle[1], data:data);
    if (rep && (strlen (rep) == 24))
    {
      # NULL handle (useless) + code
      # Return code
      code = get_dword (blob:rep, pos:20);
    }
  }

  if (handle[2] == 1)
    ret = smb_close (fid:handle[1]);

  if (isnull (code) || (code != STATUS_SUCCESS) || (ret != 1))
  {
    _debug_smb_status_not_success(fname:FUNCTION_NAME);
    return NULL;
  }

  return 1;
}
