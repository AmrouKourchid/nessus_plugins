#TRUSTED 60c0ed04fef7ac37f5045337639178c61679053ee1906ecb2192c957b1c91c5e5bee5d1ced4610a6c40ab66ea650a406dea42c56fae36b135f8dec9d8ec0439bdfd9188fe5990fe6c680b9d85924b5f8a789236d8e7e9db58b5b2191666c58bca1304747acc5eeabd800f95b17d6db7c0d2babab94cf38f6bcd2f48e7bbaa64a899cf8d1e20b0063a110721844a0e7bf3996172edc951f8df0cc8e01b105879d6cecd40de86f3e83e81a7d0f6390a71cbfec26b2e2d15fe2f9b1cc89be2fa8db233870afb70930c0b2248b3d1063c8f3b4b2cc619cc5469d5e5b0c4461190e46dac013f1853dd769ee76d70da391323a5122338a78fcc105a9aa223956339a4a3607c065f90d78b4174c385f7705c64f1ebabb8a418d53ac94c5d164895c119b1ef3c96a728a26dcf26d77c6ba3dc7be4a7eb95686d8fc4745c94d065574407895d6253d109efbb21470a7db335e341c0a53db8403c6405e65ad605b691544fead431f38fef1c1bc15ca3af66721484b35873d733ea267ae378c2999355955752c9df64f0d8501bb1837dde97e4bb041eac7d53ab4b137f6442558d9ee9816675c3e907464cf0b453aac6287dae0fec262a91129da8769cf46c809b54a066920a5699d86ece846419aec4a052af572efaf6ca40e154c81b9f3f38675f0cdd1627938c97af388844079e9548b2ddc15c5050cec61280a14015c26dfbfbd6b09db
###
# (C) Tenable Network Security, Inc.
#
# This script is released under one of the Tenable Script Licenses and may not
# be used from within scripts released under another license without the
# authorization from Tenable Network Security Inc.
#
# Revision:1.3
#
###

##
#
#  Namespace sshlib
#    Provides an encapsulated naming scope for sshlib functions and objects
#
##
namespace sshlib
{

  ##
  #
  # Object cipher
  #    cipher this object managed the encryption and decrption of
  #    keys and generates the HMAC for the keys
  #
  ##
  object cipher
  {
    var block_size = 16;

    var iv_len;
    var key_len;
    var mac_len;

    #Length of the authentication token that accompanies the ciphertext with
    #authenticated ciphers like aes-gcm.
    var tag_len;

    var crypto_alg = NULL;
    var mac_alg = NULL;

    var enc_keys;
    var session;

    ##
    # Set the crypto algorithm and the block size, iv_len, key_len and tag_len
    # based on the name of the crypto algorithm being used.
    #
    # @anonparam <first> the string name of the crypto alg being used
    # @category SSH
    #
    # @return no return
    ##
    public function set_crypto_alg()
    {
      crypto_alg = _FCT_ANON_ARGS[0];
      if(crypto_alg =~ "^blowfish-cbc$")
      {
        block_size = 8;
        iv_len     = 8;
        key_len    = 16;
        tag_len    = 0;
      }
      else if(crypto_alg =~ "^aes128-c(bc|tr)$")
      {
        block_size = 16;
        iv_len     = 16;
        key_len    = 16;
        tag_len    = 0;
      }
      else if(crypto_alg =~ "^aes192-c(bc|tr)$")
      {
        block_size = 16;
        iv_len     = 16;
        key_len    = 24;
        tag_len    = 0;
      }
      else if(crypto_alg =~ "^aes256-c(bc|tr)$")
      {
        block_size = 16;
        iv_len     = 16;
        key_len    = 32;
        tag_len    = 0;
      }
      else if(crypto_alg =~ "^aes128-gcm")
      {
        block_size = 16;
        iv_len     = 12;
        key_len    = 16;
        tag_len    = 16;
      }
      else if(crypto_alg =~ "^aes256-gcm")
      {
        block_size = 16;
        iv_len     = 12;
        key_len    = 32;
        tag_len    = 16;
      }
      else if(crypto_alg =~ "^3des-cbc$")
      {
        block_size = 8;
        iv_len     = 8;
        key_len    = 24;
        tag_len    = 0;
      }
    }

    ##
    # Set algorithm and mac length based on alg name
    #
    # @anonparam <first> the string name of the alg being used
    # @category SSH
    #
    # @return no return
    ##
    public function set_mac_alg()
    {
      mac_alg = _FCT_ANON_ARGS[0];
      if(mac_alg =~ "^hmac-sha1$")
        mac_len = 20;
      else if(mac_alg =~ "^hmac-sha2-256")
        mac_len = 32;
      else if(mac_alg =~ "^hmac-sha2-512")
        mac_len = 64;
      else if(mac_alg =~ "^umac-128")
        mac_len = 16;
    }

    ##
    # Set the enc keys generated by ssh_derive_keys
    #
    # @anonparam <first> the enc key value to set
    # @category SSH
    #
    # @return no return
    ##
    public function set_enc_keys() {enc_keys = _FCT_ANON_ARGS[0];}

    ##
    # Set the current session
    #
    # @anonparam <first> session handle
    # @category SSH
    #
    # @return no return
    ##
    public function set_session() {session = _FCT_ANON_ARGS[0];}

    ##
    # Compute and return the HMAC hash
    #
    # @param <data> string of data to compute HMAC from
    # @param <mode> An integer signifying the direction of communication to set a
    #        compression algorithm for.  MODE_IN = 0, MODE_OUT = 1
    # @category SSH
    #
    # @return hmac hash as a string
    ##
    public function mac_compute(data, mode)
    {
      local_var hash, key, nonce;

      if (mode == MODE_IN)
      {
        if(mac_alg =~ "^umac-128")
          nonce = mkdword(0) + mkdword(session.seqn_r);
        else
          data = mkdword(session.seqn_r, order:BYTE_ORDER_BIG_ENDIAN) + data;
        key = enc_keys[5];
      }
      else
      {
        if(mac_alg =~ "^umac-128")
          nonce = mkdword(0) + mkdword(session.seqn_w);
        else
          data = mkdword(session.seqn_w, order:BYTE_ORDER_BIG_ENDIAN) + data;
        key = enc_keys[4];
      }

      if (mac_alg == "hmac-sha1")
        hash = HMAC_SHA1(data:data, key:key);
      else if (mac_alg =~ "^hmac-sha2-256")
        hash = HMAC_SHA256(data:data, key:key);
      else if (mac_alg =~ "^hmac-sha2-512")
        hash = HMAC_SHA512(data:data, key:key);
      else if(mac_alg =~ "^umac-128")
      {
        if(strlen(data) > 2**17)
        {
          #This should never occur since the max SSH message is 65K, but, if it does.....
          session.set_error('cipher: umac-128 was selected for a message size exceeding 128K.\n');
          return NULL;
        }

        hash = umac_128(data:data, nonce:nonce, key:key, length:mac_len);
      }

      return hash;
    }

    ##
    # Encrypt the data passed in. The type of encryption
    # is based on the paramaters set in set_crypto_alg.
    #
    # @param <data> the data to encrypt
    # @category SSH
    #
    # @return encrypted version of the data
    ##
    public function encrypt(data)
    {
      if (isnull(enc_keys))
      {
        return NULL;
      }
      # Pad out data to block size
      if(strlen(data) % block_size != 0)
      {
        data += crap(data:'\0', length:(block_size - (strlen(data) % block_size)));
      }
      local_var crypted;
      if (crypto_alg == "blowfish-cbc")
      {
        crypted = bf_cbc_encrypt(data:data, key:enc_keys[2], iv:enc_keys[0]);
      }
      else if ("aes" >< crypto_alg)
      {
        if ("cbc" >< crypto_alg)
        {
          crypted = aes_cbc_encrypt(data:data, key:enc_keys[2], iv:substr(enc_keys[0], 0, 15));
        }
        else if("gcm" >< crypto_alg)
        {
          var iv = substr(enc_keys[0], 0, 11);
          var gcm_crypted = crypto_encrypt(type:'aes_gcm', data:data, key:enc_keys[2],
              iv:iv,
              options: {taglen:tag_len, aad:mkdword(strlen(data))});



          crypted[0] = [];
          crypted[0][0] = gcm_crypted['ciphertext'];
          crypted[0][1] = gcm_crypted['tag'];

          #https://tools.ietf.org/html/rfc5647 Section 7.1
          crypted[1] = bn_add(iv, mkbyte(1)) + crap(data:'\0', 4);
        }
        else
        {
          crypted = aes_ctr_encrypt(data:data, key:enc_keys[2], iv:substr(enc_keys[0], 0, 15));
        }
      }
      else if (crypto_alg == "3des-cbc")
      {
        crypted = tripledes_cbc_encrypt(data:data, key:enc_keys[2], iv:enc_keys[0]);
      }
      # Update crypto state
      enc_keys[0] = crypted[1];
      return crypted[0];
    }

    ##
    # Decrypt the data passed in. The type of decryption
    # is based on the paramaters set in set_crypto_alg.
    #
    # @param <data> the data to decrypt
    # @category SSH
    #
    # @return decrpyted version of the data
    ##
    public function decrypt(data)
    {
      if (isnull(enc_keys))
      {
        return NULL;
      }
      local_var decrypted;

      if (strlen(data) % block_size != 0)
      {
        data += crap(data:'\0', length:(block_size - (strlen(data) % block_size)));
      }

      if (crypto_alg == "blowfish-cbc")
      {
        decrypted = bf_cbc_decrypt(data:data, key:enc_keys[3], iv:enc_keys[1]);
      }
      else if ("aes" >< crypto_alg)
      {
        if ("cbc" >< crypto_alg)
        {
          decrypted = aes_cbc_decrypt(data:data, key:enc_keys[3], iv:substr(enc_keys[1], 0, 15));
        }
        else if("gcm" >< crypto_alg)
        {
          var tag_end = strlen(data) - 1;
          var tag_start = tag_end - tag_len;

          var tag = substr(data, tag_start + 1, tag_end);
          data = substr(data, 0, tag_start);

          var iv = substr(enc_keys[1], 0, 11);
          decrypted[0] = crypto_decrypt(type:'aes_gcm', data:data,
              key:enc_keys[3],
              iv:iv,
              options: {taglen:tag_len, tag:tag, aad:mkdword(strlen(data))});

          #https://tools.ietf.org/html/rfc5647 Section 7.1
          decrypted[1] = bn_add(iv, mkbyte(1)) + crap(data:'\0', 4);
        }
        else
        {
          decrypted = aes_ctr_decrypt(data:data, key:enc_keys[3], iv:substr(enc_keys[1], 0, 15));
        }
      }
      else if (crypto_alg == "3des-cbc")
      {
        decrypted = tripledes_cbc_decrypt(data:data, key:enc_keys[3], iv:enc_keys[1]);
      }
      # Update crypto state
      enc_keys[1] = decrypted[1];
      return decrypted[0];
    }
  }

  ##
  #
  # Object cipherset
  #    This object managed the encryption and decrption of
  #    keys and generates the HMAC for the keys
  #
  #    This is a management class for the cipher class.
  #    This class will abstract the instance of sshlib::cipher and
  #    manage the objects interactions
  #    See sshlib::cipher for better detail on the inter workings.
  ##
  object cipherset
  {
    var cipher_s_to_c, cipher_c_to_s;

    ##
    # Define a set of cipher objects
    #
    # @category SSH
    #
    # @return no return
    ##
    function cipherset()
    {
      cipher_s_to_c = new("sshlib::cipher");
      cipher_c_to_s = new("sshlib::cipher");
    }

    ##
    # passthrough to sshlib::cipher::set_crypto_alg
    #
    # @param <mode> An integer signifying the direction of communication to enable
    #        compression for.  MODE_IN = 0, MODE_OUT = 1
    # @category SSH
    #
    # @return no return
    ##
    public function set_crypto_alg(mode)
    {
      if(mode == MODE_IN)
        cipher_s_to_c.set_crypto_alg(_FCT_ANON_ARGS[0]);
      else if(mode == MODE_OUT)
        cipher_c_to_s.set_crypto_alg(_FCT_ANON_ARGS[0]);
    }

    ##
    # passthrough to sshlib::cipher::set_mac_alg
    #
    # @param <mode> An integer signifying the direction of communication to enable
    #        compression for.  MODE_IN = 0, MODE_OUT = 1
    # @category SSH
    #
    # @return no return
    ##
    public function set_mac_alg(mode)
    {
      if(mode == MODE_IN)
        cipher_s_to_c.set_mac_alg(_FCT_ANON_ARGS[0]);
      else if(mode == MODE_OUT)
        cipher_c_to_s.set_mac_alg(_FCT_ANON_ARGS[0]);
    }

    ##
    # Trucate the key
    # passthrough to sshlib::cipher::set_enc_keys
    #
    # @anonparam <first>
    # @category SSH
    #
    # @return no return
    ##
    public function set_enc_keys()
    {
      var keys = truncate_keys(keys:_FCT_ANON_ARGS[0]);
      cipher_s_to_c.set_enc_keys(keys);
      cipher_c_to_s.set_enc_keys(keys);
    }

    ##
    # passthrough to sshlib::cipher::set_session
    #
    # @anonparam <first> the session to set
    # @category SSH
    #
    # @return no return
    ##
    public function set_session()
    {
        cipher_s_to_c.set_session(_FCT_ANON_ARGS[0]);
        cipher_c_to_s.set_session(_FCT_ANON_ARGS[0]);
    }

    ##
    # passthrough to sshlib::cipher::encrypt
    #
    # @param <data> the data to encrypt
    # @category SSH
    #
    # @return encrypted data
    ##
    public function encrypt(data)
    {
      return cipher_c_to_s.encrypt(data:data);
    }

    ##
    # passthrough to sshlib::cipher::decrypt
    #
    # @param <data> the data to decrypt
    # @category SSH
    #
    # @return decrypted data
    ##
    public function decrypt(data)
    {
      return cipher_s_to_c.decrypt(data:data);
    }

    ##
    # passthrough to sshlib::cipher::mac_compute
    #
    # @param <mode> An integer signifying the direction of communication to enable
    #        compression for.  MODE_IN = 0, MODE_OUT = 1
    # @param data data used to compute the mac
    # @category SSH
    #
    # @return
    ##
    public function mac_compute(mode, data)
    {
      if(mode == MODE_IN)
        return cipher_s_to_c.mac_compute(data:data, mode:mode);
      else if(mode == MODE_OUT)
        return cipher_c_to_s.mac_compute(data:data, mode:mode);
    }

    ##
    # Find the largest cipher len size from the
    # block size, iv length, key length, and mac length
    #
    # @category SSH
    #
    # @return integer the size of the largest length
    ##
    public function get_ciphers_need()
    {
      var need = 0;

      if(need < cipher_c_to_s.block_size) need = cipher_c_to_s.block_size;
      if(need < cipher_c_to_s.iv_len) need = cipher_c_to_s.iv_len;
      if(need < cipher_c_to_s.key_len) need = cipher_c_to_s.key_len;
      if(need < cipher_c_to_s.mac_len) need = cipher_c_to_s.mac_len;

      if(need < cipher_s_to_c.block_size) need = cipher_s_to_c.block_size;
      if(need < cipher_s_to_c.iv_len) need = cipher_s_to_c.iv_len;
      if(need < cipher_s_to_c.key_len) need = cipher_s_to_c.key_len;
      if(need < cipher_s_to_c.mac_len) need = cipher_s_to_c.mac_len;

      return need;
    }

    ##
    # reduce the size of all the items in the key array by 1
    #
    # @param keys the keys generated by sshlib::kex_handler::ssh_derive_keys
    # @category SSH
    #
    # @return trunkated versions of the keys array
    ##
    function truncate_keys(keys)
    {
      #         MODE OUT  MODE IN
      # enc.iv    0         1
      # enc.key   2         3
      # mac.key   4         5

      keys[0] = substr(keys[0], 0, cipher_c_to_s.iv_len - 1);
      keys[1] = substr(keys[1], 0, cipher_s_to_c.iv_len - 1);

      keys[2] = substr(keys[2], 0, cipher_c_to_s.key_len - 1);
      keys[3] = substr(keys[3], 0, cipher_s_to_c.key_len - 1);

      keys[4] = substr(keys[4], 0, cipher_c_to_s.mac_len - 1);
      keys[5] = substr(keys[5], 0, cipher_s_to_c.mac_len - 1);

      return keys;
    }

    ##
    # Is the mac cipher "encrypt then mac" etm?
    #
    # @param <mode> An integer signifying the direction of communication to enable
    #        compression for.  MODE_IN = 0, MODE_OUT = 1
    # @category SSH
    #
    # @returns TRUE if the MAC cipher for the indicated mode is an
    #          encrypt then MAC cipher.
    ##
    public function is_etm(mode)
    {
      if(mode == MODE_IN)
        return cipher_s_to_c.mac_alg =~ "-etm@openssh.com$";
      else if(mode == MODE_OUT)
        return cipher_c_to_s.mac_alg =~ "-etm@openssh.com$";
    }

    ##
    # Is the encryption cipher AES using Galois Counter Mode?
    #
    # @param <mode> An integer signifying the direction of communication to enable
    #        compression for.  MODE_IN = 0, MODE_OUT = 1
    # @category SSH
    # @remark Reference: https://tools.ietf.org/html/rfc5647
    # @returns TRUE if the encryption cipher for the indicated mode is an
    #          AES cipher that uses Galois Counter Mode.
    ##
    public function is_gcm(mode)
    {
      if(mode == MODE_IN)
        return "gcm" >< cipher_s_to_c.crypto_alg;
      else if(mode == MODE_OUT)
        return "gcm" >< cipher_c_to_s.crypto_alg;
    }

    ##
    # Get the mac length set in the sshlib::cipher object
    #
    # @param <mode> An integer signifying the direction of communication to enable
    #        compression for.  MODE_IN = 0, MODE_OUT = 1
    # @category SSH
    #
    # @return integer mac length
    ##
    public function get_mac_len(mode)
    {
      if(mode == MODE_IN)
        return cipher_s_to_c.mac_len;
      else if(mode == MODE_OUT)
        return cipher_c_to_s.mac_len;
    }

    ##
    # Get the tag length set in the sshlib::cipher object
    #
    # @param <mode> An integer signifying the direction of communication to enable
    #        compression for.  MODE_IN = 0, MODE_OUT = 1
    # @category SSH
    #
    # @return integer tag, or authentication token, length
    ##
    public function get_tag_len(mode)
    {
      if(mode == MODE_IN)
        return cipher_s_to_c.tag_len;
      else if(mode == MODE_OUT)
        return cipher_c_to_s.tag_len;
    }

    ##
    # Get the block size set in the sshlib::cipher object
    #
    # @param <mode> An integer signifying the direction of communication to enable
    #        compression for.  MODE_IN = 0, MODE_OUT = 1
    # @category SSH
    #
    # @return
    ##
    public function get_block_size(mode)
    {
      if(mode == MODE_IN)
        return cipher_s_to_c.block_size;
      else if(mode == MODE_OUT)
        return cipher_c_to_s.block_size;
    }

    ##
    # Get the key length set in the sshlib::cipher object
    #
    # @param <mode> An integer signifying the direction of communication to enable
    #        compression for.  MODE_IN = 0, MODE_OUT = 1
    # @category SSH
    #
    # @return
    ##
    public function get_key_length(mode)
    {
      if(mode == MODE_IN)
        return cipher_s_to_c.key_len;
      else if(mode == MODE_OUT)
        return cipher_c_to_s.key_len;
    }
  }
}
