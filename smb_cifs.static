#TRUSTED 5261e1b29461b21ae37b4a02735641e8b661002b4c5867e94a931de161d53a3b854557b2a74d2a47d9ac15bff3115fa2f4bb1ae5ca1e00f8fc85a76dc71d59c81523efaa2a7e2150ad42228f226f3f3ab344ed43b8a5e2b905974e68e96b0dc590e6cdb119dd8f9179a5fbc0fa852c5c57982d25bb54fd899a3c8d3049e88c39bf32b6cbc898c4954a3f11398e3d1276f750206641650c17f1fb95673b8018d9aea537b995f25441f5630a120edfaccf070a701c31f4e20b7f8e05bff217f26afbd82e20415fef146970c3c097d5b65027c2bdd3079080da91cbe8d1fc5952f6214afe9e6f6daa2d5fd24e3c897917774316e6bf1072f149a214cade957ac7db06d3451586ec80b8b6b9a8d2ebdf34dff02d6ce3a1576d21c033921862d8e3eb837e467a898a1507c07e06e2b1a86acf59daad09b7585cbd0013420f9bda3b1df50f352308414329c4e252d426aa8f25e01dcff7222911d51f5b24020a86d4ce3af2f4e7551e5e276867181bf779b4e22e7be085c9e236c0632e6b49d895a74e6677fd5b16e9bcfd41eb65eda28aa3c781501352d5f5f1137175a3fda33750a6667db15f8bfaad6995ebaf4c42ec734d0a27dea4191ad073691871654f6fbd976fef8269e4a9a28f6a6fe842762ea2fcee82da8be7a7f14d005c857e9fd9900c0118585b6c93375ec7577189600b210fa2248ee4ad5e6a7a3b6e7750b2f06888
#TRUST-RSA-SHA256 24e102032f0fda5c0294c8982d4e81862c9c09487c8c44be7fcfadb0b1a9dba341c2d8fea9c4697812282374c4cf5192a73b1a505d2762eea80e05a1850bb48cb10a8be54262a640cf4a9931b82681da45bbfa918625a5e5842a345eccbd2fc34f77301b09b62af54e72ee7ae0b24996204df7ea87f4ed42119de653a2458094cef9208752416741dccbe5e4cd17c16864aeca64ba6726e3e3bc786e1c37deda544a6c79da72ee5f20fa25b3df4319460b19bdf5af3fd49e9eb35117d6fc02a3298fa67d1e3b906f756579ddc1239a757edc712ece72fc182bc77b46f8d4a4fad68f5ed455e963ff186481bb572dd4b7b6c11de147513241575199a7024ad9fdf09eaaac776e7cf762e91e7c8361580cd99f17dededd2321e9f3625dafaa51c8b371793a688ebcf019689910916c3a04014a9691db7f2dd8559abc36ccf1c5e403c5454af5d7155d0489d9959117448b47d4753827b5101962bffd1e2b53ac22363a8ab4e186cdc1cd368c1e1d8781f13304460272721ce8fad38039614b8f204a129b9e13b2544c8a9f1ab55c62c144661ad3ff0bf90a3bdc925987be01208f4f7054111962a14f644f56401c9d1ec732bbe33b34ae880209b8069f9623cc7bdd4fa92810b299f72cb58459f807051f87e898cb3c5fcd71a3927dba19d97254ade618f12d13c1af70ced1978efc03e31c7d26a30c1f545253e16357a7ae4464
#------------------------------------------------------------------------------
#
# (C) Tenable Network Security, Inc.
#
# This script is released under one of the Tenable Script Licenses and may not
# be used from within scripts released under another license without the
# authorization from Tenable Network Security, Inc.
#
# @NOGPL@
#
# smb_cifs.inc
# Revision: 1.36
#



#==================================================================#
# Section 3. SMB functions                                         #
#==================================================================#


#---------------------------------------------------------#
# Function    : smb_parameters                            #
# Description : Create SMB parameters structure           #
#---------------------------------------------------------#

function smb_parameters (data)
{
  var count;

  if ( !data )
    count = 0;
  else
    count = strlen (data) / 2;

  return raw_byte (b:count) + data;
}


#---------------------------------------------------------#
# Function    : smb_data                                  #
# Description : Create SMB data structure                 #
#---------------------------------------------------------#

function smb_data (data)
{
  var count;

  if ( isnull(data) )
    count = 0;
  else
    count = strlen (data);

  return raw_word (w:count) + data;
}


function netbios_header (type, length)
{
  return raw_byte (b:type) +
         raw_string ( (length>>16) & 255, (length>>8) & 255, (length) & 255 );
}


#---------------------------------------------------------#
# Function    : netbios_packet                            #
# Description : Convert SMB to netbios packet             #
#---------------------------------------------------------#
#                                                         #
# BYTE Type;       # 0 = session message                  #
# BYTE Length[3];  # length is on 24bits                  #
#                                                         #
#---------------------------------------------------------#

function netbios_packet (header,parameters,data)
{
  var length, netbios, head, hash, MAC, key;

  key = session_get_mackey();

  if (key)
  {
    hash = MD5 (key + header + parameters + data);
    MAC = substr( hash, 0, 7);
    head = substr (header, 0, 13) + MAC + substr (header, 22, 31);
    previous_hash = MAC;
  }
  else
    head = header;

  length = strlen (head) + strlen (parameters) + strlen (data);

  netbios = netbios_header (type:0, length:length) +
            head + parameters + data;

  return netbios;
}


#---------------------------------------------------------#
# Function    : smb_recv                                  #
# Description : Receive network smb packet                #
#---------------------------------------------------------#

function smb_recv ()
{
  var header, len, trailer, socket, timeout, tmp, hash, key;

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'SMB receiving');
  socket = session_get_socket ();
  if (!socket)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'session_get_socket()');
    return NULL;
  }
  timeout = session_get_timeout ();

  header = recv(socket:socket, length:4, min:4, timeout:timeout);
  if (strlen(header) < 4)
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'Header', length:4);
    return NULL;
  }

  len = 65535 * ord(header[1]) +
        256 * ord(header[2]) +
        ord(header[3]);

  if (len < 32)
  {
    dbg::detailed_log(lvl:1, family:'SMB', src:FUNCTION_NAME, msg:
      'Len of ' + len + ' is less than 32!');
    return NULL;
  }

  if (len > 100000)
    len = 100000;

  trailer = recv(socket:socket, length:len, min:len, timeout:timeout);
  if (strlen(trailer) < len )
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'Trailer', length:len);
    return NULL;
  }

  if ( session_get_mackey() )
  {
    key = session_get_mackey();

    tmp = substr (trailer,0,13) + raw_dword (d:session_get_sequencenumber()) + raw_dword (d:0) + substr (trailer, 22, strlen(trailer)-1);
    hash = substr(MD5 (key + tmp),0,7);

    # if signature is not correct we stop
    if (hash >!< substr(trailer, 14, 21))
    {
      if (strlen (key) == 16)
      {
        session_set_mackey (key:crap(data:raw_string(0),length:16));
        tmp = substr (trailer,0,13) + raw_dword (d:session_get_sequencenumber()) + raw_dword (d:0) + substr (trailer, 22, strlen(trailer)-1);
        hash = substr(MD5 (session_get_mackey () + tmp),0,7);

        # guest logon disable smb signing
        if (previous_hash >< substr(trailer, 14, 21))
          session_set_mackey (key:NULL);

        # if signature is not correct we stop
        else if (hash >!< substr(trailer, 14, 21))
        {
          dbg::detailed_log(lvl:1, family:'SMB', src:FUNCTION_NAME, msg:
          'Signature hash is missing from trailer!');
          return NULL;
        }
      }
      else
      {
        _debug_smb_length(fname:FUNCTION_NAME, varname:'Keyr', length:16, operator:'is not');
        return NULL;
      }
    }
  }

  if (session_get_mackey())
    session_increase_sequencenumber();

  dbg::detailed_log(
    lvl:3,
    family:'SMB',
    src:FUNCTION_NAME,
    msg:'smb_recv response',
    msg_details:{
      "Data":{"lvl":3, "value":trailer}
    });
  return trailer;
}


#---------------------------------------------------------#
# Function    : smb_sendrecv                              #
# Description : Perform a client/server exchange          #
#---------------------------------------------------------#

function smb_sendrecv(data)
{
  var socket;

  socket = session_get_socket();

  if (!socket)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'session_get_socket()');
    return NULL;
  }

  send (socket:socket, data:data);

  if (session_get_mackey())
    session_increase_sequencenumber();

  return smb_recv ();
}


#---------------------------------------------------------#
# Function    : get_header_flags                          #
# Description : Extract Flags                             #
#---------------------------------------------------------#

function get_header_flags(header)
{
  return get_byte (blob:header, pos:9);
}


#---------------------------------------------------------#
# Function    : get_header_flags2                         #
# Description : Extract Flags2                            #
#---------------------------------------------------------#

function get_header_flags2(header)
{
  return get_word (blob:header, pos:10);
}


#---------------------------------------------------------#
# Function    : get_header_dos_error_code                 #
# Description : Extract DOS Error code                    #
#---------------------------------------------------------#

function get_header_dos_error_code(header)
{
  return get_word (blob:header, pos:7);
}


#---------------------------------------------------------#
# Function    : get_header_nt_error_code                  #
# Description : Extract NT Error code                     #
#---------------------------------------------------------#

function get_header_nt_error_code(header)
{
  return get_dword (blob:header, pos:5);
}


#---------------------------------------------------------#
# Function    : get_header_command_code                   #
# Description : Extract Command code                      #
#---------------------------------------------------------#

function get_header_command_code(header)
{
  return get_byte (blob:header, pos:4);
}


#---------------------------------------------------------#
# Function    : get_header_uid                            #
# Description : Extract User ID                           #
#---------------------------------------------------------#

function get_header_uid(header)
{
  return get_word (blob:header, pos:28);
}


#---------------------------------------------------------#
# Function    : get_header_tid                            #
# Description : Extract Tree ID                           #
#---------------------------------------------------------#

function get_header_tid(header)
{
  return get_word (blob:header, pos:24);
}


#---------------------------------------------------------#
# Function    : get_header_signature                      #
# Description : Extract Signature                         #
#---------------------------------------------------------#

function get_header_signature(header)
{
  return substr (header,14,21);
}


#---------------------------------------------------------#
# Function    : get_smb_header                            #
# Description : Extract SMB header from blob              #
#---------------------------------------------------------#

function get_smb_header(smbblob)
{
  if (strlen (smbblob) < SMB_HDR_SIZE)
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'smbblob', length:SMB_HDR_SIZE);
    return NULL;
  }

  return substr (smbblob, 0, SMB_HDR_SIZE - 1);
}


#---------------------------------------------------------#
# Function    : get_smb_parameters                        #
# Description : Extract SMB parameters from blob          #
#---------------------------------------------------------#

function get_smb_parameters(smbblob)
{
  var WordCount;

  if (strlen (smbblob) < SMB_HDR_SIZE + 1)
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'smbblob', length:SMB_HDR_SIZE + 1);
    return NULL;
  }

  WordCount = get_byte (blob:smbblob, pos:SMB_HDR_SIZE);
  if (strlen (smbblob) < (SMB_HDR_SIZE + 1 + WordCount * 2))
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'smbblob', length:(SMB_HDR_SIZE + 1 + WordCount * 2));
    return NULL;
  }

  return substr (smbblob, SMB_HDR_SIZE + 1, SMB_HDR_SIZE + 1 + WordCount * 2);
}


#---------------------------------------------------------#
# Function    : get_smb_data                              #
# Description : Extract SMB data from blob                #
#---------------------------------------------------------#

function get_smb_data(smbblob)
{
  var WordCount, ByteCount, pos;

  if (strlen (smbblob) < SMB_HDR_SIZE + 1)
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'smbblob', length:(SMB_HDR_SIZE + 1 + WordCount * 2));
    return NULL;
  }

  WordCount = get_byte (blob:smbblob, pos:SMB_HDR_SIZE);
  if (strlen (smbblob) < (SMB_HDR_SIZE + 1 + WordCount * 2 + 2))
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'smbblob', length:(SMB_HDR_SIZE + 1 + WordCount * 2 + 2));
    return NULL;
  }
  pos = SMB_HDR_SIZE + 1 + WordCount * 2;

  ByteCount = get_word (blob:smbblob, pos:pos);

  if (strlen (smbblob) < (pos + 2 + ByteCount))
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'smbblob', length:(pos + 2 + ByteCount));
    return NULL;
  }

  return substr (smbblob, pos + 2, pos + 2 + ByteCount - 1);
}


#---------------------------------------------------------#
# Function    : smb_header                                #
# Description : Generate header of SMB packet             #
#---------------------------------------------------------#
#                                                         #
# SMB header structure                                    #
#                                                         #
# struct {                                                #
#   BYTE  Protocol[4];      # "\xFFSMB"                   #
#   BYTE  Command;                                        #
#   DWORD Status;           # Or BYTE ErrorClass;         #
#                           #    BYTE Reserved;           #
#                           #    WORD Error;              #
#   BYTE  Flags;                                          #
#   WORD  Flags2;                                         #
#   WORD  PidHigh;          # 0 like noone know it        #
#   BYTE  Signature[8];                                   #
#   WORD  Reserved;                                       #
#   WORD  Tid;              # Tree ID                     #
#   WORD  Pid;              # Process ID                  #
#   WORD  Uid;              # User ID                     #
#   WORD  Mid;              # Multiplex ID                #
# }                                                       #
#                                                         #
#---------------------------------------------------------#

function smb_header (Command, Status, Flags, Flags2, Bsrspyl)
{
  var header, fl, fl2;

  if (!isnull (Flags))
    fl = Flags;
  if (!isnull (Flags2))
    fl2 = Flags2;

  header = '\xFFSMB';
  header += raw_byte(b:Command);
  header += Status;
  header += raw_byte (b:session_get_flags() | fl);
  header += raw_word (w:session_get_flags2() | fl2);
  header += raw_word (w:0);
  if ( Bsrspyl )
    header += 'BSRSPYL ';
  else
    header += raw_dword (d:session_get_sequencenumber()) + raw_dword (d:0);

  header += raw_word (w:0);
  header += raw_word (w:session_get_tid());
  header += raw_word (w:session_get_pid());
  header += raw_word (w:session_get_uid());
  header += raw_word (w:session_get_mid());

  return header;
}


function get_fid_from_data(data)
{
  var parameters = get_smb_parameters (smbblob:data);
  if(strlen(parameters) < 7)
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'parameters', length:7);
    return NULL;
  }

  return get_word(blob:parameters, pos:5); # FID
}


function smb_check_success (data, op_desc, report_kb_failure, text)
{
  var header, flags2, code, fid, desc;

  if (isnull(report_kb_failure)) report_kb_failure=FALSE;

  # Some checks in the header first
  header = get_smb_header (smbblob:data);
  if (!header)
    return FALSE;

  flags2 = get_header_flags2 (header:header);
  if (flags2 & SMB_FLAGS2_32BIT_STATUS)
  {
    code = get_header_nt_error_code (header:header);

    if (report_kb_failure && code == STATUS_ACCESS_DENIED)
    {
      if (!text)
         fid = get_fid_from_data(data:data);
      desc = smb_get_problem_description(fid:fid, op_desc:op_desc, text:text);
      smb_set_kb_auth_problem(desc:desc);
    }

    if (code != STATUS_SUCCESS)
      return FALSE;
  }
  else
  {
    code = get_header_dos_error_code (header:header);

    if (report_kb_failure && code == ERROR_ACCESS_DENIED)
    {
      if (!text)
        fid = get_fid_from_data(data:data);
      desc = smb_get_problem_description(fid:fid, op_desc:op_desc, text:text);
      smb_set_kb_auth_problem(desc:desc);
    }

    if (code != NO_ERROR)
      return FALSE;
  }

  return TRUE;
}


#-----------------------------------------------------------------#
# Encode name and service to the netbios network format           #
#-----------------------------------------------------------------#

function netbios_encode(data,service)
{
  var tmpdata, ret, i, o, odiv, omod, c;

  ret = "";
  tmpdata = data;

  while (strlen(tmpdata) < 15)
  {
    tmpdata += " ";
  }

  tmpdata += raw_string(service);

  for(i=0;i<16;i=i+1)
  {
    o = ord(tmpdata[i]);
    odiv = o/16;
    odiv = odiv + ord("A");
    omod = o%16;
    omod = omod + ord("A");
    c = raw_string(odiv, omod);

    ret = ret+c;
  }

  return raw_byte (b:strlen(ret)) + ret;
}


#-----------------------------------------------------------------#
# Convert a netbios name to the netbios network format            #
#-----------------------------------------------------------------#

function netbios_name(orig)
{
  return netbios_encode(data:orig, service:0x20);
}


function netbios_sendrecv (type, data)
{
  var req, socket, timeout, header, len, trailer;

  req = netbios_header (type:type, length:strlen(data)) +
        data;

  socket = session_get_socket();
  if (!socket)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'session_get_socket()');
    return NULL;
  }
  timeout = session_get_timeout ();

  send (socket:socket, data:req);

  header = recv(socket:socket, length:4, min:4, timeout:timeout);
  if (strlen(header) < 4)
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'header', length:4);
    return NULL;
  }

  len = 65535 * ord(header[1]) +
        256 * ord(header[2]) +
        ord(header[3]);

  if (len > 100000)
    len = 100000;

  trailer = recv(socket:socket, length:len, min:len, timeout:timeout);
  if (strlen(trailer) < len )
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'trailer', length:len);
    return NULL;
  }

  return header + trailer;
}





#==================================================================#
# Section 4. Netbios Functions                                     #
#==================================================================#

function netbios_session_request ()
{
  var req, resp, rep, port, called_name, calling_name, name, data;

  port = kb_smb_transport ();
  if (port == 445)
    return TRUE;

  name = get_kb_item ("SMB/netbios_name");
  if (name == TRUE)
    called_name = netbios_name (orig:session_get_hostname());
  else
    called_name = netbios_name (orig:"*SMBSERVER");

  calling_name = netbios_name (orig:NULL);

  data = called_name + raw_byte (b:0) +
         calling_name + raw_byte (b:0);
  rep = netbios_sendrecv (type:0x81, data:data);
  if (!rep)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'netbios_sendrecv()');
    return NULL;
  }

  if (ord(rep[0]) != 0x82)
    return FALSE;

  return TRUE;
}



#==================================================================#
# Section 4a. CIFS Functions                                       #
#==================================================================#


#---------------------------------------------------------#
# Function    : smb_negotiate_protocol                    #
# Description : Negotiate the SMB protocol to use         #
#---------------------------------------------------------#
#                                                         #
# SMB header :                                            #
#    Command : SMB_COM_NEGOTIATE                          #
#              Status = STATUS_SUCCESS                    #
#              Flags  = SMB_FLAGS_CANONICAL_PATHNAMES |   #
#                       SMB_FLAGS_CASELESS_PATHNAMES      #
#              Flags2 = SMB_FLAGS2_UNICODE_STRINGS |      #
#                       SMB_FLAGS2_KNOWS_LONG_NAMES       #
#              PidHig = 0                                 #
#              Signature = NULL (0,0..)                   #
#              Tid    = 0                                 #
#              Uid    = 0                                 #
#              Mid    = 2                                 #
#                                                         #
# SMB parameters :                                        #
#   BYTE  WordCount;      # 0                             #
#                                                         #
# SMB data :                                              #
#   WORD ByteCount;       # Number of byte                #
#   {                                                     #
#    BYTE BufferFormat;   # 0x02 (Dialect)                #
#    BYTE Name[];         # NTLM 0.12                     #
#   }                                                     #
#   {                                                     #
#    ...                  # PC NETWORK PROGRAM 1.0        #
#                         # MICROSOFT NETWORKS 1.03       #
#                         # MICROSOFT NETWORKS 3.0        #
#                         # LANMAN1.0                     #
#                         # LM1.2X002                     #
#                         # Samba                         #
#                         # NT LANMAN 1.0                 #
#   }                     # NT LM 0.12                    #
#                                                         #
#---------------------------------------------------------#

function smb_negotiate_protocol (extended)
{
  var header, parameters, data, packet, ret, i, ns;

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Attempting protocol negotiate');

  if (isnull(extended) || (extended == TRUE))
  {
    header = smb_header (Command: SMB_COM_NEGOTIATE,
                         Status : nt_status (Status: STATUS_SUCCESS),
                         Flags2 : SMB_FLAGS2_EXTENDED_SECURITY);
  }
  else
  {
    header = smb_header (Command: SMB_COM_NEGOTIATE,
                         Status : nt_status(Status:STATUS_SUCCESS));
  }
  parameters = smb_parameters (data:NULL); # No parameters

  data = NULL;
  ns = supported_protocol;

  if (!session_smb2_support())
    ns-=2;

  for (i = 0; i < ns; i++)
  {
    data += raw_byte (b:0x02) + ascii (string:protocol[i]);
  }

  # Watermark for PVS to flag communications coming from Nessus
  data += raw_byte(b:0x02) + ascii(string:"Tenable Nessus");

  data = smb_data (data:data);

  packet = netbios_packet (header:header, parameters:parameters, data:data);

  return smb_sendrecv (data:packet);
}




#---------------------------------------------------------#
# Function    : smb_session_setup_andx_lanman_core        #
# Description : Create SMB packet for LANMAN2.1 setupandx #
#---------------------------------------------------------#
#                                                         #
# SMB parameters :                                        #
#   BYTE  WordCount;                                      #
#   BYTE  Command;                                        #
#   BYTE  Reserved;                                       #
#   WORD  Offset;                                         #
#   WORD  MaxBufferSize;                                  #
#   WORD  MaxMpxCount;                                    #
#   WORD  VcNumber;                                       #
#   DWORD SessionKey;                                     #
#   WORD  PasswordLength;                                 #
#   DWORD Reserved;                                       #
#                                                         #
# SMB data :                                              #
#   WORD ByteCount;                                       #
#   BYTE Password[];                                      #
#   BYTE AccountName[];                                   #
#   BYTE PrimaryDomain[];                                 #
#   BYTE NativeOS[];                                      #
#   BYTE NativeLanMan[];                                  #
#                                                         #
#---------------------------------------------------------#

function smb_session_setup_andx_lanman_core (session_key,login,domain,password,hash,mode,challenge)
{
  var name,dom,pass,header,parameters,data,packet,response,code,flags2,skey,guest,ret,uid,sig;
  var os_info, domain_info, lan_info, mult;

  header = smb_header (Command: SMB_COM_SESSION_SETUP_ANDX,
                       Status: nt_status (Status: STATUS_SUCCESS),
                       Bsrspyl:TRUE);

  # LANMAN2.1 names are uppercase and ascii
  name = toupper(login);
  dom = toupper (domain);
  pass = toupper (password);

  # If challenge/response mode we generate the response, else we keep plain text password
  if (pass && (mode & NEGOTIATE_SECURITY_CHALLENGE_RESPONSE))
  {
    response = LM_Response (password:cstring (string:pass), challenge:challenge, hash:hash);

    pass = response[0];
    skey = response[1] + response[0];
  }

  parameters = raw_byte (b:255) + # no further command
               raw_byte (b:0) +
               raw_word (w:0) +
               raw_word (w:session_get_buffersize()) +
               raw_word (w:1) +
               raw_word (w:0) +
               raw_dword (d:session_key) +
               raw_word (w:strlen(pass)) +
               raw_dword (d:0);

  parameters = smb_parameters (data:parameters);

  data = pass +
         cstring (string:name) +
         cstring (string:dom) +
         cstring (string:nes_native_os) +
         cstring (string:nes_native_lanman);

  data = smb_data (data:data);

  packet = netbios_packet (header:header, parameters:parameters, data:data);

  ret = smb_sendrecv (data:packet);
  if (!ret)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'smb_sendrecv()');
    return NULL;
  }

  if (smb_check_success (data:ret, op_desc:"session") == FALSE)
  {
    dbg::detailed_log(lvl:1, family:'SMB', src:FUNCTION_NAME, msg:
      'smb_check_success returned FALSE!');
    return NULL;
  }

  # Some checks in the header first
  header = get_smb_header (smbblob:ret);
  if (!header)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'get_smb_header()');
    return NULL;
  }

  sig = hexstr (get_header_signature (header:header));
  if ("0000000000000000" >!< sig)
  {
    # Security signatures are enabled only if server support them
    if (!session_get_mackey())
      session_set_mackey (key:skey);

    # we need to mark 2 previous exchange as signed
    session_increase_sequencenumber();
    session_increase_sequencenumber();
  }

  uid = get_header_uid (header:header);
  session_set_uid (uid:uid);

  # We now parse/take information in SMB parameters
  parameters = get_smb_parameters (smbblob:ret);
  if (!parameters || (strlen(parameters) < 6))
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'parameters', length:6);
    return NULL;
  }

  guest = get_word (blob:parameters, pos:4);
  session_set_guest (guest:guest);

  data = get_smb_data (smbblob:ret);

  os_info = get_string (blob:data, pos:0);
  if (session_is_unicode ())
    mult = 2;
  else
    mult = 1;
  lan_info = get_string (blob:data, pos: (strlen(os_info)+1)*mult);

  domain_info = NULL;

  session_set_host_info (domain:domain_info, os:os_info, lan:lan_info);

  return packet;
}



#---------------------------------------------------------#
# Function    : smb_session_setup_andx_ntlm_core          #
# Description : Create SMB packet for NTLM setupandx      #
#---------------------------------------------------------#
#                                                         #
# SMB parameters :                                        #
#   BYTE  WordCount;                                      #
#   BYTE  Command;                                        #
#   BYTE  Reserved;                                       #
#   WORD  Offset;                                         #
#   WORD  MaxBufferSize;                                  #
#   WORD  MaxMpxCount;                                    #
#   WORD  VcNumber;                                       #
#   DWORD SessionKey;                                     #
#   WORD  CaseInsensitivePasswordLength;                  #
#   WORD  CaseSensitivePasswordLength;                    #
#   DWORD Reserved;                                       #
#   DWORD Capabilities;                                   #
#                                                         #
# SMB data :                                              #
#   WORD  ByteCount;                                      #
#   BYTE  CaseInsensitivePassword[];                      #
#   BYTE  CaseSensitivePassword[];                        #
#   BYTE  Pad;        # present with unicode only         #
#   BYTE  AccountName[];                                  #
#   BYTE  PrimaryDomain[];                                #
#   BYTE  NativeOS[];                                     #
#   BYTE  NativeLanMan[];                                 #
#   BYTE  Pad2[];     # seems to be optional              #
#                                                         #
#---------------------------------------------------------#

function smb_session_setup_andx_ntlm_core (session_key, login, domain, password, lm_hash, ntlm_hash, mode, challenge, version)
{
  var name,dom,pass,spass,ipass,header,parameters,data,packet,response,code,flags2,skey,guest;
  var domain_info, os_info, lan_info, mult, ret, uid, hinfo;

  header = smb_header (Command: SMB_COM_SESSION_SETUP_ANDX,
                       Status: nt_status (Status: STATUS_SUCCESS),
                       Bsrspyl:TRUE);

  if (!(mode & NEGOTIATE_SECURITY_CHALLENGE_RESPONSE))
  {
    # SAMBA servers support plain text password in NTLM.
    # Implementing CIFS don't know exactly how to do with password.
    # Need to look at SAMBA code
    dbg::detailed_log(lvl:1, family:'SMB', src:FUNCTION_NAME, msg:
      'mode bitwise anded with challenge response not true!');
    return NULL;
  }

  ipass = spass = NULL;

  # NTLM use only unicode password
  if (session_is_unicode() == 0)
  {
    session_set_unicode (unicode:1);
    pass = cstring (string:password, _null:1);
    name = cstring (string:login, _null:1);
    dom = cstring (string:domain, _null:1);
    session_set_unicode (unicode:0);
  }
  else
  {
    pass = cstring (string:password, _null:1);
    name = cstring (string:login, _null:1);
    dom = cstring (string:domain, _null:1);
  }

  # If challenge/response mode we generate the response, else we keep plain text password
  if ((pass || lm_hash || ntlm_hash) && (mode & NEGOTIATE_SECURITY_CHALLENGE_RESPONSE))
  {
    # NOT WORKING !
    #response= NTLMv2_Response (password:pass, login:name, domain:dom, challenge:challenge);
    #spass = response[0];

    if (version == 2)
    {
      response = LMv2_Response (password:pass, login:name, hash:ntlm_hash, domain:dom, challenge:challenge);
      ipass = response[0];
      # Windows allways use unicode password for mac key
      # like it is null (NTLMv2 to fix) we use a null byte [16] array
      skey = response[1];
    }
    else
    {
      if (pass || ntlm_hash)
      {
        response = NTLM_Response (password:pass, hash:ntlm_hash, challenge:challenge);
        spass = response[0];
      }
      else
      {
        response = LM_Response (password:pass, hash:lm_hash, challenge:challenge);
        ipass = response[0];
      }
      skey = response[1] + response[0];
    }

    # Security signatures are enabled only if server support them
    if (!session_get_mackey() && ((mode & NEGOTIATE_SECURITY_SIGNATURES_REQUIRED) || (mode & NEGOTIATE_SECURITY_SIGNATURES_ENABLED)))
    session_set_mackey (key:skey);
  }

  parameters = raw_byte (b:255) + # no further command
               raw_byte (b:0) +
               raw_word (w:0) +
               raw_word (w:session_get_buffersize()) +
               raw_word (w:1) +
               raw_word (w:0) +
               raw_dword (d:session_key) +
               raw_word (w:strlen(ipass)) +
               raw_word (w:strlen(spass)) +
               raw_dword (d:0) +
               raw_dword (d: CAP_UNICODE * session_is_unicode() | CAP_LARGE_FILES | CAP_NT_SMBS | CAP_STATUS32 | CAP_LEVEL_II_OPLOCKS | CAP_NT_FIND );

  parameters = smb_parameters (data:parameters);

  # If Unicode we must add 1 byte pad
  if (session_is_unicode() == 1)
    spass += raw_string(0x00);

  data = ipass + spass +
         cstring (string:login) +
         cstring (string:domain) +
         cstring (string:nes_native_os) +
         cstring (string:nes_native_lanman);

  data = smb_data (data:data);

  packet = netbios_packet (header:header, parameters:parameters, data:data);

  ret = smb_sendrecv (data:packet);
  if (!ret)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'smb_sendrecv()');
    return NULL;
  }

  data = get_smb_data (smbblob:ret);

  if (strlen(data)%2)
    data = substr(data,1,strlen(data)-1);

  os_info = get_string (blob:data, pos:0);
  if (session_is_unicode ())
    mult = 2;
  else
    mult = 1;
  lan_info = get_string (blob:data, pos: (strlen(os_info)+1)*mult);
  domain_info = get_string (blob:data, pos: (strlen(os_info)+strlen(lan_info)+2)*mult);

  session_set_host_info (domain:domain_info, os:os_info, lan:lan_info);

  if (smb_check_success (data:ret, op_desc:"session") == FALSE)
  {
    dbg::detailed_log(lvl:1, family:'SMB', src:FUNCTION_NAME, msg:
      'smb_check_success returned FALSE!');
    return NULL;
  }

  # Some checks in the header first
  header = get_smb_header (smbblob:ret);
  if (!header)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'get_smb_header()');
    return NULL;
  }

  uid = get_header_uid (header:header);
  session_set_uid (uid:uid);

  # We now parse/take information in SMB parameters
  parameters = get_smb_parameters (smbblob:ret);
  if (!parameters || (strlen(parameters) < 6))
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'parameters', length:6);
    return NULL;
  }

  guest = get_word (blob:parameters, pos:4);
  session_set_guest (guest:guest);

  return packet;
}



#---------------------------------------------------------#
# Function    : smb_session_setup_andx_kerberos_core      #
# Description : Create SMB packet for Kerberos setupandx  #
#---------------------------------------------------------#

function smb_session_setup_andx_kerberos_core (session_key,login,password,realm,host,mode)
{
  var name,dom,pass,spass,ipass,header,parameters,data,packet,response;
  var uid, bloblength, securityblob, guest, key, kerb_data, flags2, code, ret;

  header = smb_header (Command: SMB_COM_SESSION_SETUP_ANDX,
                       Status: nt_status (Status: STATUS_SUCCESS),
                       Bsrspyl:TRUE);

  kerb_data = kerberos_securityblob(login:login,password:password,realm:realm,host:host);
  if (isnull(kerb_data))
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'kerberos_securityblob()');
    return NULL;
  }

  securityblob = kerb_data[1];

  parameters = raw_byte (b:255) + # no further command
               raw_byte (b:0) +
               raw_word (w:0) +
               raw_word (w:session_get_buffersize()) +
               raw_word (w:1) +
               raw_word (w:0) +
               raw_dword (d:session_key) +
               raw_word (w:strlen(securityblob)) +
               raw_dword (d:0) +
               raw_dword (d: CAP_UNICODE * session_is_unicode() | CAP_LARGE_FILES | CAP_NT_SMBS | CAP_STATUS32 | CAP_LEVEL_II_OPLOCKS | CAP_NT_FIND | CAP_EXTENDED_SECURITY);

  parameters = smb_parameters (data:parameters);

  # If strlen (securityblob) even add 1 pad byte
  if ((strlen (securityblob) % 2) == 0)
    securityblob += raw_string(0x00);

  data = securityblob +
         cstring (string:nes_native_os) +
         cstring (string:nes_native_lanman);

  data = smb_data (data:data);

  packet = netbios_packet (header:header, parameters:parameters, data:data);

  ret = smb_sendrecv (data:packet);
  if (!ret)
  {
    dbg::detailed_log(lvl:1, family:'SMB', src:FUNCTION_NAME, msg:'
      Kerberos session setup failed.  Returning NULL.');
    return NULL;
  }

  # Some checks in the header first
  header = get_smb_header (smbblob:ret);
  if (!header)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'get_smb_header()');
    return NULL;
  }
  flags2 = get_header_flags2 (header:header);
  if (flags2 & SMB_FLAGS2_32BIT_STATUS)
  {
    code = get_header_nt_error_code (header:header);
    if (code != STATUS_SUCCESS)
    {
      _debug_smb_status_not_success(fname:FUNCTION_NAME);
      return NULL;
    }
  }
  else
  {
    code = get_header_dos_error_code (header:header);
    dbg::detailed_log(lvl:1, family:'SMB', src:FUNCTION_NAME, msg:
      'Kerberos header dos error code indicates failure: ' +
      serialize(code) + ' Returning NULL.');
    if (code != NO_ERROR)
    {
      _debug_smb_status_not_success(fname:FUNCTION_NAME, status:'NO_ERROR');
      return NULL;
    }
  }

  uid = get_header_uid (header:header);
  session_set_uid (uid:uid);

  # We now parse/take information in SMB parameters
  parameters = get_smb_parameters (smbblob:ret);
  if (!parameters || (strlen(parameters) < 8))
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'parameters', length:6);
    return NULL;
  }
  guest = get_word (blob:parameters, pos:4);
  session_set_guest (guest:guest);

  bloblength = get_word (blob:parameters, pos:6);

  # We now parse/take information in SMB parameters
  data = get_smb_data (smbblob:ret);
  if (!data)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'get_smb_data()');
    return NULL;
  }

  if (strlen(data) < bloblength)
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'data', length:bloblength);
    return NULL;
  }

  securityblob = substr (data, 0, bloblength - 1);
  if (!securityblob)
  {
    dbg::detailed_log(lvl:1, family:'SMB', src:FUNCTION_NAME, msg:
      'Failed to extract server security blob.  Returning NULL.');
    return NULL;
  }

  key = check_kerberos_response (data:securityblob, key:kerb_data[0]);
  if (isnull(key))
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'check_kerberos_response()');
    return NULL;
  }

  if (!session_get_mackey() && ((mode & NEGOTIATE_SECURITY_SIGNATURES_REQUIRED) || (mode & NEGOTIATE_SECURITY_SIGNATURES_ENABLED)) && (login))
  {
   if (key[0] == 0)
     session_set_mackey (key:kerb_data[0]);
   else
     session_set_mackey (key:key[1]);

   session_increase_sequencenumber();
   session_increase_sequencenumber();
  }

  dbg::detailed_log(
    lvl:3,
    family:'SMB',
    src:FUNCTION_NAME,
    msg:'Packet setup seems to have worked',
    msg_details:{
       "Data":{"lvl":3, "value":packet}
    });
  return packet;
}


#---------------------------------------------------------#
# Function    : smb_session_setup_andx_ntlmssp_core       #
# Description : Create SMB packet for ntlmssp setupandx   #
#---------------------------------------------------------#

function smb_session_setup_andx_ntlmssp_core (session_key,login,password,hash,domain,mode)
{
  var name,dom,pass,header,parameters,data,packet,response,uid,guest, bloblength, ret, code;
  var challenge, securityblob,securityblob_length,d_name,h_info,os_info,lan_info,mult,hinfo;
  var sblob, skey, i;

  header = smb_header (Command: SMB_COM_SESSION_SETUP_ANDX,
                       Status: nt_status (Status: STATUS_SUCCESS),
                       Bsrspyl:TRUE);

  securityblob = ntlmssp_negotiate_securityblob ();

  parameters = raw_byte (b:255) + # no further command
               raw_byte (b:0) +
               raw_word (w:0) +
               raw_word (w:session_get_buffersize()) +
               raw_word (w:1) +
               raw_word (w:1) +
               raw_dword (d:session_key) +
               raw_word (w:strlen(securityblob)) +
               raw_dword (d:0) +
               raw_dword (d: CAP_UNICODE * session_is_unicode() | CAP_LARGE_FILES | CAP_NT_SMBS | CAP_STATUS32 | CAP_LEVEL_II_OPLOCKS | CAP_NT_FIND | CAP_EXTENDED_SECURITY);

  parameters = smb_parameters (data:parameters);

  # If strlen (securityblob) even add 1 pad byte
  if ((strlen (securityblob) % 2) == 0)
    securityblob += raw_string(0x00);

  data = securityblob +
         cstring (string:nes_native_os) +
         cstring (string:nes_native_lanman) +
         cstring (string:domain);

  data = smb_data (data:data);

  packet = netbios_packet (header:header, parameters:parameters, data:data);

  ret = smb_sendrecv (data:packet);
  if (!ret)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'smb_sendrecv()');
    return NULL;
  }
  # Some checks in the header first
  header = get_smb_header (smbblob:ret);
  if (!header)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'get_smb_header()');
    return NULL;
  }

  code = get_header_nt_error_code (header:header);
  if (code != STATUS_MORE_PROCESSING_REQUIRED)
  {
    _debug_smb_status_not_success(fname:FUNCTION_NAME, status:'more processing required');
    return NULL;
  }

  uid = get_header_uid (header:header);
  session_set_uid (uid:uid);

  # We now parse/take information in SMB parameters
  parameters = get_smb_parameters (smbblob:ret);
  if (!parameters)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'get_smb_parameters()');
    return NULL;
  }

  bloblength = get_word (blob:parameters, pos:6);

  # We now parse/take information in SMB parameters
  data = get_smb_data (smbblob:ret);
  if (!data)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'get_smb_data()');
    return NULL;
  }

  if (strlen(data) < bloblength)
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'data', length:bloblength);
    return NULL;
  }

  securityblob = substr (data, 0, bloblength - 1);
  challenge = ntlmssp_parse_challenge(data:securityblob);
  if (isnull(challenge))
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'ntlmssp_parse_challenge()');
    return NULL;
  }

  session_set_addrlist(addrlist:challenge[3]);
  sblob = challenge[3];

  d_name = get_string2 (blob:challenge[1], pos:0, len:strlen(challenge[1]));
  challenge = challenge[0];

  # If bloblength is even account for extra 1 pad byte
  hinfo = substr(data,bloblength,strlen(data)-1);
  if ((strlen(hinfo) > 1) && ((bloblength % 2) == 0))
    hinfo = substr(hinfo, 1, strlen(hinfo)-1);

  os_info = get_string (blob:hinfo, pos:0);
  if (session_is_unicode ())
    mult = 2;
  else
    mult = 1;
  lan_info = get_string (blob:hinfo, pos: (strlen(os_info)+1)*mult);

  session_set_host_info (domain:d_name, os:os_info, lan:lan_info);

  if (login)
  {
    # NTLM use only unicode password
    if (session_is_unicode() == 0)
    {
      session_set_unicode (unicode:1);
      if (password)
        pass = cstring (string:password, _null:1);
      else
        pass = NULL;
      name = cstring (string:login, _null:1);
      dom = cstring (string:domain, _null:1);
      session_set_unicode (unicode:0);
    }
    else
    {
      pass = cstring (string:password, _null:1);
      name = cstring (string:login, _null:1);
      dom = cstring (string:domain, _null:1);
    }
  }
  else
  {
    name = NULL;
    pass = NULL;
    dom = NULL;
  }

  # generates a random key for the session
  skey = NULL;
  for (i=0 ; i<16; i++)
    skey += raw_string(rand()&0xFF);

  securityblob = ntlmssp_auth_securityblob (password:pass,login:name,hash:hash,domain:dom,challenge:challenge,skey:skey,sblob:sblob);
  if (isnull(securityblob))
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'ntlmssp_auth_securityblob()');
    return NULL;
  }

  # Security signatures are enabled only if server support them
  # We use null session_key as we used LMv2 only
  if (!session_get_mackey() && ((mode & NEGOTIATE_SECURITY_SIGNATURES_REQUIRED) || (mode & NEGOTIATE_SECURITY_SIGNATURES_ENABLED)) && (login))
    # session_set_mackey (key:crap(data:raw_string(0),length:16));
    session_set_mackey (key:securityblob[0]);

  securityblob = securityblob[1];

  header = smb_header (Command: SMB_COM_SESSION_SETUP_ANDX,
                       Status: nt_status (Status: STATUS_SUCCESS),
                       Bsrspyl:TRUE);

  parameters = raw_byte (b:255) + # no further command
               raw_byte (b:0) +
               raw_word (w:0) +
               raw_word (w:session_get_buffersize()) +
               raw_word (w:1) +
               raw_word (w:0) +
               raw_dword (d:session_key) +
               raw_word (w:strlen(securityblob)) +
               raw_dword (d:0) +
               raw_dword (d: CAP_UNICODE * session_is_unicode() | CAP_LARGE_FILES | CAP_NT_SMBS | CAP_STATUS32 | CAP_LEVEL_II_OPLOCKS | CAP_NT_FIND | CAP_EXTENDED_SECURITY);

  parameters = smb_parameters (data:parameters);

  # If strlen (securityblob) even add 1 pad byte
  if ((strlen (securityblob) % 2) == 0)
    securityblob += raw_string(0x00);

  data = securityblob +
         cstring (string:nes_native_os) +
         cstring (string:nes_native_lanman) +
         cstring (string:domain);

  data = smb_data (data:data);

  packet = netbios_packet (header:header, parameters:parameters, data:data);

  ret = smb_sendrecv (data:packet);
  if (!ret)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'smb_sendrecv() 2nd call');
    return NULL;
  }

  # Some checks in the header first
  header = get_smb_header (smbblob:ret);
  if (!header)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'get_smb_parameters() 2nd call');
    return NULL;
  }

  code = get_header_nt_error_code (header:header);
  if (code != STATUS_SUCCESS)
  {
    _debug_smb_status_not_success(fname:FUNCTION_NAME);
    return NULL;
  }
  uid = get_header_uid (header:header);
  session_set_uid (uid:uid);

  # We now parse/take information in SMB parameters
  parameters = get_smb_parameters (smbblob:ret);
  if (!parameters || (strlen(parameters) < 8))
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'parameters', length:8);
    return NULL;
  }

  guest = get_word (blob:parameters, pos:4);
  session_set_guest (guest:guest);

  bloblength = get_word (blob:parameters, pos:6);
  # We now parse/take information in SMB parameters
  data = get_smb_data (smbblob:ret);
  if (!data)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'smb_sendrecv() 3rd call');
    return NULL;
  }

  if (strlen(data) < bloblength)
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'data', length:bloblength, second:'the 3rd calls length of');
    return NULL;
  }
  securityblob = substr (data, 0, bloblength - 1);

  challenge = ntlmssp_parse_response (data:securityblob);
  if (isnull(challenge) || (challenge != 0)) # Accept Completed
  {
    dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
      'Accept Completed');
    return NULL;
  }

  return packet;
}




#---------------------------------------------------------#
# Function    : smb_session_setup_andx                    #
# Description : Authenticate to the remote host           #
#---------------------------------------------------------#

function smb_session_setup_andx (session_key, dialect, challenge, mode, extended, login, password, lm_hash, ntlm_hash, domain, host, realm)
{
  var packet, ct, onlyv2, only_kerb;
  var prefix = 'SMB1 authentication : ';

  # If cleartext is prohibited we return NULL
  ct = get_kb_item("SMB/dont_send_in_cleartext");
  if ((ct == "yes") && (!(mode & NEGOTIATE_SECURITY_CHALLENGE_RESPONSE)))
  {
    dbg::detailed_log(lvl:1, family:'SMB', src:FUNCTION_NAME, msg:
      'Do not sent in cleartext enabled, and mode bitwise anded with challenge response not true!');
    return NULL;
  }

  onlyv2 = get_kb_item ("SMB/dont_send_ntlmv1");
  only_kerb = get_kb_item ("SMB/only_use_kerberos");

  # If LANMAN2.1 protocol
  if (protocol[dialect] == "LANMAN2.1")
  {
    if (onlyv2)
    {
      smb_set_auth_failure(login:login, desc:prefix + 'SMB/dont_send_ntlmv1 is enabled. Dialect: ' + protocol[dialect]);
      dbg::detailed_log(lvl:1, family:'SMB', src:FUNCTION_NAME, msg:
        'SMB/dont_send_ntlmv1 is enabled. Dialect: ' + protocol[dialect]);
      return NULL;
    }

    packet = smb_session_setup_andx_lanman_core (
               session_key : session_key,
               login       : login,
               domain      : domain,
               password    : password,
               hash        : lm_hash,
               mode        : mode,
               challenge   : challenge);
    if (isnull(packet))
      smb_set_auth_failure(login:login, desc:prefix + 'smb_session_setup_andx_lanman_core() failed.');
    return packet;
  }
  # If NT LM 0.12 protocol
  if (protocol[dialect] == "NT LM 0.12")
  {
    if (isnull (extended))
    {
      if (password || ntlm_hash)
      {
        packet = smb_session_setup_andx_ntlm_core (
                   session_key : session_key,
                   login       : login,
                   domain      : domain,
                   password    : password,
                   lm_hash     : lm_hash,
                   ntlm_hash   : ntlm_hash,
                   mode        : mode,
                   challenge   : challenge,
                   version     : 2);

        if (isnull(packet)) prefix += 'smb_session_setup_andx_ntlm_core() failed with version 2 and ';
      }
      else
        packet = NULL;

      if (! packet )
      {
        if (onlyv2)
        {
          smb_set_auth_failure(login:login, desc:prefix + 'SMB/dont_send_ntlmv1 is enabled. Dialect: ' + protocol[dialect]);
          dbg::detailed_log(lvl:1, family:'SMB', src:FUNCTION_NAME, msg:
            'SMB/dont_send_ntlmv1 is enabled. Dialect: ' + protocol[dialect]);
          return NULL;
        }

        packet = smb_session_setup_andx_ntlm_core (
                   session_key : session_key,
                   login       : login,
                   domain      : domain,
                   password    : password,
                   lm_hash     : lm_hash,
                   ntlm_hash   : ntlm_hash,
                   mode        : mode,
                   challenge   : challenge,
                   version     : 1);
        if (isnull(packet))
        {
          smb_set_auth_failure(login:login, desc:prefix + 'smb_session_setup_andx_ntlmssp_core() failed with version 1. Dialect: ' + protocol[dialect]);
          dbg::detailed_log(lvl:1, family:'SMB', src:FUNCTION_NAME, msg:
            'smb_session_setup_andx_ntlmssp_core() failed with version 1. Dialect: ' + protocol[dialect]);
        }
      }
      return packet;
    }
    else
    {
      if ((extended == 2) && defined_func ("open_sock_kdc") && get_kb_item('KerberosAuth/enabled') && login && password && realm)
      {
        # If Kerberos
        packet = smb_session_setup_andx_kerberos_core (
                   session_key : session_key,
                   login       : login,
                   password    : password,
                   host        : host,
                   realm       : realm,
                   mode        : mode);

        if (!isnull (packet))
          return packet;

        prefix += 'smb_session_setup_andx_kerberos_core() failed and ';

        if(only_kerb)
        {
          var port = get_kb_item("Secret/SMB/kdc_port");
          if(isnull(port))
            port = 88;
          smb_set_auth_failure(login:login, port:port, desc:prefix + 'SMB/only_use_kerberos is enabled.');
          dbg::detailed_log(lvl:1, family:'SMB', src:FUNCTION_NAME, msg:
            'SMB/only_use_kerberos is enabled.');
          return NULL;
        }
      }

      # If NTLMSSP or if Kerberos failed
      packet = smb_session_setup_andx_ntlmssp_core (
                 session_key:session_key,
                 login:login,
                 password:password,
                 hash:ntlm_hash,
                 domain:domain,
                 mode:mode);
      if (isnull(packet))
        smb_set_auth_failure(login:login, desc:prefix + 'smb_session_setup_andx_ntlmssp_core() failed.');
      return packet;
    }
  }
}




#---------------------------------------------------------#
# Function    : smb_login                                 #
# Description : Negotiate authentication  with remote     #
#               host.                                     #
# Return      : Return 1 on success , 0 on failure        #
#---------------------------------------------------------#

function smb_login (login,password,domain,lm_hash,ntlm_hash)
{
  var ret, code, flags2, header, parameters, data, unicode, SecurityBlob, ServerGUID;
  var DialectIndex, SecurityMode, MaxBufferSize, SessionKey, Capabilities, EncryptionKeyLength, EncryptionKey, Extended;
  var realm,host, ext;
  var spnego, michlist, DomainName, next, ServerName;
  var prefix;

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Attemping login');

  host = realm = NULL;

  #
  # First step : Protocol negotiation
  #

  if (isnull(password) && isnull(ntlm_hash) && !isnull(lm_hash))
    ext = FALSE;
  else
    ext = TRUE;

  prefix = 'Initial SMB negotiation : ';
  ret = smb_negotiate_protocol (extended:ext);
  if (!ret || (strlen(ret) < 4))
  {
    smb_set_auth_failure(login:login, desc:prefix + 'smb_negotiate_protocol() failed.');
    _debug_smb_length(fname:FUNCTION_NAME, varname:'smb_negotiate_protocol() return', length:4);
    return NULL;
  }

  if (get_dword(blob:ret, pos:0) == 0x424d53fe)
    return smb2_login(negotiate:ret, login:login, password:password, domain:domain, lm_hash:lm_hash, ntlm_hash:ntlm_hash);

  prefix = 'SMB1 protocol negotiation : ';

  # Some checks in the header first
  header = get_smb_header (smbblob:ret);
  if (!header)
  {
    smb_set_auth_failure(login:login, desc:prefix + 'Failed to get SMB header from response.');
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'get_smb_header()');
    return NULL;
  }

  flags2 = get_header_flags2 (header:header);
  if (flags2 & SMB_FLAGS2_32BIT_STATUS)
  {
    code = get_header_nt_error_code (header:header);
    if (code != STATUS_SUCCESS)
    {
      smb_set_auth_failure(login:login, desc:prefix + 'Response header flags included an NT error code other than STATUS_SUCCESS (' + STATUS_SUCCESS + '). Received error code: ' + code);
      _debug_smb_status_not_success(fname:FUNCTION_NAME);
      return code;
    }
  }
  else
  {
    code = get_header_dos_error_code (header:header);
    if (code != NO_ERROR)
    {
      smb_set_auth_failure(login:login, desc:prefix + 'Response header included a DOS error code other than NO_ERROR (' + NO_ERROR + '). Received error code: ' + code);
      _debug_smb_status_not_success(fname:FUNCTION_NAME, status:'no error');
      return code;
    }
  }

  code = get_header_command_code (header:header);
  if (code != SMB_COM_NEGOTIATE)
  {
    smb_set_auth_failure(login:login, desc:prefix + 'Response header command code was not SMB_COM_NEGOTIATE (' + SMB_COM_NEGOTIATE + '). Received code: ' + code);
    _debug_smb_status_not_success(fname:FUNCTION_NAME, status:'smb com negotiate');
    return ERROR_BAD_COMMAND;
  }

  # We must get unicode or not here
  unicode = flags2 & SMB_FLAGS2_UNICODE_STRINGS;

  # We now parse/take information in SMB parameters
  parameters = get_smb_parameters (smbblob:ret);
  if (!parameters)
  {
    smb_set_auth_failure(login:login, desc:prefix + 'Failed to parse SMB parameters from response.');
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'get_smb_parameters()');
    return NULL;
  }

  # Negotiate protocol response parameters
  # NT LM 0.12                        LANMAN2.1
  # WORD  DialectIndex;               WORD  DialectIndex;
  # BYTE  SecurityMode;               WORD  SecurityMode;
  # WORD  MaxMpxCount;                WORD  MaxBufferSize;
  # WORD  MaxNumberVCs;               WORD  MaxMpxCount;
  # DWORD MaxBufferSize;              BYTE  MaxNumberVCs;
  # DWORD MaxRawSize;                 WORD  RawMode;
  # DWORD SessionKey;                 DWORD SessionKey;
  # DWORD Capabilities;               WORD  ServerTime;
  # DWORD SystemTimeLow;              WORD  ServerDate;
  # DWORD SystemTimeHigh;             WORD  ServerTimeZone;
  # WORD  ServerTimeZone;             WORD  EncryptionKeyLength;
  # BYTE  EncryptionKeyLength;        WORD  Reserved;
  # WORD  Reserved;

  DialectIndex = get_word (blob:parameters, pos:0);

  if (DialectIndex > (supported_protocol-1))
  {
    # Bad server's response. Because it asks for an unsupported protocol
    smb_set_auth_failure(login:login, desc:prefix + 'Server response requested an unsupported protocol. DialectIndex: ' + DialectIndex);
    dbg::detailed_log(lvl:1, family:'SMB', src:FUNCTION_NAME, msg:
      'Server response requested an unsupported protocol. DialectIndex: ' + DialectIndex);
    return NULL;
  }

  Extended = NULL;

  if (protocol[DialectIndex] == "NT LM 0.12")
  {
    SecurityMode = get_byte (blob:parameters, pos:2);
    MaxBufferSize = get_dword (blob:parameters, pos:7);
    SessionKey = get_dword (blob:parameters, pos:15);
    Capabilities = get_dword (blob:parameters, pos:19);
    EncryptionKeyLength = get_byte (blob:parameters, pos:33);

    if (Capabilities & CAP_UNICODE)
      session_set_unicode (unicode:1);
    else
      session_set_unicode (unicode:0);

    if ((SecurityMode & NEGOTIATE_SECURITY_SIGNATURES_REQUIRED) || (SecurityMode & NEGOTIATE_SECURITY_SIGNATURES_ENABLED))
      session_add_flags2 (flag:SMB_FLAGS2_SECURITY_SIGNATURE);

    if (Capabilities & CAP_EXTENDED_SECURITY)
      session_add_flags2 (flag:SMB_FLAGS2_EXTENDED_SECURITY);

    # We now parse/take information in SMB parameters
    data = get_smb_data (smbblob:ret);
    if (!data)
    {
      smb_set_auth_failure(login:login, desc:prefix + 'Failed to parse SMB data from response. Dialect: ' + protocol[DialectIndex]);
      _debug_smb_null_return(fname:FUNCTION_NAME, label:'get_smb_data()');
      return NULL;
    }

    # Negotiate protocol response data for NTLM
    # BYTE EncryptionKey[];
    # BYTE DomainName[]; // NULL terminated
    # BYTE ServerName[]; // NULL terminated

    if (Capabilities & CAP_EXTENDED_SECURITY)
    {
      if (strlen(data) < 16)
      {
        smb_set_auth_failure(login:login, desc:prefix + 'The server included extended security in capabilities, but the response data length is unexpectedly < 16.');
        _debug_smb_length(fname:FUNCTION_NAME, varname:'data', length:16);
        return NULL;
      }
      ServerGUID = substr (data, 0, 15);
      if ((strlen (data) > 16) && (login && password))
      {
        var mech;
        SecurityBlob = substr (data, 16, strlen(data) - 1);
        spnego = der_parse_spnego_init (sdata:SecurityBlob);

        if (!isnull (spnego) && (spnego[3] != NULL) &&
            (spnego[3] != "not_defined_in_RFC4178@please_ignore") &&
            (toupper(spnego[3]) != "NONE") # samba
        )
        {
          michlist = spnego[3];
          host = ereg_replace (pattern:"(.*?)\$?@.*", string:michlist, replace:"\1");
          realm = ereg_replace (pattern:".*\$?@(.*)", string:michlist, replace:"\1");
          Extended = 2; # Kerberos
        }
        # Check if Kerberos is supported by server, if so use it for auth
        else if(!isnull (spnego) && (spnego[0] != NULL) && MICROSOFT_KERBEROS_OID >< spnego[0])
        {
          realm  = domain;
          host   =  kb_smb_name();
          if(isnull(host) || host == get_host_ip())
            host = get_host_name();

          Extended = 2;
        }
        else
          Extended = 1;
      }
      else
      {
        Extended = 1; # NTLMSSP
        SecurityBlob = NULL;
      }
    }
    else
    {
      if (EncryptionKeyLength != 0)
        EncryptionKey = substr (data, 0, 7); # Always 8 byte length
      else
        EncryptionKey = NULL;

      if (strlen(data) > 8)
        DomainName = get_string (blob:data, pos:8);

      next = strlen(DomainName) + null_length();
      next += strlen(EncryptionKey);

      if (next  < strlen(data))
        ServerName = get_string (blob:data, pos:next);
    }
  }

  else if (protocol[DialectIndex] == "LANMAN2.1")
  {
    #LANMAN2.1 does not support unicode
    session_set_unicode (unicode:0);

    SecurityMode = get_word (blob:parameters, pos:2);
    MaxBufferSize = get_word (blob:parameters, pos:4);
    SessionKey = get_dword (blob:parameters, pos:11);
    EncryptionKeyLength = get_word (blob:parameters, pos:21);

    # We now parse/take information in SMB parameters
    data = get_smb_data (smbblob:ret);
    if (!data)
    {
      smb_set_auth_failure(login:login, desc:prefix + 'Failed to parse SMB data from response. Dialect: ' + protocol[DialectIndex]);
      _debug_smb_null_return(fname:FUNCTION_NAME, label:'get_smb_data() with LANMAN2.1');
      return NULL;
    }

    # BYTE EncryptionKey[];
    if (EncryptionKeyLength != 0)
      EncryptionKey = substr (data, 0, 7); # Always 8 byte length
    else
      EncryptionKey = NULL;
  }
  else
  {
    # Bad server's response. Because it asks for an unsupported protocol
    smb_set_auth_failure(login:login, desc:prefix + 'Server response requested an unsupported protocol. DialectIndex: ' + DialectIndex + ', Dialect: ' + protocol[DialectIndex]);
    dbg::detailed_log(lvl:1, family:'SMB', src:FUNCTION_NAME, msg:
      'Server response requested an unsupported protocol. DialectIndex: ' + DialectIndex + ', Dialect: ' + protocol[DialectIndex]);
    return NULL;
  }

  session_set_server_max_size (size:MaxBufferSize);
  if (MaxBufferSize > (session_get_buffersize() - 0x100))
  {
    if(MaxBufferSize + 0x100 > 0xffff)
     session_set_buffersize(size:0xffff);
    else
     session_set_buffersize(size:MaxBufferSize+0x100);
  }

  if (isnull(password) && isnull(ntlm_hash) && !isnull(lm_hash))
    Extended = NULL;

  # This function will call smb_set_auth_failure() itself with details
  # if there is an authentication failure
  ret = smb_session_setup_andx (session_key:SessionKey, dialect:DialectIndex, challenge:EncryptionKey, mode:SecurityMode, extended:Extended, login:login, password:password, domain:domain, lm_hash:lm_hash, ntlm_hash:ntlm_hash, host:host, realm:realm);

  if (isnull (ret))
  {
    dbg::detailed_log(lvl:1, family:'SMB', src:FUNCTION_NAME, msg:
      'Login unsuccessful');
    return 0;
  }
  else
  {
    dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
      'Login successful');
    return 1;
  }
}




#---------------------------------------------------------#
# Function    : smb_tree_connect_and_x                    #
# Description : Connects to a remote share                #
#---------------------------------------------------------#

function smb_tree_connect_and_x (share)
{
  var header, parameters, password, path, service, data, packet, ret, tid;

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Attempting tree connect to share ' + share);

  if (session_is_smb2())
  {
    ret = smb2_tree_connect(path:share);
    tid = session_get_tid();
  }
  else
  {

    header = smb_header (Command: SMB_COM_TREE_CONNECT_ANDX,
                         Status: nt_status (Status: STATUS_SUCCESS));

    parameters = raw_byte (b:255) + # no further command
                 raw_byte (b:0) +
                 raw_word (w:0) +
                 raw_word (w:0xC) +
                 raw_word (w:1); # strlen (password)

    parameters = smb_parameters (data:parameters);

    password = raw_string (0x00); # NULL password / To change for share authentication
    path = cstring (string:"\\", _null:1) + cstring (string:session_get_hostname(), _null:1) + cstring (string:"\", _null:1) + cstring (string:share);
    service = ascii (string:"?????");

    data = password + path + service;

    data = smb_data (data:data);

    packet = netbios_packet (header:header, parameters:parameters, data:data);

    ret = smb_sendrecv (data:packet);
    if (!ret)
    {
      _debug_smb_null_return(fname:FUNCTION_NAME, label:'smb tree connect');
      return NULL;
    }
    if (smb_check_success (data:ret, op_desc:"connect", text:"the '" + share + "' share") == FALSE)
    {
      _debug_smb_status_not_success(fname:FUNCTION_NAME);
      return NULL;
    }

    # Some checks in the header first
    header = get_smb_header (smbblob:ret);
    if (!header)
    {
      _debug_smb_null_return(fname:FUNCTION_NAME, label:'smb_get_header()');
      return NULL;
    }

    tid = get_header_tid (header:header);
    session_set_tid (tid:tid);
  }

  # Map fid to the name of the object being accessed
  smb_set_open_share_name(tid:int(tid), name:share);
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Potentially good return');
  return ret;
}


#---------------------------------------------------------#
# Function    : smb_create_and_x                          #
# Description : Connects to a remote file                 #
#---------------------------------------------------------#
function smb_create_and_x (name, desired_access, flags_attributes, share_mode, create_disposition, create_options, dont_record_access)
{
  var header, parameters, data, packet, ret, offset, fid, pad, filename;

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Attempting create on name ' + name);

  if (isnull(dont_record_access)) dont_record_access = FALSE;

  if (session_is_smb2())
  {
    ret = smb2_create(
      name:name,
      desired_access:desired_access,
      flags_attributes:flags_attributes,
      share_mode:share_mode,
      create_disposition:create_disposition,
      create_options:create_options,
      dont_record_access:dont_record_access
    );
  }
  else
  {
    header = smb_header (Command: SMB_COM_NT_CREATE_ANDX,
                         Status: nt_status (Status: STATUS_SUCCESS));

    pad = NULL;
    if (session_is_unicode() == 1)
      pad = raw_byte (b:0);

    filename = cstring (string:name);

    parameters = raw_byte (b:255) + # no further command
                 raw_byte (b:0) +
                 raw_word (w:0) +
                 raw_byte (b:0) +
                 raw_word (w:strlen(cstring(string:name,_null:1))) +
                 raw_dword (d:0x16)                +  # flags to change
                 raw_dword (d:0)                   +  # root fid
                 raw_dword (d:desired_access)      +  # access mask
                 raw_dword (d:0) + raw_dword (d:0) +  # allocation size
                 raw_dword (d:flags_attributes)    +  # file attributes
                 raw_dword (d:share_mode)          +  # share access
                 raw_dword (d:create_disposition)  +  # Disposition
                 raw_dword (d:create_options)      +  # create options
                 raw_dword (d:2)                   +  # impersonation
                 raw_byte  (b:3);                     # security flags

    parameters = smb_parameters (data:parameters);

    data = pad + filename;

    data = smb_data (data:data);

    packet = netbios_packet (header:header, parameters:parameters, data:data);

    ret = smb_sendrecv (data:packet);
    if (!ret)
    {
      _debug_smb_null_return(fname:FUNCTION_NAME, label:'smb create');
      return NULL;
    }

    if (smb_check_success (data:ret, op_desc:"open", text:name,
                           report_kb_failure:!dont_record_access) == FALSE)
    {
      _debug_smb_status_not_success(fname:FUNCTION_NAME);
      return NULL;
    }

    parameters = get_smb_parameters (smbblob:ret);
    if (!parameters || (strlen(parameters) < 63))
    {
      _debug_smb_length(fname:FUNCTION_NAME, varname:'parameters', length:63);
      return NULL;
    }

    offset = get_word (blob:parameters, pos:2);

    ret = NULL;
    ret[0] = get_word (blob:parameters, pos:5); # FID
    ret[1] = substr (parameters, 55, 62);       # SIZE
  }

  # Map fid to the name of the object being accessed
  if(isnull(name) || !strlen(name))
    name = smb_get_open_share_name(tid:int(session_get_tid()));

  smb_set_open_file_name(fid:int(ret[0]), name:name);

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Potentially good return');

  return ret;
}


#---------------------------------------------------------#
# Function    : smb_write_and_x                           #
# Description : writes to a remote pipe                   #
#---------------------------------------------------------#

function smb_write_and_x (fid, offset, mode, data)
{
  var header, parameters, dat, packet, ret, pad;

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Attempting write');

  if (session_is_smb2()) return smb2_write(fid:fid, offset:offset, data:data);

  pad = raw_byte (b:0);

  header = smb_header (Command: SMB_COM_WRITE_ANDX,
                       Status: nt_status (Status: STATUS_SUCCESS));

  parameters = raw_byte (b:255) +            # no further command
               raw_byte (b:0) +              # reserved
               raw_word (w:0) +              # andxoffset
               raw_word (w:fid) +            # fid
               raw_dword (d:offset) +        # offset
               raw_dword (d:0xFFFFFFFF) +    # reserved
               raw_word (w:mode) +           # write mode
               raw_word (w:strlen (data)) +  # remaining
               raw_word (w:0) +              # data length high
               raw_word (w:strlen (data)) +  # data length low
               raw_word (w:64) +             # data offset == 64
               raw_dword (d:0) ;             # high offset

  parameters = smb_parameters (data:parameters);

  dat = pad + data;

  dat = smb_data (data:dat);

  packet = netbios_packet (header:header, parameters:parameters, data:dat);

  ret = smb_sendrecv (data:packet);
  if (!ret)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'smb write');
    return NULL;
  }

  if (smb_check_success (data:ret, op_desc:"write", report_kb_failure:TRUE) == FALSE)
  {
    _debug_smb_status_not_success(fname:FUNCTION_NAME);
    return NULL;
  }

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Potentially good return');

  return 1;
}



#---------------------------------------------------------#
# Function    : smb_read_and_x                            #
# Description : reads on a remote pipe                    #
#---------------------------------------------------------#

function smb_read_and_x (fid, offset, length)
{
  var header, parameters, data, packet, ret, pad, code;

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Attempting read');

  if (session_is_smb2()) return smb2_read(fid:fid, offset:offset, length:length);

  header = smb_header (Command: SMB_COM_READ_ANDX,
                       Status: nt_status (Status: STATUS_SUCCESS));

  pad = raw_byte (b:0);

  parameters = raw_byte (b:255) +            # no further command
               raw_byte (b:0) +              # reserved
               raw_word (w:0) +              # andxoffset
               raw_word (w:fid) +            # fid
               raw_dword (d:offset) +        # offset
               raw_word (w:length) +         # Max count low
               raw_word (w:length) +         # Min count
               raw_dword (d:0xFFFFFFFF) +    # Reserved or max count high ?
               raw_word (w:length) +         # Remaining
               raw_dword (d:0) ;             # high offset

  parameters = smb_parameters (data:parameters);

  data = pad + smb_data (data:NULL);

  packet = netbios_packet (header:header, parameters:parameters, data:data);

  ret = smb_sendrecv (data:packet);
  if (!ret)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'smb read');
    return NULL;
  }

  header = get_smb_header (smbblob:ret);
  if (isnull (header))
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'smb_get_header()');
    return NULL;
  }

  code = get_header_nt_error_code(header:header);
  if ((code != STATUS_SUCCESS) && (code != STATUS_BUFFER_OVERFLOW))
  {
    _debug_smb_status_not_success(fname:FUNCTION_NAME, status:'success or buffer overflow');
    return NULL;
  }

  if (strlen(ret) < (SMB_HDR_SIZE+14))
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'ret', length:(SMB_HDR_SIZE+14));
    return NULL;
  }

  offset = get_word (blob:ret, pos:SMB_HDR_SIZE + 13);
  length = get_word (blob:ret, pos:SMB_HDR_SIZE + 11);

  if (strlen(ret) < (offset+length))
  {
    _debug_smb_length(fname:FUNCTION_NAME, varname:'ret', length:(offset+length));
    return NULL;
  }

  data = substr (ret, offset, offset+length-1);

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Potentially good return');
  return data;
}



#---------------------------------------------------------#
# Function    : smb_trans_and_x                           #
# Description : TransAndX Request                         #
#---------------------------------------------------------#

function smb_trans_and_x (extra_parameters, transname, param, data, max_pcount, sendonly)
{
  var header, parameters, dat, packet, ret, pad, trans, p_offset, d_offset, plen, dlen, elen, pad2, socket;

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Attempting trans');

  pad = pad2 = NULL;
  if (session_is_unicode () == 1)
    pad = raw_byte (b:0);
  else
    pad2 = raw_byte (b:0);

  header = smb_header (Command: SMB_COM_TRANSACTION,
                       Status: nt_status (Status: STATUS_SUCCESS));

  trans = cstring (string:transname);

  p_offset = 66 + strlen(trans) + strlen (extra_parameters);
  d_offset = p_offset + strlen (param);

  plen = strlen(param);
  dlen = strlen(data);
  elen = strlen(extra_parameters);

  parameters = raw_word (w:plen)            +   # total parameter count
               raw_word (w:dlen) +   # total data count
               raw_word (w:max_pcount)            +   # Max parameter count
               raw_word (w:0xFFFF)         +   # Max data count
               raw_byte (b:0)            +   # Max setup count
               raw_byte (b:0)            +   # Reserved
               raw_word (w:0)            +   # Flags
               raw_dword (d:0)           +   # Timeout
               raw_word (w:0)            +   # Reserved
               raw_word (w:plen)            +   # Parameter count
               raw_word (w:p_offset)           +   # Parameter offset
               raw_word (w:dlen) +   # Data count
               raw_word (w:d_offset)           +   # Data offset
               raw_byte (b:elen/2)            +   # Setup count
               raw_byte (b:0);               # Reserved

  parameters += extra_parameters;

  parameters = smb_parameters (data:parameters);

  dat = pad +
        trans +
        pad2 +
        raw_word (w:0) +
        param +
        data;

  dat = smb_data (data:dat);

  packet = netbios_packet (header:header, parameters:parameters, data:dat);

  if (isnull(sendonly))
  {
    ret = smb_sendrecv (data:packet);
    if (!ret)
    {
      _debug_smb_null_return(fname:FUNCTION_NAME, label:'smb trans');
      return NULL;
    }

    if (smb_check_success (data:ret, op_desc:"pipe", report_kb_failure:TRUE) == FALSE)
    {
      _debug_smb_status_not_success(fname:FUNCTION_NAME);
      return NULL;
    }

    dat = get_smb_data (smbblob:ret);
    if (isnull (dat))
    {
      _debug_smb_null_return(fname:FUNCTION_NAME, label:'get_smb_data()');
      return NULL;
    }

    dat = substr (dat, 1, strlen(dat)-1);
    dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
      'Trans successful, sendonly null');
    return dat;
  }
  else
  {
    socket = session_get_socket();
    if (!socket)
    {
      _debug_smb_null_return(fname:FUNCTION_NAME, label:'session_get_socket()');
      return NULL;
    }

    send (socket:socket, data:packet);

    if (session_get_mackey())
      session_increase_sequencenumber();
    dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
      'Trans successful, sendonly populated');
  }
}



#---------------------------------------------------------#
# Function    : smb_trans2                                #
# Description : Trans2 Request                            #
#---------------------------------------------------------#

function smb_trans2 (param, data, max_pcount, command)
{
  var header, parameters, dat, packet, ret, pad, trans, p_offset, d_offset, plen, dlen, elen;

    dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
      'Attempting trans2');

  header = smb_header (Command: SMB_COM_TRANSACTION2,
                       Status: nt_status (Status: STATUS_SUCCESS));

  pad = raw_byte (b:0);

  p_offset = 66;
  d_offset = p_offset + strlen (param);

  plen = strlen(param);
  dlen = strlen(data);

  parameters = raw_word (w:plen)         +   # total parameter count
               raw_word (w:dlen)         +   # total data count
               raw_word (w:max_pcount)   +   # Max parameter count
               raw_word (w:1000)         +   # Max data count
               raw_byte (b:0)            +   # Max setup count
               raw_byte (b:0)            +   # Reserved
               raw_word (w:0)            +   # Flags
               raw_dword (d:0)           +   # Timeout
               raw_word (w:0)            +   # Reserved
               raw_word (w:plen)         +   # Parameter count
               raw_word (w:p_offset)     +   # Parameter offset
               raw_word (w:dlen)         +   # Data count
               raw_word (w:d_offset)     +   # Data offset
               raw_byte (b:1)            +   # Setup count
               raw_byte (b:0)            +   # Reserved
               raw_word (w:command);         # command

  parameters = smb_parameters (data:parameters);

  dat = pad + param + data;

  dat = smb_data (data:dat);

  packet = netbios_packet (header:header, parameters:parameters, data:dat);

  ret = smb_sendrecv (data:packet);
  if (!ret)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'smb trans2');
    return NULL;
  }

  if (smb_check_success (data:ret, op_desc:"pipe", report_kb_failure:TRUE) == FALSE)
  {
    _debug_smb_status_not_success(fname:FUNCTION_NAME);
    return NULL;
  }

  dat = get_smb_data (smbblob:ret);
  if (isnull (dat))
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'get_smb_data()');
    return NULL;
  }

  dat = substr (dat, 1, strlen(dat)-1);

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Trans2 successful');
  return dat;
}


#---------------------------------------------------------#
# Function    : smb_nt_trans                              #
# Description : NT Trans Request                          #
#---------------------------------------------------------#

function smb_nt_trans (param, data, command, max_pcount, max_dcount)
{
  var header, parameters, dat, packet, ret, pad, trans, p_offset, d_offset, plen, dlen, elen;

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Attempting nt trans');

  header = smb_header (Command: SMB_COM_NT_TRANSACT,
                       Status: nt_status (Status: STATUS_SUCCESS));

  pad = raw_byte (b:0) + raw_word(w:0);

  p_offset = 76;
  d_offset = p_offset + strlen (param);

  plen = strlen(param);
  dlen = strlen(data);

  parameters = raw_byte (b:0)            +   # Max setup count
               raw_word (w:0)            +   # Reserved
               raw_dword (d:plen)        +   # total parameter count
               raw_dword (d:dlen)        +   # total data count
               raw_dword (d:max_pcount)  +   # Max parameter count
               raw_dword (d:max_dcount)  +   # Max data count
               raw_dword (d:plen)        +   # Parameter count
               raw_dword (d:p_offset)    +   # Parameter offset
               raw_dword (d:dlen)        +   # Data count
               raw_dword (d:d_offset)    +   # Data offset
               raw_byte (b:0)            +   # Setup count
               raw_word (w:command);         # command

  parameters = smb_parameters (data:parameters);

  dat = pad + param + data;

  dat = smb_data (data:dat);

  packet = netbios_packet (header:header, parameters:parameters, data:dat);

  ret = smb_sendrecv (data:packet);
  if (!ret)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'smb nt trans');
    return NULL;
  }

  dat = get_smb_data (smbblob:ret);
  if (isnull (dat))
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'get_smb_data()');
    return NULL;
  }

  dat = substr (dat, 1, strlen(dat)-1);

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'NT Trans successful');
  return dat;
}


#---------------------------------------------------------#
# Function    : smb_trans_pipe                            #
# Description : TransAndX Pipe Request                    #
#---------------------------------------------------------#

function smb_trans_pipe (fid, data, sendonly)
{
  var parameters, ret;

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Attempting trans pipe');

  if (session_is_smb2())
  {
    ret = smb2_ioctl(fid:fid, code:FSCTL_PIPE_TRANSCEIVE, data:data);
    if (isnull (ret))
    {
      _debug_smb_null_return(fname:FUNCTION_NAME, label:'smb2_ioctl()');
      return NULL;
    }
    dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
      'Returning successful smb2 version');
    return ret[11];
  }
  else
  {
    parameters = raw_word (w:TRANS_PIPE) +
                 raw_word (w:fid);
    dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
      'Attempting trans and x');
    return smb_trans_and_x (extra_parameters:parameters, transname:"\PIPE\", param:NULL, data:data, max_pcount:0, sendonly:sendonly);
  }
}


#---------------------------------------------------------#
# Function    : smb_trans_lanman                          #
# Description : TransAndX LANMAN Request                  #
#---------------------------------------------------------#

function smb_trans_lanman (data)
{
  return smb_trans_and_x (extra_parameters:NULL, transname:"\PIPE\LANMAN", param:data, data:NULL, max_pcount:8);
}


#---------------------------------------------------------#
# Function    : smb_close                                 #
# Description : Close a pipe                              #
# Return      : 1 on success (else NULL)                  #
#---------------------------------------------------------#

function smb_close (fid)
{
  var header, parameters, data, packet, ret;

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Attempting close');

  if (session_is_smb2())
  {
    ret = smb2_close(fid:fid);
  }
  else
  {
    header = smb_header (Command: SMB_COM_CLOSE,
                         Status: nt_status (Status: STATUS_SUCCESS));

    parameters = raw_word (w:fid)          +   # FID
                 raw_dword (d:0xFFFFFFFF) ;    # Last write (not specified)

    parameters = smb_parameters (data:parameters);

    data = smb_data (data:NULL);

    packet = netbios_packet (header:header, parameters:parameters, data:data);

    ret = smb_sendrecv (data:packet);
    if (!ret)
    {
      _debug_smb_null_return(fname:FUNCTION_NAME, label:'smb close');
      return NULL;
    }

    if (smb_check_success (data:ret, op_desc:"close", report_kb_failure:TRUE) == FALSE)
    {
      _debug_smb_status_not_success(fname:FUNCTION_NAME);
      return NULL;
    }

    ret = 1;
  }

  # Unmap fid since file descriptors may be reused
  smb_set_open_file_name(fid:int(fid), name:NULL);
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Successful close');
  return ret;
}


#---------------------------------------------------------#
# Function    : smb_logoff_andx                           #
# Description : Close a session                           #
# Return      : 1 on success (else NULL)                  #
#---------------------------------------------------------#

function smb_logoff_andx ()
{
  var header, parameters, data, packet, ret;
  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Attempting logoff');

  if (session_is_smb2()) return smb2_logoff();

  header = smb_header (Command: SMB_COM_LOGOFF_ANDX,
                       Status: nt_status (Status: STATUS_SUCCESS));

  parameters = raw_byte (b:0xFF)         +   # No further command
               raw_byte (b:0)            +   # Reserved
               raw_word (w:0) ;              # AndXOffset

  parameters = smb_parameters (data:parameters);

  data = smb_data (data:NULL);

  packet = netbios_packet (header:header, parameters:parameters, data:data);

  ret = smb_sendrecv (data:packet);
  if (!ret)
  {
    _debug_smb_null_return(fname:FUNCTION_NAME, label:'smb logoff');
    return NULL;
  }

 if (smb_check_success (data:ret, op_desc:"logoff") == FALSE)
 {
   _debug_smb_status_not_success(fname:FUNCTION_NAME);
   return NULL;
 }

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Successful logoff');
  return 1;
}


#---------------------------------------------------------#
# Function    : smb_tree_disconnect                       #
# Description : Close a tree                              #
# Return      : 1 on success (else NULL)                  #
#---------------------------------------------------------#

function smb_tree_disconnect ()
{
  var header, parameters, data, packet, ret, tid;

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Attempting tree disconnect');

  tid = session_get_tid ();
  if (tid == 0)
    return 1;

  if (session_is_smb2())
  {
    ret = smb2_tree_disconnect();
  }
  else
  {
    header = smb_header (Command: SMB_COM_TREE_DISCONNECT,
                         Status: nt_status (Status: STATUS_SUCCESS));

    parameters = smb_parameters (data:NULL);

    data = smb_data (data:NULL);

    packet = netbios_packet (header:header, parameters:parameters, data:data);

    ret = smb_sendrecv (data:packet);
    if (!ret)
    {
      _debug_smb_null_return(fname:FUNCTION_NAME, label:'smb tree disconnect');
      return NULL;
    }

    if (smb_check_success (data:ret, op_desc:"disconnect") == FALSE)
    {
      _debug_smb_status_not_success(fname:FUNCTION_NAME);
      return NULL;
    }

    ret = 1;
  }

  # Unmap tid since share descriptors may be reused
  smb_set_open_share_name(tid:int(tid), name:NULL);

  session_set_tid (tid:0);

  dbg::detailed_log(lvl:3, family:'SMB', src:FUNCTION_NAME, msg:
    'Successful tree disconnect');
  return ret;
}
