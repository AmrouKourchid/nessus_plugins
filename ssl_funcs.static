#TRUSTED 03e8eea1aeaba2508cc189275db217e549385a5954378659b2f8a3975811a88bd0fef115868c3d91d73afb24b83b02a96af276fbf2ec04157bf4ebef30d906a60f635a3873b3c7de3287c278d22248a28840c8304d1e8ebab84b7b8711d8fdb4a8de50bd384a9351f292e692976b038266a76608dcf75fcc33f03eaffa75578afbe3ff6ed6763b94348c0aef8eb2d3400098febdd77cc2d9582baff9605c5610abb267726d65d83e1bb81f9c7daf712edab6000eede7dac67ff7ffcdcb28a9138e6e4423a04fba1a742512133cfa1b2509a6e69be041eef4f2cfbdaff7294d0ca89708255ef2282057c6ae544c4a47f5c5182a8a362abbe945ad0667d590da434fd0c9b4cd09ccb0f6d44520e635ac655b4f0c65255599ceb07108d6c5a579e2f03ee8c2a637d0a2d4f627222842da2a585a9794df1cfad537d00ad953bc614882931c7fb7e0dfbe6c8332a3d3a17546231cec6fbb9a9a76201057709ebf09f468788d2e16188247f83a826007c9d2d3ca500cd966c6bcb28947bfc758d5cec6d9e615e9a110f81d631a9fd5e30e55b0799225a43cbac9a11308110b3408a37ff340f2524432a2876956675cf3b17e7f8e1d874c50bb9415ce30895bca14eadf2d5f6e4753898bf1256ffbd460867be91e36a156a05b98aa644cbf46590ed26ab835c0c299d9a30e1a2447f0d0b72246f117aa36ebfa5a31f95e9f90221e8683
#TRUST-RSA-SHA256 74f9e39f29c215d9c62944d2340967a7c818608ac282621a9679935faaa38f424af50c7d678919fe7caa327dad8b3412949cecb133d29c9e7ba0f998ba0a27b0012ad837b742f5a44fa21f68b7507a0d2a093b28c159ae99db90045e5f61c66fb9d5a0a508c9d3cbd9bb7df2fb410cc72844d974fdc0f9661aed44c7304b849ca6a5e753a8209d0268ad76aa417cd2b57af254d8ff61c5e5c87d7e66614602269cc3c7023fbcd38d5471e3026d0425a3a1db0318fa4a170125f74e449dcb1901b0292b8f271f74455ab27a7e39e4bfa326e34a415f09b2e8c59035134f1222d3d2ed3883a93433f5af5a425691ad93e8580762250244325778968babd8083a7a59f71ee7ddfc0d8ef41f61f0ab51408fb6e47bf8c1ff9b3a9cb0f768ed42c9aeaae2910f1b5b5facbf163be0e0eb4b021c548eb774769bf687d6242a79675e18faaed2507b4effb2a0de67c4efa900fb83706ceac394a0c3aac2d24b1229c04c3801de4e00f5cf181b0ae79fa90b58e02102e83a8045ec380736196744ae70fdd61ac8b950b60c7fdc8840e7f2f526ab8267e46e862d49539fefebb04657745c199f71c2971fb8b3e827900891b93f9c09a88a714e944a8f214c193724062f5143c8013f7a56bfa05aecc5c829998fdb31d34e65c7f2fac74d9cd22a86a74d7dc0c3f0e48a85315ebd8481e9355a4ebc450a537e26dbf1e92bd6aa15779923eb
###
# Functions to support SSL/TLS operations in Nessus plugins.
#
# (C) Tenable Network Security, Inc.
#
# This script is released under one of the Tenable Script Licenses and may not
# be used from within scripts released under another license without the
# authorization from Tenable Network Security, Inc.
#
# @NOGPL@
#
# Revision 1.0
#
###

# Cipher suites.
#
# nb: key names should start with one of "SSL2_", "SSL3_", or "TLS1".
global_var ciphers, ciphers_desc;
# - SSL v2
# -   from OpenSSL's ssl2.h
ciphers["SSL2_CK_NULL_WITH_MD5"]                    = raw_string(0x00, 0x00, 0x00);
ciphers["SSL2_CK_RC4_128_WITH_MD5"]                 = raw_string(0x01, 0x00, 0x80);
ciphers["SSL2_CK_RC4_128_EXPORT40_WITH_MD5"]        = raw_string(0x02, 0x00, 0x80);
ciphers["SSL2_CK_RC2_128_CBC_WITH_MD5"]             = raw_string(0x03, 0x00, 0x80);
ciphers["SSL2_CK_RC2_128_CBC_EXPORT40_WITH_MD5"]    = raw_string(0x04, 0x00, 0x80);
ciphers["SSL2_CK_IDEA_128_CBC_WITH_MD5"]            = raw_string(0x05, 0x00, 0x80);
ciphers["SSL2_CK_DES_64_CBC_WITH_MD5"]              = raw_string(0x06, 0x00, 0x40);
ciphers["SSL2_CK_DES_64_CBC_WITH_SHA"]              = raw_string(0x06, 0x01, 0x40);
ciphers["SSL2_CK_DES_192_EDE3_CBC_WITH_MD5"]        = raw_string(0x07, 0x00, 0xc0);
ciphers["SSL2_CK_DES_192_EDE3_CBC_WITH_SHA"]        = raw_string(0x07, 0x01, 0xc0);
ciphers["SSL2_CK_RC4_64_WITH_MD5"]                  = raw_string(0x08, 0x00, 0x80);
ciphers["SSL2_CK_DES_64_CFB64_WITH_MD5_1"]          = raw_string(0xff, 0x08, 0x00);
ciphers["SSL2_CK_NULL"]                             = raw_string(0xff, 0x08, 0x10);
# - TLS (v1.0 and 1.2)
#
#   nb: TLS 1.0 cipher suites start with 'TLS1_'
#       TLS 1.2 with 'TLS12_'
#
# -   from https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml
ciphers["TLS1_CK_NULL_WITH_NULL_NULL"]              = raw_string(0x00, 0x00);
ciphers["TLS1_CK_RSA_WITH_NULL_MD5"]                = raw_string(0x00, 0x01);
ciphers["TLS1_CK_RSA_WITH_NULL_SHA"]                = raw_string(0x00, 0x02);
ciphers["TLS1_CK_RSA_EXPORT_WITH_RC4_40_MD5"]       = raw_string(0x00, 0x03);
ciphers["TLS1_CK_RSA_WITH_RC4_128_MD5"]             = raw_string(0x00, 0x04);
ciphers["TLS1_CK_RSA_WITH_RC4_128_SHA"]             = raw_string(0x00, 0x05);
ciphers["TLS1_CK_RSA_EXPORT_WITH_RC2_CBC_40_MD5"]   = raw_string(0x00, 0x06);
ciphers["TLS1_CK_RSA_WITH_IDEA_CBC_SHA"]            = raw_string(0x00, 0x07);
ciphers["TLS1_CK_RSA_EXPORT_WITH_DES40_CBC_SHA"]    = raw_string(0x00, 0x08);
ciphers["TLS1_CK_RSA_WITH_DES_CBC_SHA"]             = raw_string(0x00, 0x09);
ciphers["TLS1_CK_RSA_WITH_3DES_EDE_CBC_SHA"]        = raw_string(0x00, 0x0A);
ciphers["TLS1_CK_DH_DSS_EXPORT_WITH_DES40_CBC_SHA"] = raw_string(0x00, 0x0B);
ciphers["TLS1_CK_DH_DSS_WITH_DES_CBC_SHA"]          = raw_string(0x00, 0x0C);
ciphers["TLS1_CK_DH_DSS_WITH_3DES_EDE_CBC_SHA"]     = raw_string(0x00, 0x0D);
ciphers["TLS1_CK_DH_RSA_EXPORT_WITH_DES40_CBC_SHA"] = raw_string(0x00, 0x0E);
ciphers["TLS1_CK_DH_RSA_WITH_DES_CBC_SHA"]          = raw_string(0x00, 0x0F);
ciphers["TLS1_CK_DH_RSA_WITH_3DES_EDE_CBC_SHA"]     = raw_string(0x00, 0x10);
ciphers["TLS1_CK_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA"]= raw_string(0x00, 0x11);
ciphers["TLS1_CK_DHE_DSS_WITH_DES_CBC_SHA"]         = raw_string(0x00, 0x12);
ciphers["TLS1_CK_DHE_DSS_WITH_3DES_EDE_CBC_SHA"]    = raw_string(0x00, 0x13);
ciphers["TLS1_CK_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA"]= raw_string(0x00, 0x14);
ciphers["TLS1_CK_DHE_RSA_WITH_DES_CBC_SHA"]         = raw_string(0x00, 0x15);
ciphers["TLS1_CK_DHE_RSA_WITH_3DES_EDE_CBC_SHA"]    = raw_string(0x00, 0x16);
ciphers["TLS1_CK_DH_anon_EXPORT_WITH_RC4_40_MD5"]   = raw_string(0x00, 0x17);
ciphers["TLS1_CK_DH_anon_WITH_RC4_128_MD5"]         = raw_string(0x00, 0x18);
ciphers["TLS1_CK_DH_anon_EXPORT_WITH_DES40_CBC_SHA"]= raw_string(0x00, 0x19);
ciphers["TLS1_CK_DH_anon_WITH_DES_CBC_SHA"]         = raw_string(0x00, 0x1A);
ciphers["TLS1_CK_DH_anon_WITH_3DES_EDE_CBC_SHA"]    = raw_string(0x00, 0x1B);
ciphers["TLS1_CK_KRB5_WITH_DES_CBC_SHA"]            = raw_string(0x00, 0x1E);
ciphers["TLS1_CK_KRB5_WITH_3DES_EDE_CBC_SHA"]       = raw_string(0x00, 0x1F);
ciphers["TLS1_CK_KRB5_WITH_RC4_128_SHA"]            = raw_string(0x00, 0x20);
ciphers["TLS1_CK_KRB5_WITH_IDEA_CBC_SHA"]           = raw_string(0x00, 0x21);
ciphers["TLS1_CK_KRB5_WITH_DES_CBC_MD5"]            = raw_string(0x00, 0x22);
ciphers["TLS1_CK_KRB5_WITH_3DES_EDE_CBC_MD5"]       = raw_string(0x00, 0x23);
ciphers["TLS1_CK_KRB5_WITH_RC4_128_MD5"]            = raw_string(0x00, 0x24);
ciphers["TLS1_CK_KRB5_WITH_IDEA_CBC_MD5"]           = raw_string(0x00, 0x25);
ciphers["TLS1_CK_KRB5_EXPORT_WITH_DES_CBC_40_SHA"]  = raw_string(0x00, 0x26);
ciphers["TLS1_CK_KRB5_EXPORT_WITH_RC2_CBC_40_SHA"]  = raw_string(0x00, 0x27);
ciphers["TLS1_CK_KRB5_EXPORT_WITH_RC4_40_SHA"]      = raw_string(0x00, 0x28);
ciphers["TLS1_CK_KRB5_EXPORT_WITH_DES_CBC_40_MD5"]  = raw_string(0x00, 0x29);
ciphers["TLS1_CK_KRB5_EXPORT_WITH_RC2_CBC_40_MD5"]  = raw_string(0x00, 0x2A);
ciphers["TLS1_CK_KRB5_EXPORT_WITH_RC4_40_MD5"]      = raw_string(0x00, 0x2B);
ciphers["TLS1_PSK_WITH_NULL_SHA"]                   = raw_string(0x00, 0x2C);
ciphers["TLS1_DHE_PSK_WITH_NULL_SHA"]               = raw_string(0x00, 0x2D);
ciphers["TLS1_RSA_PSK_WITH_NULL_SHA"]               = raw_string(0x00, 0x2E);
ciphers["TLS1_CK_RSA_WITH_AES_128_CBC_SHA"]         = raw_string(0x00, 0x2F);
ciphers["TLS1_CK_DH_DSS_WITH_AES_128_CBC_SHA"]      = raw_string(0x00, 0x30);
ciphers["TLS1_CK_DH_RSA_WITH_AES_128_CBC_SHA"]      = raw_string(0x00, 0x31);
ciphers["TLS1_CK_DHE_DSS_WITH_AES_128_CBC_SHA"]     = raw_string(0x00, 0x32);
ciphers["TLS1_CK_DHE_RSA_WITH_AES_128_CBC_SHA"]     = raw_string(0x00, 0x33);
ciphers["TLS1_CK_DH_anon_WITH_AES_128_CBC_SHA"]     = raw_string(0x00, 0x34);
ciphers["TLS1_CK_RSA_WITH_AES_256_CBC_SHA"]         = raw_string(0x00, 0x35);
ciphers["TLS1_CK_DH_DSS_WITH_AES_256_CBC_SHA"]      = raw_string(0x00, 0x36);
ciphers["TLS1_CK_DH_RSA_WITH_AES_256_CBC_SHA"]      = raw_string(0x00, 0x37);
ciphers["TLS1_CK_DHE_DSS_WITH_AES_256_CBC_SHA"]     = raw_string(0x00, 0x38);
ciphers["TLS1_CK_DHE_RSA_WITH_AES_256_CBC_SHA"]     = raw_string(0x00, 0x39);
ciphers["TLS1_CK_DH_anon_WITH_AES_256_CBC_SHA"]     = raw_string(0x00, 0x3A);
ciphers["TLS1_RSA_WITH_NULL_SHA256"]                = raw_string(0x00, 0x3B);
ciphers["TLS1_RSA_WITH_AES_128_CBC_SHA256"]         = raw_string(0x00, 0x3C);
ciphers["TLS1_RSA_WITH_AES_256_CBC_SHA256"]         = raw_string(0x00, 0x3D);
ciphers["TLS1_DH_DSS_WITH_AES_128_CBC_SHA256"]      = raw_string(0x00, 0x3E);
ciphers["TLS1_DH_RSA_WITH_AES_128_CBC_SHA256"]      = raw_string(0x00, 0x3F);
ciphers["TLS1_DHE_DSS_WITH_AES_128_CBC_SHA256"]     = raw_string(0x00, 0x40);
ciphers["TLS1_DHE_RSA_WITH_AES_128_CBC_SHA256"]     = raw_string(0x00, 0x67);
ciphers["TLS1_DH_DSS_WITH_AES_256_CBC_SHA256"]      = raw_string(0x00, 0x68);
ciphers["TLS1_DH_RSA_WITH_AES_256_CBC_SHA256"]      = raw_string(0x00, 0x69);
ciphers["TLS1_DHE_DSS_WITH_AES_256_CBC_SHA256"]     = raw_string(0x00, 0x6A);
ciphers["TLS1_DHE_RSA_WITH_AES_256_CBC_SHA256"]     = raw_string(0x00, 0x6B);
ciphers["TLS1_DH_anon_WITH_AES_128_CBC_SHA256"]     = raw_string(0x00, 0x6C);
ciphers["TLS1_DH_anon_WITH_AES_256_CBC_SHA256"]     = raw_string(0x00, 0x6D);
# -   nb: these aren't part of the IANA spec but are supported by OpenSSL
#         if TLS1_ALLOW_EXPERIMENTAL_CIPHERSUITES is defined.
ciphers["TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_MD5"]   = raw_string(0x00, 0x60);
ciphers["TLS1_CK_RSA_EXPORT1024_WITH_RC2_CBC_56_MD5"]= raw_string(0x00, 0x61);
ciphers["TLS1_CK_RSA_EXPORT1024_WITH_DES_CBC_SHA"]  = raw_string(0x00, 0x62);
ciphers["TLS1_CK_DHE_DSS_EXPORT1024_WITH_DES_CBC_SHA"]= raw_string(0x00, 0x63);
ciphers["TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_SHA"]   = raw_string(0x00, 0x64);
ciphers["TLS1_CK_DHE_DSS_EXPORT1024_WITH_RC4_56_SHA"]= raw_string(0x00, 0x65);
ciphers["TLS1_CK_DHE_DSS_WITH_RC4_128_SHA"]         = raw_string(0x00, 0x66);
# -   nb: Camellia, from RFC 4132
ciphers["TLS1_CK_RSA_WITH_CAMELLIA_128_CBC_SHA"]    = raw_string(0x00, 0x41);
ciphers["TLS1_CK_DH_DSS_WITH_CAMELLIA_128_CBC_SHA"] = raw_string(0x00, 0x42);
ciphers["TLS1_CK_DH_RSA_WITH_CAMELLIA_128_CBC_SHA"] = raw_string(0x00, 0x43);
ciphers["TLS1_CK_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA"]= raw_string(0x00, 0x44);
ciphers["TLS1_CK_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA"]= raw_string(0x00, 0x45);
ciphers["TLS1_CK_DH_anon_WITH_CAMELLIA_128_CBC_SHA"]= raw_string(0x00, 0x46);
ciphers["TLS1_CK_RSA_WITH_CAMELLIA_256_CBC_SHA"]    = raw_string(0x00, 0x84);
ciphers["TLS1_CK_DH_DSS_WITH_CAMELLIA_256_CBC_SHA"] = raw_string(0x00, 0x85);
ciphers["TLS1_CK_DH_RSA_WITH_CAMELLIA_256_CBC_SHA"] = raw_string(0x00, 0x86);
ciphers["TLS1_CK_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA"]= raw_string(0x00, 0x87);
ciphers["TLS1_CK_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA"]= raw_string(0x00, 0x88);
ciphers["TLS1_CK_DH_anon_WITH_CAMELLIA_256_CBC_SHA"]= raw_string(0x00, 0x89);
# -   nb: GOST, draft-chudov-cryptopro-cptls-04.txt
ciphers["TLS1_GOSTR341094_WITH_28147_CNT_IMIT"]     = raw_string(0x00, 0x80);
ciphers["TLS1_GOSTR341001_WITH_28147_CNT_IMIT"]     = raw_string(0x00, 0x81);
ciphers["TLS1_GOSTR341094_WITH_NULL_GOSTR3411"]     = raw_string(0x00, 0x82);
ciphers["TLS1_GOSTR341001_WITH_NULL_GOSTR3411"]     = raw_string(0x00, 0x83);
# -   nb: TLS w/ pre-shared keys, RFC 4279.
ciphers["TLS1_CK_PSK_WITH_RC4_128_SHA"]             = raw_string(0x00, 0x8A);
ciphers["TLS1_CK_PSK_WITH_3DES_EDE_CBC_SHA"]        = raw_string(0x00, 0x8B);
ciphers["TLS1_CK_PSK_WITH_AES_128_CBC_SHA"]         = raw_string(0x00, 0x8C);
ciphers["TLS1_CK_PSK_WITH_AES_256_CBC_SHA"]         = raw_string(0x00, 0x8D);
ciphers["TLS1_CK_DHE_PSK_WITH_RC4_128_SHA"]         = raw_string(0x00, 0x8E);
ciphers["TLS1_CK_DHE_PSK_WITH_3DES_EDE_CBC_SHA"]    = raw_string(0x00, 0x8F);
ciphers["TLS1_CK_DHE_PSK_WITH_AES_128_CBC_SHA"]     = raw_string(0x00, 0x90);
ciphers["TLS1_CK_DHE_PSK_WITH_AES_256_CBC_SHA"]     = raw_string(0x00, 0x91);
ciphers["TLS1_CK_RSA_PSK_WITH_RC4_128_SHA"]         = raw_string(0x00, 0x92);
ciphers["TLS1_CK_RSA_PSK_WITH_3DES_EDE_CBC_SHA"]    = raw_string(0x00, 0x93);
ciphers["TLS1_CK_RSA_PSK_WITH_AES_128_CBC_SHA"]     = raw_string(0x00, 0x94);
ciphers["TLS1_CK_RSA_PSK_WITH_AES_256_CBC_SHA"]     = raw_string(0x00, 0x95);
# -   nb: SEED Cipher Suites, RFC 4162
ciphers["TLS1_CK_RSA_WITH_SEED_CBC_SHA"]            = raw_string(0x00, 0x96);
ciphers["TLS1_CK_DH_DSS_WITH_SEED_CBC_SHA"]         = raw_string(0x00, 0x97);
ciphers["TLS1_CK_DH_RSA_WITH_SEED_CBC_SHA"]         = raw_string(0x00, 0x98);
ciphers["TLS1_CK_DHE_DSS_WITH_SEED_CBC_SHA"]        = raw_string(0x00, 0x99);
ciphers["TLS1_CK_DHE_RSA_WITH_SEED_CBC_SHA"]        = raw_string(0x00, 0x9A);
ciphers["TLS1_CK_DH_anon_WITH_SEED_CBC_SHA"]        = raw_string(0x00, 0x9B);
# -   nb: AES Galois Counter Mode (GCM), RFC 5288
ciphers["TLS12_RSA_WITH_AES_128_GCM_SHA256"]        = raw_string(0x00, 0x9C);
ciphers["TLS12_RSA_WITH_AES_256_GCM_SHA384"]        = raw_string(0x00, 0x9D);
ciphers["TLS12_DHE_RSA_WITH_AES_128_GCM_SHA256"]    = raw_string(0x00, 0x9E);
ciphers["TLS12_DHE_RSA_WITH_AES_256_GCM_SHA384"]    = raw_string(0x00, 0x9F);
ciphers["TLS12_DH_RSA_WITH_AES_128_GCM_SHA256"]     = raw_string(0x00, 0xA0);
ciphers["TLS12_DH_RSA_WITH_AES_256_GCM_SHA384"]     = raw_string(0x00, 0xA1);
ciphers["TLS12_DHE_DSS_WITH_AES_128_GCM_SHA256"]    = raw_string(0x00, 0xA2);
ciphers["TLS12_DHE_DSS_WITH_AES_256_GCM_SHA384"]    = raw_string(0x00, 0xA3);
ciphers["TLS12_DH_DSS_WITH_AES_128_GCM_SHA256"]     = raw_string(0x00, 0xA4);
ciphers["TLS12_DH_DSS_WITH_AES_256_GCM_SHA384"]     = raw_string(0x00, 0xA5);
ciphers["TLS12_DH_anon_WITH_AES_128_GCM_SHA256"]    = raw_string(0x00, 0xA6);
ciphers["TLS12_DH_anon_WITH_AES_256_GCM_SHA384"]    = raw_string(0x00, 0xA7);
# -   nb: Pre-Shared Key w/ SHA-256/384 and AES Galois Counter Mode, RFC 5487
ciphers["TLS12_PSK_WITH_AES_128_GCM_SHA256"]        = raw_string(0x00, 0xA8);
ciphers["TLS12_PSK_WITH_AES_256_GCM_SHA384"]        = raw_string(0x00, 0xA9);
ciphers["TLS12_DHE_PSK_WITH_AES_128_GCM_SHA256"]    = raw_string(0x00, 0xAA);
ciphers["TLS12_DHE_PSK_WITH_AES_256_GCM_SHA384"]    = raw_string(0x00, 0xAB);
ciphers["TLS12_RSA_PSK_WITH_AES_128_GCM_SHA256"]    = raw_string(0x00, 0xAC);
ciphers["TLS12_RSA_PSK_WITH_AES_256_GCM_SHA384"]    = raw_string(0x00, 0xAD);
ciphers["TLS1_PSK_WITH_AES_128_CBC_SHA256"]         = raw_string(0x00, 0xAE);
ciphers["TLS1_PSK_WITH_AES_256_CBC_SHA384"]         = raw_string(0x00, 0xAF);
ciphers["TLS1_PSK_WITH_NULL_SHA256"]                = raw_string(0x00, 0xB0);
ciphers["TLS1_PSK_WITH_NULL_SHA384"]                = raw_string(0x00, 0xB1);
ciphers["TLS1_DHE_PSK_WITH_AES_128_CBC_SHA256"]     = raw_string(0x00, 0xB2);
ciphers["TLS1_DHE_PSK_WITH_AES_256_CBC_SHA384"]     = raw_string(0x00, 0xB3);
ciphers["TLS1_DHE_PSK_WITH_NULL_SHA256"]            = raw_string(0x00, 0xB4);
ciphers["TLS1_DHE_PSK_WITH_NULL_SHA384"]            = raw_string(0x00, 0xB5);
ciphers["TLS1_RSA_PSK_WITH_AES_128_CBC_SHA256"]     = raw_string(0x00, 0xB6);
ciphers["TLS1_RSA_PSK_WITH_AES_256_CBC_SHA384"]     = raw_string(0x00, 0xB7);
ciphers["TLS1_RSA_PSK_WITH_NULL_SHA256"]            = raw_string(0x00, 0xB8);
ciphers["TLS1_RSA_PSK_WITH_NULL_SHA384"]            = raw_string(0x00, 0xB9);
# -   nb: Camellia, from RFC-kato-tls-rfc4132bis-05.txt
ciphers["TLS1_RSA_WITH_CAMELLIA_128_CBC_SHA256"]    = raw_string(0x00, 0xBA);
ciphers["TLS1_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256"] = raw_string(0x00, 0xBB);
ciphers["TLS1_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256"] = raw_string(0x00, 0xBC);
ciphers["TLS1_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256"]= raw_string(0x00, 0xBD);
ciphers["TLS1_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256"]= raw_string(0x00, 0xBE);
ciphers["TLS1_DH_anon_WITH_CAMELLIA_128_CBC_SHA256"]= raw_string(0x00, 0xBF);
ciphers["TLS1_RSA_WITH_CAMELLIA_256_CBC_SHA256"]    = raw_string(0x00, 0xC0);
ciphers["TLS1_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256"] = raw_string(0x00, 0xC1);
ciphers["TLS1_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256"] = raw_string(0x00, 0xC2);
ciphers["TLS1_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256"]= raw_string(0x00, 0xC3);
ciphers["TLS1_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256"]= raw_string(0x00, 0xC4);
ciphers["TLS1_DH_anon_WITH_CAMELLIA_256_CBC_SHA256"]= raw_string(0x00, 0xC5);
# -   nb: Elliptic Curve Cryptography (ECC), RFC 4492
ciphers["TLS1_CK_ECDH_ECDSA_WITH_NULL_SHA"]         = raw_string(0xC0, 0x01);
ciphers["TLS1_CK_ECDH_ECDSA_WITH_RC4_128_SHA"]      = raw_string(0xC0, 0x02);
ciphers["TLS1_CK_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA"] = raw_string(0xC0, 0x03);
ciphers["TLS1_CK_ECDH_ECDSA_WITH_AES_128_CBC_SHA"]  = raw_string(0xC0, 0x04);
ciphers["TLS1_CK_ECDH_ECDSA_WITH_AES_256_CBC_SHA"]  = raw_string(0xC0, 0x05);
ciphers["TLS1_CK_ECDHE_ECDSA_WITH_NULL_SHA"]        = raw_string(0xC0, 0x06);
ciphers["TLS1_CK_ECDHE_ECDSA_WITH_RC4_128_SHA"]     = raw_string(0xC0, 0x07);
ciphers["TLS1_CK_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA"]= raw_string(0xC0, 0x08);
ciphers["TLS1_CK_ECDHE_ECDSA_WITH_AES_128_CBC_SHA"] = raw_string(0xC0, 0x09);
ciphers["TLS1_CK_ECDHE_ECDSA_WITH_AES_256_CBC_SHA"] = raw_string(0xC0, 0x0A);
ciphers["TLS1_CK_ECDH_RSA_WITH_NULL_SHA"]           = raw_string(0xC0, 0x0B);
ciphers["TLS1_CK_ECDH_RSA_WITH_RC4_128_SHA"]        = raw_string(0xC0, 0x0C);
ciphers["TLS1_CK_ECDH_RSA_WITH_3DES_EDE_CBC_SHA"]   = raw_string(0xC0, 0x0D);
ciphers["TLS1_CK_ECDH_RSA_WITH_AES_128_CBC_SHA"]    = raw_string(0xC0, 0x0E);
ciphers["TLS1_CK_ECDH_RSA_WITH_AES_256_CBC_SHA"]    = raw_string(0xC0, 0x0F);
ciphers["TLS1_CK_ECDHE_RSA_WITH_NULL_SHA"]          = raw_string(0xC0, 0x10);
ciphers["TLS1_CK_ECDHE_RSA_WITH_RC4_128_SHA"]       = raw_string(0xC0, 0x11);
ciphers["TLS1_CK_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA"]  = raw_string(0xC0, 0x12);
ciphers["TLS1_CK_ECDHE_RSA_WITH_AES_128_CBC_SHA"]   = raw_string(0xC0, 0x13);
ciphers["TLS1_CK_ECDHE_RSA_WITH_AES_256_CBC_SHA"]   = raw_string(0xC0, 0x14);
ciphers["TLS1_CK_ECDH_anon_NULL_WITH_SHA"]          = raw_string(0xC0, 0x15);
ciphers["TLS1_CK_ECDH_anon_WITH_RC4_128_SHA"]       = raw_string(0xC0, 0x16);
ciphers["TLS1_CK_ECDH_anon_WITH_3DES_EDE_CBC_SHA"]  = raw_string(0xC0, 0x17);
ciphers["TLS1_CK_ECDH_anon_WITH_AES_128_CBC_SHA"]   = raw_string(0xC0, 0x18);
ciphers["TLS1_CK_ECDH_anon_WITH_AES_256_CBC_SHA"]   = raw_string(0xC0, 0x19);
# -   nb: Secure Remote Password (SRP), RFC 5054
ciphers["TLS1_SRP_SHA_WITH_3DES_EDE_CBC_SHA"]       = raw_string(0xC0, 0x1A);
ciphers["TLS1_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA"]   = raw_string(0xC0, 0x1B);
ciphers["TLS1_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA"]   = raw_string(0xC0, 0x1C);
ciphers["TLS1_SRP_SHA_WITH_AES_128_CBC_SHA"]        = raw_string(0xC0, 0x1D);
ciphers["TLS1_SRP_SHA_RSA_WITH_AES_128_CBC_SHA"]    = raw_string(0xC0, 0x1E);
ciphers["TLS1_SRP_SHA_DSS_WITH_AES_128_CBC_SHA"]    = raw_string(0xC0, 0x1F);
ciphers["TLS1_SRP_SHA_WITH_AES_256_CBC_SHA"]        = raw_string(0xC0, 0x20);
ciphers["TLS1_SRP_SHA_RSA_WITH_AES_256_CBC_SHA"]    = raw_string(0xC0, 0x21);
ciphers["TLS1_SRP_SHA_DSS_WITH_AES_256_CBC_SHA"]    = raw_string(0xC0, 0x22);
# -   nb: Elliptic Curve Cipher Suites w/ SHA-256/384 and AES Galois Counter Mode (GCM), RFC 5289
ciphers["TLS1_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256"] = raw_string(0xC0, 0x23);
ciphers["TLS1_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384"] = raw_string(0xC0, 0x24);
ciphers["TLS1_ECDH_ECDSA_WITH_AES_128_CBC_SHA256"]  = raw_string(0xC0, 0x25);
ciphers["TLS1_ECDH_ECDSA_WITH_AES_256_CBC_SHA384"]  = raw_string(0xC0, 0x26);
ciphers["TLS1_ECDHE_RSA_WITH_AES_128_CBC_SHA256"]   = raw_string(0xC0, 0x27);
ciphers["TLS1_ECDHE_RSA_WITH_AES_256_CBC_SHA384"]   = raw_string(0xC0, 0x28);
ciphers["TLS1_ECDH_RSA_WITH_AES_128_CBC_SHA256"]    = raw_string(0xC0, 0x29);
ciphers["TLS1_ECDH_RSA_WITH_AES_256_CBC_SHA384"]    = raw_string(0xC0, 0x2A);
ciphers["TLS12_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256"]= raw_string(0xC0, 0x2B);
ciphers["TLS12_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384"]= raw_string(0xC0, 0x2C);
ciphers["TLS12_ECDH_ECDSA_WITH_AES_128_GCM_SHA256"] = raw_string(0xC0, 0x2D);
ciphers["TLS12_ECDH_ECDSA_WITH_AES_256_GCM_SHA384"] = raw_string(0xC0, 0x2E);
ciphers["TLS12_ECDHE_RSA_WITH_AES_128_GCM_SHA256"]  = raw_string(0xC0, 0x2F);
ciphers["TLS12_ECDHE_RSA_WITH_AES_256_GCM_SHA384"]  = raw_string(0xC0, 0x30);
ciphers["TLS12_ECDH_RSA_WITH_AES_128_GCM_SHA256"]   = raw_string(0xC0, 0x31);
ciphers["TLS12_ECDH_RSA_WITH_AES_256_GCM_SHA384"]   = raw_string(0xC0, 0x32);
# -   nb: ECDHE_PSK, RFC 5489
ciphers["TLS1_ECDHE_PSK_WITH_RC4_128_SHA"]          = raw_string(0xC0, 0x33);
ciphers["TLS1_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA"]     = raw_string(0xC0, 0x34);
ciphers["TLS1_ECDHE_PSK_WITH_AES_128_CBC_SHA"]      = raw_string(0xC0, 0x35);
ciphers["TLS1_ECDHE_PSK_WITH_AES_256_CBC_SHA"]      = raw_string(0xC0, 0x36);
ciphers["TLS1_ECDHE_PSK_WITH_AES_128_CBC_SHA256"]   = raw_string(0xC0, 0x37);
ciphers["TLS1_ECDHE_PSK_WITH_AES_256_CBC_SHA384"]   = raw_string(0xC0, 0x38);
ciphers["TLS1_ECDHE_PSK_WITH_NULL_SHA"]             = raw_string(0xC0, 0x39);
ciphers["TLS1_ECDHE_PSK_WITH_NULL_SHA256"]          = raw_string(0xC0, 0x3A);
ciphers["TLS1_ECDHE_PSK_WITH_NULL_SHA384"]          = raw_string(0xC0, 0x3B);
# -   nb: Ciphers per RFC 6367
ciphers["TLS12_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256"]  = raw_string(0xC0, 0x72);
ciphers["TLS12_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384"]  = raw_string(0xC0, 0x73);
ciphers["TLS12_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256"]   = raw_string(0xC0, 0x74);
ciphers["TLS12_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384"]   = raw_string(0xC0, 0x75);
ciphers["TLS12_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256"]    = raw_string(0xC0, 0x76);
ciphers["TLS12_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384"]    = raw_string(0xC0, 0x77);
ciphers["TLS12_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256"]     = raw_string(0xC0, 0x78);
ciphers["TLS12_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384"]     = raw_string(0xC0, 0x79);
ciphers["TLS12_RSA_WITH_CAMELLIA_128_GCM_SHA256"]          = raw_string(0xC0, 0x7A);
ciphers["TLS12_RSA_WITH_CAMELLIA_256_GCM_SHA384"]          = raw_string(0xC0, 0x7B);
ciphers["TLS12_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256"]      = raw_string(0xC0, 0x7C);
ciphers["TLS12_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384"]      = raw_string(0xC0, 0x7D);
ciphers["TLS12_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256"]       = raw_string(0xC0, 0x7E);
ciphers["TLS12_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384"]       = raw_string(0xC0, 0x7F);
ciphers["TLS12_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256"]      = raw_string(0xC0, 0x80);
ciphers["TLS12_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384"]      = raw_string(0xC0, 0x81);
ciphers["TLS12_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256"]       = raw_string(0xC0, 0x82);
ciphers["TLS12_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384"]       = raw_string(0xC0, 0x83);
ciphers["TLS12_DH_anon_WITH_CAMELLIA_128_GCM_SHA256"]      = raw_string(0xC0, 0x84);
ciphers["TLS12_DH_anon_WITH_CAMELLIA_256_GCM_SHA384"]      = raw_string(0xC0, 0x85);
ciphers["TLS12_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256"]  = raw_string(0xC0, 0x86);
ciphers["TLS12_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384"]  = raw_string(0xC0, 0x87);
ciphers["TLS12_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256"]   = raw_string(0xC0, 0x88);
ciphers["TLS12_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384"]   = raw_string(0xC0, 0x89);
ciphers["TLS12_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256"]    = raw_string(0xC0, 0x8A);
ciphers["TLS12_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384"]    = raw_string(0xC0, 0x8B);
ciphers["TLS12_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256"]     = raw_string(0xC0, 0x8C);
ciphers["TLS12_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384"]     = raw_string(0xC0, 0x8D);
ciphers["TLS12_PSK_WITH_CAMELLIA_128_GCM_SHA256"]          = raw_string(0xC0, 0x8E);
ciphers["TLS12_PSK_WITH_CAMELLIA_256_GCM_SHA384"]          = raw_string(0xC0, 0x8F);
ciphers["TLS12_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256"]      = raw_string(0xC0, 0x90);
ciphers["TLS12_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384"]      = raw_string(0xC0, 0x91);
ciphers["TLS12_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256"]      = raw_string(0xC0, 0x92);
ciphers["TLS12_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384"]      = raw_string(0xC0, 0x93);
ciphers["TLS12_PSK_WITH_CAMELLIA_128_CBC_SHA256"]          = raw_string(0xC0, 0x94);
ciphers["TLS12_PSK_WITH_CAMELLIA_256_CBC_SHA384"]          = raw_string(0xC0, 0x95);
ciphers["TLS12_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256"]      = raw_string(0xC0, 0x96);
ciphers["TLS12_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384"]      = raw_string(0xC0, 0x97);
ciphers["TLS12_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256"]      = raw_string(0xC0, 0x98);
ciphers["TLS12_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384"]      = raw_string(0xC0, 0x99);
ciphers["TLS12_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256"]    = raw_string(0xC0, 0x9A);
ciphers["TLS12_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384"]    = raw_string(0xC0, 0x9B);

# -   nb: Ciphers per RFC 6655
ciphers["TLS12_RSA_WITH_AES_128_CCM"]                      = raw_string(0xC0, 0x9C);
ciphers["TLS12_RSA_WITH_AES_256_CCM"]                      = raw_string(0xC0, 0x9D);
ciphers["TLS12_DHE_RSA_WITH_AES_128_CCM"]                  = raw_string(0xC0, 0x9E);
ciphers["TLS12_DHE_RSA_WITH_AES_256_CCM"]                  = raw_string(0xC0, 0x9F);
ciphers["TLS12_RSA_WITH_AES_128_CCM_8"]                    = raw_string(0xC0, 0xA0);
ciphers["TLS12_RSA_WITH_AES_256_CCM_8"]                    = raw_string(0xC0, 0xA1);
ciphers["TLS12_DHE_RSA_WITH_AES_128_CCM_8"]                = raw_string(0xC0, 0xA2);
ciphers["TLS12_DHE_RSA_WITH_AES_256_CCM_8"]                = raw_string(0xC0, 0xA3);
ciphers["TLS12_PSK_WITH_AES_128_CCM"]                      = raw_string(0xC0, 0xA4);
ciphers["TLS12_PSK_WITH_AES_256_CCM"]                      = raw_string(0xC0, 0xA5);
ciphers["TLS12_DHE_PSK_WITH_AES_128_CCM"]                  = raw_string(0xC0, 0xA6);
ciphers["TLS12_DHE_PSK_WITH_AES_256_CCM"]                  = raw_string(0xC0, 0xA7);
ciphers["TLS12_PSK_WITH_AES_128_CCM_8"]                    = raw_string(0xC0, 0xA8);
ciphers["TLS12_PSK_WITH_AES_256_CCM_8"]                    = raw_string(0xC0, 0xA9);
ciphers["TLS12_PSK_DHE_WITH_AES_128_CCM_8"]                = raw_string(0xC0, 0xAA);
ciphers["TLS12_PSK_DHE_WITH_AES_256_CCM_8"]                = raw_string(0xC0, 0xAB);

# -   nb: Ciphers per RFC 7251
ciphers["TLS12_ECDHE_ECDSA_WITH_AES_128_CCM"]              = raw_string(0xC0, 0xAC);
ciphers["TLS12_ECDHE_ECDSA_WITH_AES_256_CCM"]              = raw_string(0xC0, 0xAD);
ciphers["TLS12_ECDHE_ECDSA_WITH_AES_128_CCM_8"]            = raw_string(0xC0, 0xAE);
ciphers["TLS12_ECDHE_ECDSA_WITH_AES_256_CCM_8"]            = raw_string(0xC0, 0xAF);

# -   nb: Ciphers per RFC 7905
ciphers["TLS12_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256"]     = raw_string(0xCC, 0xA8);
ciphers["TLS12_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256"]   = raw_string(0xCC, 0xA9);
ciphers["TLS12_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256"]       = raw_string(0xCC, 0xAA);

ciphers["TLS12_PSK_WITH_CHACHA20_POLY1305_SHA256"]           = raw_string(0xCC, 0xAB);
ciphers["TLS12_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256"]     = raw_string(0xCC, 0xAC);
ciphers["TLS12_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256"]       = raw_string(0xCC, 0xAD);
ciphers["TLS12_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256"]       = raw_string(0xCC, 0xAE);

# Other ciphers not in IANA registry
ciphers["SSL3_FORTEZZA_KEA_WITH_NULL_SHA"]                = raw_string(0x00, 0x1C);
ciphers["SSL3_FORTEZZA_KEA_WITH_FORTEZZA_CBC_SHA"]        = raw_string(0x00, 0x1D);

# http://www-archive.mozilla.org/projects/security/pki/nss/ssl/fips-ssl-ciphersuites.html
ciphers["SSL3_RSA_FIPS_WITH_DES_CBC_SHA"]                 = raw_string(0xFE, 0xFE);
ciphers["SSL3_RSA_FIPS_WITH_3DES_EDE_CBC_SHA"]            = raw_string(0xFE, 0xFF);
ciphers["SSL3_RSA_FIPS_WITH_DES_CBC_SHA_PRIVATE"]         = raw_string(0xFF, 0xE1);
ciphers["SSL3_RSA_FIPS_WITH_3DES_EDE_CBC_SHA_PRIVATE"]    = raw_string(0xFF, 0xE0);

# TLS 1.3 ciphers
ciphers["TLS13_AES_128_GCM_SHA256"]                         = raw_string(0x13, 0x01);
ciphers["TLS13_AES_256_GCM_SHA384"]                         = raw_string(0x13, 0x02);
ciphers["TLS13_CHACHA20_POLY1305_SHA256"]                   = raw_string(0x13, 0x03);
ciphers["TLS13_AES_128_CCM_SHA256"]                         = raw_string(0x13, 0x04);
ciphers["TLS13_AES_128_CCM_8_SHA256"]                       = raw_string(0x13, 0x05);

# Cipher descriptions; fields are
#   Name=<Tenable ciphername>
#   Code=<Cipher ID>
#   <protocol version>
#   Kex=<key exchange>
#   Auth=<authentication>
#   Encrypt=<symmetric encryption method>
#   MAC=<message authentication code>
#   <export flag>
ciphers_desc["SSL2_CK_NULL_WITH_MD5"]                    = "NULL-MD5|SSLv2|RSA|RSA|None|MD5";
ciphers_desc["SSL2_CK_RC4_128_WITH_MD5"]                 = "RC4-MD5|SSLv2|RSA|RSA|RC4(128)|MD5";
ciphers_desc["SSL2_CK_RC4_128_EXPORT40_WITH_MD5"]        = "EXP-RC4-MD5|SSLv2|RSA(512)|RSA|RC4(40)|MD5|export";
ciphers_desc["SSL2_CK_RC2_128_CBC_WITH_MD5"]             = "RC2-CBC-MD5|SSLv2|RSA|RSA|RC2-CBC(128)|MD5";
ciphers_desc["SSL2_CK_RC2_128_CBC_EXPORT40_WITH_MD5"]    = "EXP-RC2-CBC-MD5|SSLv2|RSA(512)|RSA|RC2-CBC(40)|MD5|export";
ciphers_desc["SSL2_CK_IDEA_128_CBC_WITH_MD5"]            = "IDEA-CBC-MD5|SSLv2|RSA|RSA|IDEA-CBC(128)|MD5";
ciphers_desc["SSL2_CK_DES_64_CBC_WITH_MD5"]              = "DES-CBC-MD5|SSLv2|RSA|RSA|DES-CBC(56)|MD5";
ciphers_desc["SSL2_CK_DES_64_CBC_WITH_SHA"]              = "DES-CBC-SHA|SSLv2|RSA|RSA|DES-CBC(56)|SHA1";
ciphers_desc["SSL2_CK_DES_192_EDE3_CBC_WITH_MD5"]        = "DES-CBC3-MD5|SSLv2|RSA|RSA|3DES-CBC(168)|MD5";
ciphers_desc["SSL2_CK_DES_192_EDE3_CBC_WITH_SHA"]        = "DES-CBC3-SHA|SSLv2|RSA|RSA|3DES-CBC(168)|SHA1";
ciphers_desc["SSL2_CK_RC4_64_WITH_MD5"]                  = "RC4-64-MD5|SSLv2|RSA|RSA|RC4(64)|MD5";
ciphers_desc["SSL2_CK_DES_64_CFB64_WITH_MD5_1"]          = "DES-CFB-M1|SSLv2|RSA|RSA|DES(56)|MD5 with 1 byte";
ciphers_desc["SSL2_CK_NULL"]                             = "NULL|SSLv2|RSA|RSA|None|None";
ciphers_desc["TLS1_CK_NULL_WITH_NULL_NULL"]              = "TLS-NULL-NULL-NULL|TLSv1|None|None|None|None";
ciphers_desc["TLS1_CK_RSA_WITH_NULL_MD5"]                = "NULL-MD5|TLSv1|RSA|RSA|None|MD5";
ciphers_desc["TLS1_CK_RSA_WITH_NULL_SHA"]                = "NULL-SHA|TLSv1|RSA|RSA|None|SHA1";
ciphers_desc["TLS1_CK_RSA_EXPORT_WITH_RC4_40_MD5"]       = "EXP-RC4-MD5|TLSv1|RSA(512)|RSA|RC4(40)|MD5|export";
ciphers_desc["TLS1_CK_RSA_WITH_RC4_128_MD5"]             = "RC4-MD5|TLSv1|RSA|RSA|RC4(128)|MD5";
ciphers_desc["TLS1_CK_RSA_WITH_RC4_128_SHA"]             = "RC4-SHA|TLSv1|RSA|RSA|RC4(128)|SHA1";
ciphers_desc["TLS1_CK_RSA_EXPORT_WITH_RC2_CBC_40_MD5"]   = "EXP-RC2-CBC-MD5|TLSv1|RSA(512)|RSA|RC2-CBC(40)|MD5|export";
ciphers_desc["TLS1_CK_RSA_WITH_IDEA_CBC_SHA"]            = "IDEA-CBC-SHA|TLSv1|RSA|RSA|IDEA-CBC(128)|SHA1";
ciphers_desc["TLS1_CK_RSA_EXPORT_WITH_DES40_CBC_SHA"]    = "EXP-DES-CBC-SHA|TLSv1|RSA(512)|RSA|DES-CBC(40)|SHA1|export";
ciphers_desc["TLS1_CK_RSA_WITH_DES_CBC_SHA"]             = "DES-CBC-SHA|TLSv1|RSA|RSA|DES-CBC(56)|SHA1";
ciphers_desc["TLS1_CK_RSA_WITH_3DES_EDE_CBC_SHA"]        = "DES-CBC3-SHA|TLSv1|RSA|RSA|3DES-CBC(168)|SHA1";
ciphers_desc["TLS1_CK_DH_DSS_EXPORT_WITH_DES40_CBC_SHA"] = "EXP-DH-DSS-DES-CBC-SHA|TLSv1|StaticDH(512)|DSS|DES-CBC(40)|SHA1|export";
ciphers_desc["TLS1_CK_DH_DSS_WITH_DES_CBC_SHA"]          = "DH-DSS-DES-CBC-SHA|TLSv1|StaticDH|DSS|DES-CBC(56)|SHA1";
ciphers_desc["TLS1_CK_DH_DSS_WITH_3DES_EDE_CBC_SHA"]     = "DH-DSS-DES-CBC3-SHA|TLSv1|StaticDH|DSS|3DES-CBC(168)|SHA1";
ciphers_desc["TLS1_CK_DH_RSA_EXPORT_WITH_DES40_CBC_SHA"] = "EXP-DH-RSA-DES-CBC-SHA|TLSv1|StaticDH(512)|RSA|DES-CBC(40)|SHA1|export";
ciphers_desc["TLS1_CK_DH_RSA_WITH_DES_CBC_SHA"]          = "DH-RSA-DES-CBC-SHA|TLSv1|StaticDH|RSA|DES-CBC(56)|SHA1";
ciphers_desc["TLS1_CK_DH_RSA_WITH_3DES_EDE_CBC_SHA"]     = "DH-RSA-DES-CBC3-SHA|TLSv1|StaticDH|RSA|3DES-CBC(168)|SHA1";
ciphers_desc["TLS1_CK_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA"]= "EXP-EDH-DSS-DES-CBC-SHA|TLSv1|DH(512)|DSS|DES-CBC(40)|SHA1|export";
ciphers_desc["TLS1_CK_DHE_DSS_WITH_DES_CBC_SHA"]         = "EDH-DSS-DES-CBC-SHA|TLSv1|DH|DSS|DES-CBC(56)|SHA1";
ciphers_desc["TLS1_CK_DHE_DSS_WITH_3DES_EDE_CBC_SHA"]    = "EDH-DSS-DES-CBC3-SHA|TLSv1|DH|DSS|3DES-CBC(168)|SHA1";
ciphers_desc["TLS1_CK_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA"]= "EXP-EDH-RSA-DES-CBC-SHA|TLSv1|DH(512)|RSA|DES-CBC(40)|SHA1|export";
ciphers_desc["TLS1_CK_DHE_RSA_WITH_DES_CBC_SHA"]         = "EDH-RSA-DES-CBC-SHA|TLSv1|DH|RSA|DES-CBC(56)|SHA1";
ciphers_desc["TLS1_CK_DHE_RSA_WITH_3DES_EDE_CBC_SHA"]    = "EDH-RSA-DES-CBC3-SHA|TLSv1|DH|RSA|3DES-CBC(168)|SHA1";
ciphers_desc["TLS1_CK_DH_anon_EXPORT_WITH_RC4_40_MD5"]   = "EXP-ADH-RC4-MD5|TLSv1|DH(512)|None|RC4(40)|MD5|export";
ciphers_desc["TLS1_CK_DH_anon_WITH_RC4_128_MD5"]         = "ADH-RC4-MD5|TLSv1|DH|None|RC4(128)|MD5";
ciphers_desc["TLS1_CK_DH_anon_EXPORT_WITH_DES40_CBC_SHA"]= "EXP-ADH-DES-CBC-SHA|TLSv1|DH(512)|None|DES-CBC(40)|SHA1|export";
ciphers_desc["TLS1_CK_DH_anon_WITH_DES_CBC_SHA"]         = "ADH-DES-CBC-SHA|TLSv1|DH|None|DES-CBC(56)|SHA1";
ciphers_desc["TLS1_CK_DH_anon_WITH_3DES_EDE_CBC_SHA"]    = "ADH-DES-CBC3-SHA|TLSv1|DH|None|3DES-CBC(168)|SHA1";
ciphers_desc["TLS1_CK_KRB5_WITH_DES_CBC_SHA"]            = "KRB5-DES-CBC-SHA|TLSv1|KRB5|KRB5|DES-CBC(56)|SHA1";
ciphers_desc["TLS1_CK_KRB5_WITH_3DES_EDE_CBC_SHA"]       = "KRB5-DES-CBC3-SHA|TLSv1|KRB5|KRB5|3DES-CBC(168)|SHA1";
ciphers_desc["TLS1_CK_KRB5_WITH_RC4_128_SHA"]            = "KRB5-RC4-SHA|TLSv1|KRB5|KRB5|RC4(128)|SHA1";
ciphers_desc["TLS1_CK_KRB5_WITH_IDEA_CBC_SHA"]           = "KRB5-IDEA-CBC-SHA|TLSv1|KRB5|KRB5|IDEA-CBC(128)|SHA1";
ciphers_desc["TLS1_CK_KRB5_WITH_DES_CBC_MD5"]            = "KRB5-DES-CBC-MD5|TLSv1|KRB5|KRB5|DES-CBC(56)|MD5";
ciphers_desc["TLS1_CK_KRB5_WITH_3DES_EDE_CBC_MD5"]       = "KRB5-DES-CBC3-MD5|TLSv1|KRB5|KRB5|3DES-CBC(168)|MD5";
ciphers_desc["TLS1_CK_KRB5_WITH_RC4_128_MD5"]            = "KRB5-RC4-MD5|TLSv1|KRB5|KRB5|RC4(128)|MD5";
ciphers_desc["TLS1_CK_KRB5_WITH_IDEA_CBC_MD5"]           = "KRB5-IDEA-CBC-MD5|TLSv1|KRB5|KRB5|IDEA-CBC(128)|MD5";
ciphers_desc["TLS1_CK_KRB5_EXPORT_WITH_DES_CBC_40_SHA"]  = "EXP-KRB5-DES-CBC-SHA|TLSv1|KRB5|KRB5|DES-CBC(40)|SHA1|export";
ciphers_desc["TLS1_CK_KRB5_EXPORT_WITH_RC2_CBC_40_SHA"]  = "EXP-KRB5-RC2-CBC-SHA|TLSv1|KRB5|KRB5|RC2-CBC(40)|SHA1|export";
ciphers_desc["TLS1_CK_KRB5_EXPORT_WITH_RC4_40_SHA"]      = "EXP-KRB5-RC4-SHA|TLSv1|KRB5|KRB5|RC4(40)|SHA1|export";
ciphers_desc["TLS1_CK_KRB5_EXPORT_WITH_DES_CBC_40_MD5"]  = "EXP-KRB5-DES-CBC-MD5|TLSv1|KRB5|KRB5|DES-CBC(40)|MD5|export";
ciphers_desc["TLS1_CK_KRB5_EXPORT_WITH_RC2_CBC_40_MD5"]  = "EXP-KRB5-RC2-CBC-MD5|TLSv1|KRB5|KRB5|RC2-CBC(40)|MD5|export";
ciphers_desc["TLS1_CK_KRB5_EXPORT_WITH_RC4_40_MD5"]      = "EXP-KRB5-RC4-MD5|TLSv1|KRB5|KRB5|RC4(40)|MD5|export";
ciphers_desc["TLS1_PSK_WITH_NULL_SHA"]                   = "PSK-NULL-SHA|TLSv1|PSK|PSK|None|SHA1";
ciphers_desc["TLS1_DHE_PSK_WITH_NULL_SHA"]               = "DHE-PSK-NULL-SHA|TLSv1|DH|PSK|None|SHA1";
ciphers_desc["TLS1_RSA_PSK_WITH_NULL_SHA"]               = "RSA-PSK-NULL-SHA|TLSv1|RSA|PSK|None|SHA1";
ciphers_desc["TLS1_CK_RSA_WITH_AES_128_CBC_SHA"]         = "AES128-SHA|TLSv1|RSA|RSA|AES-CBC(128)|SHA1";
ciphers_desc["TLS1_CK_DH_DSS_WITH_AES_128_CBC_SHA"]      = "DH-DSS-AES128-SHA|TLSv1|StaticDH|DSS|AES-CBC(128)|SHA1";
ciphers_desc["TLS1_CK_DH_RSA_WITH_AES_128_CBC_SHA"]      = "DH-RSA-AES128-SHA|TLSv1|StaticDH|RSA|AES-CBC(128)|SHA1";
ciphers_desc["TLS1_CK_DHE_DSS_WITH_AES_128_CBC_SHA"]     = "DHE-DSS-AES128-SHA|TLSv1|DH|DSS|AES-CBC(128)|SHA1";
ciphers_desc["TLS1_CK_DHE_RSA_WITH_AES_128_CBC_SHA"]     = "DHE-RSA-AES128-SHA|TLSv1|DH|RSA|AES-CBC(128)|SHA1";
ciphers_desc["TLS1_CK_DH_anon_WITH_AES_128_CBC_SHA"]     = "ADH-AES128-SHA|TLSv1|DH|None|AES-CBC(128)|SHA1";
ciphers_desc["TLS1_CK_RSA_WITH_AES_256_CBC_SHA"]         = "AES256-SHA|TLSv1|RSA|RSA|AES-CBC(256)|SHA1";
ciphers_desc["TLS1_CK_DH_DSS_WITH_AES_256_CBC_SHA"]      = "DH-DSS-AES256-SHA|TLSv1|StaticDH|DSS|AES-CBC(256)|SHA1";
ciphers_desc["TLS1_CK_DH_RSA_WITH_AES_256_CBC_SHA"]      = "DH-RSA-AES256-SHA|TLSv1|StaticDH|RSA|AES-CBC(256)|SHA1";
ciphers_desc["TLS1_CK_DHE_DSS_WITH_AES_256_CBC_SHA"]     = "DHE-DSS-AES256-SHA|TLSv1|DH|DSS|AES-CBC(256)|SHA1";
ciphers_desc["TLS1_CK_DHE_RSA_WITH_AES_256_CBC_SHA"]     = "DHE-RSA-AES256-SHA|TLSv1|DH|RSA|AES-CBC(256)|SHA1";
ciphers_desc["TLS1_CK_DH_anon_WITH_AES_256_CBC_SHA"]     = "ADH-AES256-SHA|TLSv1|DH|None|AES-CBC(256)|SHA1";
ciphers_desc["TLS1_RSA_WITH_NULL_SHA256"]                = "RSA-NULL-SHA256|TLSv1|RSA|RSA|None|SHA256";
ciphers_desc["TLS1_RSA_WITH_AES_128_CBC_SHA256"]         = "RSA-AES128-SHA256|TLSv1|RSA|RSA|AES-CBC(128)|SHA256";
ciphers_desc["TLS1_RSA_WITH_AES_256_CBC_SHA256"]         = "RSA-AES256-SHA256|TLSv1|RSA|RSA|AES-CBC(256)|SHA256";
ciphers_desc["TLS1_DH_DSS_WITH_AES_128_CBC_SHA256"]      = "DH-DSS-AES128-SHA256|TLSv1|StaticDH|DSS|AES-CBC(128)|SHA256";
ciphers_desc["TLS1_DH_RSA_WITH_AES_128_CBC_SHA256"]      = "DH-RSA-AES128-SHA256|TLSv1|StaticDH|RSA|AES-CBC(128)|SHA256";
ciphers_desc["TLS1_DHE_DSS_WITH_AES_128_CBC_SHA256"]     = "DHE-DSS-AES128-SHA256|TLSv1|DH|DSS|AES-CBC(128)|SHA256";
ciphers_desc["TLS1_DHE_RSA_WITH_AES_128_CBC_SHA256"]     = "DHE-RSA-AES128-SHA256|TLSv1|DH|RSA|AES-CBC(128)|SHA256";
ciphers_desc["TLS1_DH_DSS_WITH_AES_256_CBC_SHA256"]      = "DH-DSS-AES256-SHA256|TLSv1|StaticDH|DSS|AES-CBC(256)|SHA256";
ciphers_desc["TLS1_DH_RSA_WITH_AES_256_CBC_SHA256"]      = "DH-RSA-AES256-SHA256|TLSv1|StaticDH|RSA|AES-CBC(256)|SHA256";
ciphers_desc["TLS1_DHE_DSS_WITH_AES_256_CBC_SHA256"]      = "DHE-DSS-AES256-SHA256|TLSv1|DH|DSS|AES-CBC(256)|SHA256";
ciphers_desc["TLS1_DHE_RSA_WITH_AES_256_CBC_SHA256"]      = "DHE-RSA-AES256-SHA256|TLSv1|DH|RSA|AES-CBC(256)|SHA256";
ciphers_desc["TLS1_DH_anon_WITH_AES_128_CBC_SHA256"]      = "DH-AES128-SHA256|TLSv1|DH|None|AES-CBC(128)|SHA256";
ciphers_desc["TLS1_DH_anon_WITH_AES_256_CBC_SHA256"]      = "DH-AES256-SHA256|TLSv1|DH|None|AES-CBC(256)|SHA256";
ciphers_desc["TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_MD5"]   = "EXP1024-RC4-MD5|TLSv1|RSA(1024)|RSA|RC4(56)|MD5|export";
ciphers_desc["TLS1_CK_RSA_EXPORT1024_WITH_RC2_CBC_56_MD5"]= "EXP1024-RC2-CBC-MD5|TLSv1|RSA(1024)|RSA|RC2-CBC(56)|MD5|export";
ciphers_desc["TLS1_CK_RSA_EXPORT1024_WITH_DES_CBC_SHA"]  = "EXP1024-DES-CBC-SHA|TLSv1|RSA(1024)|RSA|DES-CBC(56)|SHA1|export";
ciphers_desc["TLS1_CK_DHE_DSS_EXPORT1024_WITH_DES_CBC_SHA"]= "EXP1024-DHE-DSS-DES-CBC-SHA|TLSv1|DH(1024)|DSS|DES-CBC(56)|SHA1|export";
ciphers_desc["TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_SHA"]   = "EXP1024-RC4-SHA|TLSv1|RSA(1024)|RSA|RC4(56)|SHA1|export";
ciphers_desc["TLS1_CK_DHE_DSS_EXPORT1024_WITH_RC4_56_SHA"]= "EXP1024-DHE-DSS-RC4-SHA|TLSv1|DH(1024)|DSS|RC4(56)|SHA1|export";
ciphers_desc["TLS1_CK_DHE_DSS_WITH_RC4_128_SHA"]         = "DHE-DSS-RC4-SHA|TLSv1|DH|DSS|RC4(128)|SHA1";
ciphers_desc["TLS1_CK_RSA_WITH_CAMELLIA_128_CBC_SHA"]    = "CAMELLIA128-SHA|TLSv1|RSA|RSA|Camellia-CBC(128)|SHA1";
ciphers_desc["TLS1_CK_DH_DSS_WITH_CAMELLIA_128_CBC_SHA"] = "DH-DSS-CAMELLIA128-SHA|TLSv1|StaticDH|DSS|Camellia-CBC(128)|SHA1";
ciphers_desc["TLS1_CK_DH_RSA_WITH_CAMELLIA_128_CBC_SHA"] = "DH-RSA-CAMELLIA128-SHA|TLSv1|StaticDH|RSA|Camellia-CBC(128)|SHA1";
ciphers_desc["TLS1_CK_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA"]= "DHE-DSS-CAMELLIA128-SHA|TLSv1|DH|DSS|Camellia-CBC(128)|SHA1";
ciphers_desc["TLS1_CK_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA"]= "DHE-RSA-CAMELLIA128-SHA|TLSv1|DH|RSA|Camellia-CBC(128)|SHA1";
ciphers_desc["TLS1_CK_DH_anon_WITH_CAMELLIA_128_CBC_SHA"]= "ADH-CAMELLIA128-SHA|TLSv1|DH|None|Camellia-CBC(128)|SHA1";
ciphers_desc["TLS1_CK_RSA_WITH_CAMELLIA_256_CBC_SHA"]    = "CAMELLIA256-SHA|TLSv1|RSA|RSA|Camellia-CBC(256)|SHA1";
ciphers_desc["TLS1_CK_DH_DSS_WITH_CAMELLIA_256_CBC_SHA"] = "DH-DSS-CAMELLIA256-SHA|TLSv1|StaticDH|DSS|Camellia-CBC(256)|SHA1";
ciphers_desc["TLS1_CK_DH_RSA_WITH_CAMELLIA_256_CBC_SHA"] = "DH-RSA-CAMELLIA256-SHA|TLSv1|StaticDH|RSA|Camellia-CBC(256)|SHA1";
ciphers_desc["TLS1_CK_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA"]= "DHE-DSS-CAMELLIA256-SHA|TLSv1|DH|DSS|Camellia-CBC(256)|SHA1";
ciphers_desc["TLS1_CK_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA"]= "DHE-RSA-CAMELLIA256-SHA|TLSv1|DH|RSA|Camellia-CBC(256)|SHA1";
ciphers_desc["TLS1_CK_DH_anon_WITH_CAMELLIA_256_CBC_SHA"]= "ADH-CAMELLIA256-SHA|TLSv1|DH|None|Camellia-CBC(256)|SHA1";
ciphers_desc["TLS1_GOSTR341094_WITH_28147_CNT_IMIT"]     = "GOST94-GOST89-GOST89|TLSv1|GOST|GOST94|GOST2814789CNT(256)|GOST89MAC";
ciphers_desc["TLS1_GOSTR341001_WITH_28147_CNT_IMIT"]     = "GOST2001-GOST89-GOST89|TLSv1|GOST|GOST01|GOST2814789CNT(256)|GOST89MAC";
ciphers_desc["TLS1_GOSTR341094_WITH_NULL_GOSTR3411"]     = "GOST94-NULL-GOST94|TLSv1|GOST|GOST94|None|GOST94";
ciphers_desc["TLS1_GOSTR341001_WITH_NULL_GOSTR3411"]     = "GOST2001-NULL-GOST94|TLSv1|GOST|GOST01|None|GOST94";
ciphers_desc["TLS1_CK_PSK_WITH_RC4_128_SHA"]             = "PSK-RC4-SHA|TLSv1|PSK|PSK|RC4(128)|SHA1";
ciphers_desc["TLS1_CK_PSK_WITH_3DES_EDE_CBC_SHA"]        = "PSK-3DES-EDE-CBC-SHA|TLSv1|PSK|PSK|3DES-CBC(168)|SHA1";
ciphers_desc["TLS1_CK_PSK_WITH_AES_128_CBC_SHA"]         = "PSK-AES128-CBC-SHA|TLSv1|PSK|PSK|AES-CBC(128)|SHA1";
ciphers_desc["TLS1_CK_PSK_WITH_AES_256_CBC_SHA"]         = "PSK-AES256-CBC-SHA|TLSv1|PSK|PSK|AES-CBC(256)|SHA1";
ciphers_desc["TLS1_CK_DHE_PSK_WITH_RC4_128_SHA"]         = "DHE-PSK-RC4128-SHA|TLSv1|DH|PSK|RC4(128)|SHA1";
ciphers_desc["TLS1_CK_DHE_PSK_WITH_3DES_EDE_CBC_SHA"]    = "DHE-PSK-3DES-CBC168-SHA|TLSv1|DH|PSK|3DES-CBC(168)|SHA1";
ciphers_desc["TLS1_CK_DHE_PSK_WITH_AES_128_CBC_SHA"]     = "DHE-PSK-AES128-SHA|TLSv1|DH|PSK|AES-CBC(128)|SHA1";
ciphers_desc["TLS1_CK_DHE_PSK_WITH_AES_256_CBC_SHA"]     = "DHE-PSK-AES256-SHA|TLSv1|DH|PSK|AES-CBC(256)|SHA1";
ciphers_desc["TLS1_CK_RSA_PSK_WITH_RC4_128_SHA"]         = "RSA-PSK-RC4128-SHA|TLSv1|RSA|PSK|RC4(128)|SHA1";
ciphers_desc["TLS1_CK_RSA_PSK_WITH_3DES_EDE_CBC_SHA"]    = "RSA-PSK-3DES-CBC168-SHA|TLSv1|RSA|PSK|3DES-CBC(168)|SHA1";
ciphers_desc["TLS1_CK_RSA_PSK_WITH_AES_128_CBC_SHA"]     = "RSA-PSK-AES128-SHA|TLSv1|RSA|PSK|AES-CBC(128)|SHA1";
ciphers_desc["TLS1_CK_RSA_PSK_WITH_AES_256_CBC_SHA"]     = "RSA-PSK-AES256-SHA|TLSv1|RSA|PSK|AES-CBC(256)|SHA1";
ciphers_desc["TLS1_CK_RSA_WITH_SEED_CBC_SHA"]            = "SEED-SHA|TLSv1|RSA|RSA|SEED-CBC(128)|SHA1";
ciphers_desc["TLS1_CK_DH_DSS_WITH_SEED_CBC_SHA"]         = "DH-DSS-SEED-SHA|TLSv1|StaticDH|DSS|SEED-CBC(128)|SHA1";
ciphers_desc["TLS1_CK_DH_RSA_WITH_SEED_CBC_SHA"]         = "DH-RSA-SEED-SHA|TLSv1|StaticDH|RSA|SEED-CBC(128)|SHA1";
ciphers_desc["TLS1_CK_DHE_DSS_WITH_SEED_CBC_SHA"]        = "DHE-DSS-SEED-SHA|TLSv1|DH|DSS|SEED-CBC(128)|SHA1";
ciphers_desc["TLS1_CK_DHE_RSA_WITH_SEED_CBC_SHA"]        = "DHE-RSA-SEED-SHA|TLSv1|DH|RSA|SEED-CBC(128)|SHA1";
ciphers_desc["TLS1_CK_DH_anon_WITH_SEED_CBC_SHA"]        = "ADH-SEED-SHA|TLSv1|DH|None|SEED-CBC(128)|SHA1";
ciphers_desc["TLS12_PSK_WITH_AES_128_GCM_SHA256"]        = "PSK-AES128-SHA256|TLSv12|PSK|PSK|AES-GCM(128)|SHA256";
ciphers_desc["TLS12_PSK_WITH_AES_256_GCM_SHA384"]        = "PSK-AES256-SHA384|TLSv12|PSK|PSK|AES-GCM(256)|SHA384";
ciphers_desc["TLS12_DHE_PSK_WITH_AES_128_GCM_SHA256"]    = "DHE-PSK-AES128-SHA256|TLSv12|DH|PSK|AES-GCM(128)|SHA256";
ciphers_desc["TLS12_DHE_PSK_WITH_AES_256_GCM_SHA384"]    = "DHE-PSK-AES256-SHA384|TLSv12|DH|PSK|AES-GCM(256)|SHA384";
ciphers_desc["TLS12_RSA_PSK_WITH_AES_128_GCM_SHA256"]    = "RSA-PSK-AES128-SHA256|TLSv12|RSA|PSK|AES-GCM(128)|SHA256";
ciphers_desc["TLS12_RSA_PSK_WITH_AES_256_GCM_SHA384"]    = "RSA-PSK-AES256-SHA384|TLSv12|RSA|PSK|AES-GCM(256)|SHA384";
ciphers_desc["TLS1_CK_ECDH_ECDSA_WITH_NULL_SHA"]         = "ECDH-ECDSA-NULL-SHA|TLSv1|StaticECDH|ECDSA|None|SHA1";
ciphers_desc["TLS1_CK_ECDH_ECDSA_WITH_RC4_128_SHA"]      = "ECDH-ECDSA-RC4-SHA|TLSv1|StaticECDH|ECDSA|RC4(128)|SHA1";
ciphers_desc["TLS1_CK_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA"] = "ECDH-ECDSA-DES-CBC3-SHA|TLSv1|StaticECDH|ECDSA|3DES-CBC(168)|SHA1";
ciphers_desc["TLS1_CK_ECDH_ECDSA_WITH_AES_128_CBC_SHA"]  = "ECDH-ECDSA-AES128-SHA|TLSv1|StaticECDH|ECDSA|AES-CBC(128)|SHA1";
ciphers_desc["TLS1_CK_ECDH_ECDSA_WITH_AES_256_CBC_SHA"]  = "ECDH-ECDSA-AES256-SHA|TLSv1|StaticECDH|ECDSA|AES-CBC(256)|SHA1";
ciphers_desc["TLS1_CK_ECDHE_ECDSA_WITH_NULL_SHA"]        = "ECDHE-ECDSA-NULL-SHA|TLSv1|ECDH|ECDSA|None|SHA1";
ciphers_desc["TLS1_CK_ECDHE_ECDSA_WITH_RC4_128_SHA"]     = "ECDHE-ECDSA-RC4-SHA|TLSv1|ECDH|ECDSA|RC4(128)|SHA1";
ciphers_desc["TLS1_CK_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA"]= "ECDHE-ECDSA-DES-CBC3-SHA|TLSv1|ECDH|ECDSA|3DES-CBC(168)|SHA1";
ciphers_desc["TLS1_CK_ECDHE_ECDSA_WITH_AES_128_CBC_SHA"] = "ECDHE-ECDSA-AES128-SHA|TLSv1|ECDH|ECDSA|AES-CBC(128)|SHA1";
ciphers_desc["TLS1_CK_ECDHE_ECDSA_WITH_AES_256_CBC_SHA"] = "ECDHE-ECDSA-AES256-SHA|TLSv1|ECDH|ECDSA|AES-CBC(256)|SHA1";
ciphers_desc["TLS1_CK_ECDH_RSA_WITH_NULL_SHA"]           = "ECDH-RSA-NULL-SHA|TLSv1|StaticECDH|RSA|None|SHA1";
ciphers_desc["TLS1_CK_ECDH_RSA_WITH_RC4_128_SHA"]        = "ECDH-RSA-RC4-SHA|TLSv1|StaticECDH|RSA|RC4(128)|SHA1";
ciphers_desc["TLS1_CK_ECDH_RSA_WITH_3DES_EDE_CBC_SHA"]   = "ECDH-RSA-DES-CBC3-SHA|TLSv1|StaticECDH|RSA|3DES-CBC(168)|SHA1";
ciphers_desc["TLS1_CK_ECDH_RSA_WITH_AES_128_CBC_SHA"]    = "ECDH-RSA-AES128-SHA|TLSv1|StaticECDH|RSA|AES-CBC(128)|SHA1";
ciphers_desc["TLS1_CK_ECDH_RSA_WITH_AES_256_CBC_SHA"]    = "ECDH-RSA-AES256-SHA|TLSv1|StaticECDH|RSA|AES-CBC(256)|SHA1";
ciphers_desc["TLS1_CK_ECDHE_RSA_WITH_NULL_SHA"]          = "ECDHE-RSA-NULL-SHA|TLSv1|ECDH|RSA|None|SHA1";
ciphers_desc["TLS1_CK_ECDHE_RSA_WITH_RC4_128_SHA"]       = "ECDHE-RSA-RC4-SHA|TLSv1|ECDH|RSA|RC4(128)|SHA1";
ciphers_desc["TLS1_CK_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA"]  = "ECDHE-RSA-DES-CBC3-SHA|TLSv1|ECDH|RSA|3DES-CBC(168)|SHA1";
ciphers_desc["TLS1_CK_ECDHE_RSA_WITH_AES_128_CBC_SHA"]   = "ECDHE-RSA-AES128-SHA|TLSv1|ECDH|RSA|AES-CBC(128)|SHA1";
ciphers_desc["TLS1_CK_ECDHE_RSA_WITH_AES_256_CBC_SHA"]   = "ECDHE-RSA-AES256-SHA|TLSv1|ECDH|RSA|AES-CBC(256)|SHA1";
ciphers_desc["TLS1_CK_ECDH_anon_NULL_WITH_SHA"]          = "AECDH-NULL-SHA|TLSv1|ECDH|None|None|SHA1";
ciphers_desc["TLS1_CK_ECDH_anon_WITH_RC4_128_SHA"]       = "AECDH-RC4-SHA|TLSv1|ECDH|None|RC4(128)|SHA1";
ciphers_desc["TLS1_CK_ECDH_anon_WITH_3DES_EDE_CBC_SHA"]  = "AECDH-DES-CBC3-SHA|TLSv1|ECDH|None|3DES-CBC(168)|SHA1";
ciphers_desc["TLS1_CK_ECDH_anon_WITH_AES_128_CBC_SHA"]   = "AECDH-AES128-SHA|TLSv1|ECDH|None|AES-CBC(128)|SHA1";
ciphers_desc["TLS1_CK_ECDH_anon_WITH_AES_256_CBC_SHA"]   = "AECDH-AES256-SHA|TLSv1|ECDH|None|AES-CBC(256)|SHA1";
ciphers_desc["TLS1_SRP_SHA_WITH_3DES_EDE_CBC_SHA"]       = "SRP-3DES168-SHA|TLSv1|SRP|SHA|3DES-CBC(168)|SHA1";
ciphers_desc["TLS1_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA"]   = "SRP-RSA-3DES168-SHA|TLSv1|SRP|SHA_RSA|3DES-CBC(168)|SHA1";
ciphers_desc["TLS1_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA"]   = "SRP-DSS-3DES168-SHA|TLSv1|SRP|SHA_DSS|3DES-CBC(168)|SHA1";
ciphers_desc["TLS1_SRP_SHA_WITH_AES_128_CBC_SHA"]        = "SRP-AES128-SHA|TLSv1|SRP|SHA|AES-CBC(128)|SHA1";
ciphers_desc["TLS1_SRP_SHA_RSA_WITH_AES_128_CBC_SHA"]    = "SRP-RSA-AES128-SHA|TLSv1|SRP|SHA_RSA|AES-CBC(128)|SHA1";
ciphers_desc["TLS1_SRP_SHA_DSS_WITH_AES_128_CBC_SHA"]    = "SRP-DSS-AES128-SHA|TLSv1|SRP|SHA_DSS|AES-CBC(128)|SHA1";
ciphers_desc["TLS1_SRP_SHA_WITH_AES_256_CBC_SHA"]        = "SRP-AES256-SHA|TLSv1|SRP|SHA|AES-CBC(256)|SHA1";
ciphers_desc["TLS1_SRP_SHA_RSA_WITH_AES_256_CBC_SHA"]    = "SRP-RSA-AES256-SHA|TLSv1|SRP|SHA_RSS|AES-CBC(256)|SHA1";
ciphers_desc["TLS1_SRP_SHA_DSS_WITH_AES_256_CBC_SHA"]    = "SRP-DSS-AES256-SHA|TLSv1|SRP|SHA_DSS|AES-CBC(256)|SHA1";
ciphers_desc["TLS1_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256"] = "ECDHE-ECDSA-AES128-SHA256|TLSv1|ECDH|ECDSA|AES-CBC(128)|SHA256";
ciphers_desc["TLS1_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384"] = "ECDHE-ECDSA-AES256-SHA384|TLSv1|ECDH|ECDSA|AES-CBC(256)|SHA384";
ciphers_desc["TLS1_ECDH_ECDSA_WITH_AES_128_CBC_SHA256"]  = "ECDH-ECDSA-AES128-SHA256|TLSv1|StaticECDH|ECDSA|AES-CBC(128)|SHA256";
ciphers_desc["TLS1_ECDH_ECDSA_WITH_AES_256_CBC_SHA384"]  = "ECDH-ECDSA-AES256-SHA384|TLSv1|StaticECDH|ECDSA|AES-CBC(256)|SHA384";
ciphers_desc["TLS1_ECDHE_RSA_WITH_AES_128_CBC_SHA256"]   = "ECDHE-RSA-AES128-SHA256|TLSv1|ECDH|RSA|AES-CBC(128)|SHA256";
ciphers_desc["TLS1_ECDHE_RSA_WITH_AES_256_CBC_SHA384"]   = "ECDHE-RSA-AES256-SHA384|TLSv1|ECDH|RSA|AES-CBC(256)|SHA384";
ciphers_desc["TLS1_ECDH_RSA_WITH_AES_128_CBC_SHA256"]    = "ECDH-RSA-AES128-SHA256|TLSv1|StaticECDH|RSA|AES-CBC(128)|SHA256";
ciphers_desc["TLS1_ECDH_RSA_WITH_AES_256_CBC_SHA384"]    = "ECDH-RSA-AES256-SHA384|TLSv1|StaticECDH|RSA|AES-CBC(256)|SHA384";
ciphers_desc["TLS1_ECDHE_PSK_WITH_RC4_128_SHA"]          = "ECDHE-PSK-RC4-128-SHA|TLSv1|ECDHE_PSK|PSK|RC4(128)|SHA1";
ciphers_desc["TLS1_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA"]     = "ECDHE-PSK-3DES168-SHA|TLSv1|ECDHE_PSK|PSK|3DES-CBC(168)|SHA1";
ciphers_desc["TLS1_ECDHE_PSK_WITH_AES_128_CBC_SHA"]      = "ECDHE-PSK-AES128-SHA|TLSv1|ECDHE_PSK|PSK|AES-CBC(128)|SHA1";
ciphers_desc["TLS1_ECDHE_PSK_WITH_AES_256_CBC_SHA"]      = "ECDHE-PSK-AES256-SHA|TLSv1|ECDHE_PSK|PSK|AES-CBC(256)|SHA1";
ciphers_desc["TLS1_ECDHE_PSK_WITH_AES_128_CBC_SHA256"]   = "ECDHE-PSK-AES128-SHA256|TLSv1|ECDHE_PSK|PSK|AES-CBC(128)|SHA256";
ciphers_desc["TLS1_ECDHE_PSK_WITH_AES_256_CBC_SHA384"]   = "ECDHE-PSK-AES256-SHA384|TLSv1|ECDHE_PSK|PSK|AES-CBC(256)|SHA384";
ciphers_desc["TLS1_ECDHE_PSK_WITH_NULL_SHA"]             = "ECDHE-PSK-NULL-SHA|TLSv1|ECDHE_PSK|PSK|None|SHA1";
ciphers_desc["TLS1_ECDHE_PSK_WITH_NULL_SHA256"]          = "ECDHE-PSK-NULL-SHA256|TLSv1|ECDHE_PSK|PSK|None|SHA256";
ciphers_desc["TLS1_ECDHE_PSK_WITH_NULL_SHA384"]          = "ECDHE-PSK-NULL-SHA384|TLSv1|ECDHE_PSK|PSK|None|SHA384";
ciphers_desc["TLS12_RSA_WITH_AES_128_GCM_SHA256"]        = "RSA-AES128-SHA256|TLSv12|RSA|RSA|AES-GCM(128)|SHA256";
ciphers_desc["TLS12_RSA_WITH_AES_256_GCM_SHA384"]        = "RSA-AES256-SHA384|TLSv12|RSA|RSA|AES-GCM(256)|SHA384";
ciphers_desc["TLS12_DHE_RSA_WITH_AES_128_GCM_SHA256"]    = "DHE-RSA-AES128-SHA256|TLSv12|DH|RSA|AES-GCM(128)|SHA256";
ciphers_desc["TLS12_DHE_RSA_WITH_AES_256_GCM_SHA384"]    = "DHE-RSA-AES256-SHA384|TLSv12|DH|RSA|AES-GCM(256)|SHA384";
ciphers_desc["TLS12_DH_RSA_WITH_AES_128_GCM_SHA256"]     = "DH-RSA-AES128-SHA256|TLSv12|StaticDH|RSA|AES-GCM(128)|SHA256";
ciphers_desc["TLS12_DH_RSA_WITH_AES_256_GCM_SHA384"]     = "DH-RSA-AES256-SHA384|TLSv12|StaticDH|RSA|AES-GCM(256)|SHA384";
ciphers_desc["TLS12_DHE_DSS_WITH_AES_128_GCM_SHA256"]    = "DHE-DSS-AES128-SHA256|TLSv12|DH|DSS|AES-GCM(128)|SHA256";
ciphers_desc["TLS12_DHE_DSS_WITH_AES_256_GCM_SHA384"]    = "DHE-DSS-AES256-SHA384|TLSv12|DH|DSS|AES-GCM(256)|SHA384";
ciphers_desc["TLS12_DH_DSS_WITH_AES_128_GCM_SHA256"]     = "DH-DSS-AES128-SHA256|TLSv12|StaticDH|DSS|AES-GCM(128)|SHA256";
ciphers_desc["TLS12_DH_DSS_WITH_AES_256_GCM_SHA384"]     = "DH-DSS-AES256-SHA384|TLSv12|StaticDH|DSS|AES-GCM(256)|SHA384";
ciphers_desc["TLS12_DH_anon_WITH_AES_128_GCM_SHA256"]    = "DH-AES128-SHA256|TLSv12|DH|None|AES-GCM(128)|SHA256";
ciphers_desc["TLS12_DH_anon_WITH_AES_256_GCM_SHA384"]    = "DH-AES256-SHA384|TLSv12|DH|None|AES-GCM(256)|SHA384";
ciphers_desc["TLS12_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256"]= "ECDHE-ECDSA-AES128-SHA256|TLSv12|ECDH|ECDSA|AES-GCM(128)|SHA256";
ciphers_desc["TLS12_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384"]= "ECDHE-ECDSA-AES256-SHA384|TLSv12|ECDH|ECDSA|AES-GCM(256)|SHA384";
ciphers_desc["TLS12_ECDH_ECDSA_WITH_AES_128_GCM_SHA256"] = "ECDH-ECDSA-AES128-SHA256|TLSv12|StaticECDH|ECDSA|AES-GCM(128)|SHA256";
ciphers_desc["TLS12_ECDH_ECDSA_WITH_AES_256_GCM_SHA384"] = "ECDH-ECDSA-AES256-SHA384|TLSv12|StaticECDH|ECDSA|AES-GCM(256)|SHA384";
ciphers_desc["TLS12_ECDHE_RSA_WITH_AES_128_GCM_SHA256"]  = "ECDHE-RSA-AES128-SHA256|TLSv12|ECDH|RSA|AES-GCM(128)|SHA256";
ciphers_desc["TLS12_ECDHE_RSA_WITH_AES_256_GCM_SHA384"]  = "ECDHE-RSA-AES256-SHA384|TLSv12|ECDH|RSA|AES-GCM(256)|SHA384";
ciphers_desc["TLS12_ECDH_RSA_WITH_AES_128_GCM_SHA256"]   = "ECDH-RSA-AES128-SHA256|TLSv12|StaticECDH|RSA|AES-GCM(128)|SHA256";
ciphers_desc["TLS12_ECDH_RSA_WITH_AES_256_GCM_SHA384"]   = "ECDH-RSA-AES256-SHA384|TLSv12|StaticECDH|RSA|AES-GCM(256)|SHA384";
ciphers_desc["TLS1_PSK_WITH_AES_128_CBC_SHA256"]         = "PSK-AES128-SHA256|TLSv1|PSK|PSK|AES-CBC(128)|SHA256";
ciphers_desc["TLS1_PSK_WITH_AES_256_CBC_SHA384"]         = "PSK-AES256-SHA384|TLSv1|PSK|PSK|AES-CBC(256)|SHA384";
ciphers_desc["TLS1_PSK_WITH_NULL_SHA256"]                = "PSK-NULL-SHA256|TLSv1|PSK|PSK|None|SHA256";
ciphers_desc["TLS1_PSK_WITH_NULL_SHA384"]                = "PSK-NULL-SHA384|TLSv1|PSK|PSK|None|SHA384";
ciphers_desc["TLS1_DHE_PSK_WITH_AES_128_CBC_SHA256"]     = "DHE-PSK-AES128-SHA256|TLSv1|DH|PSK|AES-CBC(128)|SHA256";
ciphers_desc["TLS1_DHE_PSK_WITH_AES_256_CBC_SHA384"]     = "DHE-PSK-AES256-SHA384|TLSv1|DH|PSK|AES-CBC(256)|SHA384";
ciphers_desc["TLS1_DHE_PSK_WITH_NULL_SHA256"]            = "DHE-PSK-NULL-SHA256|TLSv1|DH|PSK|None|SHA256";
ciphers_desc["TLS1_DHE_PSK_WITH_NULL_SHA384"]            = "DHE-PSK-NULL-SHA384|TLSv1|DH|PSK|None|SHA384";
ciphers_desc["TLS1_RSA_PSK_WITH_AES_128_CBC_SHA256"]     = "RSA-PSK-AES128-SHA256|TLSv1|RSA|PSK|AES-CBC(128)|SHA256";
ciphers_desc["TLS1_RSA_PSK_WITH_AES_256_CBC_SHA384"]     = "RSA-PSK-AES256-SHA384|TLSv1|RSA|PSK|AES-CBC(256)|SHA384";
ciphers_desc["TLS1_RSA_PSK_WITH_NULL_SHA256"]            = "RSA-PSK-NULL-SHA256|TLSv1|RSA|PSK|None|SHA256";
ciphers_desc["TLS1_RSA_PSK_WITH_NULL_SHA384"]            = "RSA-PSK-NULL-SHA384|TLSv1|RSA|PSK|None|SHA384";
ciphers_desc["TLS1_RSA_WITH_CAMELLIA_128_CBC_SHA256"]    = "RSA-CAMELLIA128-SHA256|TLSv1|RSA|RSA|Camellia-CBC(128)|SHA256";
ciphers_desc["TLS1_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256"] = "DH-DSS-CAMELLIA128-SHA256|TLSv1|StaticDH|DSS|Camellia-CBC(128)|SHA256";
ciphers_desc["TLS1_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256"] = "DH-RSA-CAMELLIA128-SHA256|TLSv1|StaticDH|RSA|Camellia-CBC(128)|SHA256";
ciphers_desc["TLS1_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256"]= "DHE-DSS-CAMELLIA128-SHA256|TLSv1|DH|DSS|Camellia-CBC(128)|SHA256";
ciphers_desc["TLS1_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256"]= "DHE-RSA-CAMELLIA128-SHA256|TLSv1|DH|RSA|Camellia-CBC(128)|SHA256";
ciphers_desc["TLS1_DH_anon_WITH_CAMELLIA_128_CBC_SHA256"]= "DH-CAMELLIA128-SHA256|TLSv1|DH|None|Camellia-CBC(128)|SHA256";
ciphers_desc["TLS1_RSA_WITH_CAMELLIA_256_CBC_SHA256"]    = "RSA-CAMELLIA256-SHA256|TLSv1|RSA|RSA|Camellia-CBC(256)|SHA256";
ciphers_desc["TLS1_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256"] = "DH-DSS-CAMELLIA256-SHA256|TLSv1|StaticDH|DSS|Camellia-CBC(256)|SHA256";
ciphers_desc["TLS1_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256"] = "DH-RSA-CAMELLIA256-SHA256|TLSv1|StaticDH|RSA|Camellia-CBC(256)|SHA256";
ciphers_desc["TLS1_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256"]= "DHE-DSS-CAMELLIA256-SHA256|TLSv1|DH|DSS|Camellia-CBC(256)|SHA256";
ciphers_desc["TLS1_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256"]= "DHE-RSA-CAMELLIA256-SHA256|TLSv1|DH|RSA|Camellia-CBC(256)|SHA256";
ciphers_desc["TLS1_DH_anon_WITH_CAMELLIA_256_CBC_SHA256"]= "DH-CAMELLIA256-SHA256|TLSv1|DH|None|Camellia-CBC(256)|SHA256";
# RFC 6367
ciphers_desc["TLS12_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256"] = "ECDHE-ECDSA-CAMELLIA-CBC-128|TLSv12|ECDH|ECDSA|Camellia-CBC(128)|SHA256";
ciphers_desc["TLS12_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384"] = "ECDHE-ECDSA-CAMELLIA-CBC-256|TLSv12|ECDH|ECDSA|Camellia-CBC(256)|SHA384";
ciphers_desc["TLS12_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256"]  = "ECDH-ECDSA-CAMELLIA-CBC-128|TLSv12|StaticECDH|ECDSA|Camellia-CBC(128)|SHA256";
ciphers_desc["TLS12_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384"]  = "ECDH-ECDSA-CAMELLIA-CBC-256|TLSv12|StaticECDH|ECDSA|Camellia-CBC(256)|SHA384";
ciphers_desc["TLS12_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256"]   = "ECDHE-RSA-CAMELLIA-CBC-128|TLSv12|ECDH|RSA|Camellia-CBC(128)|SHA256";
ciphers_desc["TLS12_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384"]   = "ECDHE-RSA-CAMELLIA-CBC-256|TLSv12|ECDH|RSA|Camellia-CBC(256)|SHA384";
ciphers_desc["TLS12_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256"]    = "ECDH-RSA-CAMELLIA-CBC-128|TLSv12|StaticECDH|RSA|Camellia-CBC(128)|SHA256";
ciphers_desc["TLS12_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384"]    = "ECDH-RSA-CAMELLIA-CBC-256|TLSv12|StaticECDH|RSA|Camellia-CBC(256)|SHA384";
ciphers_desc["TLS12_RSA_WITH_CAMELLIA_128_GCM_SHA256"]         = "RSA-CAMELLIA-GCM-128|TLSv12|RSA|RSA|Camellia-GCM(128)|SHA256";
ciphers_desc["TLS12_RSA_WITH_CAMELLIA_256_GCM_SHA384"]         = "RSA-CAMELLIA-GCM-256|TLSv12|RSA|RSA|Camellia-GCM(256)|SHA384";
ciphers_desc["TLS12_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256"]     = "DHE-RSA-CAMELLIA-GCM-128|TLSv12|DH|RSA|Camellia-GCM(256)|SHA256";
ciphers_desc["TLS12_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384"]     = "DHE-RSA-CAMELLIA-GCM-256|TLSv12|DH|RSA|Camellia-GCM(256)|SHA384";
ciphers_desc["TLS12_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256"]      = "DH-RSA-CAMELLIA-GCM-128|TLSv12|StaticDH|RSA|Camellia-GCM(128)|SHA256";
ciphers_desc["TLS12_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384"]      = "DH-RSA-CAMELLIA-GCM-256|TLSv12|StaticDH|RSA|Camellia-GCM(256)|SHA384";
ciphers_desc["TLS12_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256"]     = "DHE-DSS-CAMELLIA-GCM-128|TLSv12|DH|DSS|Camellia-GCM(128)|SHA256";
ciphers_desc["TLS12_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384"]     = "DHE-DSS-CAMELLIA-GCM-256|TLSv12|DH|DSS|Camellia-GCM(256)|SHA384";
ciphers_desc["TLS12_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256"]      = "DH-DSS-CAMELLIA-GCM-128|TLSv12|StaticDH|DSS|Camellia-GCM(128)|SHA256";
ciphers_desc["TLS12_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384"]      = "DH-DSS-CAMELLIA-GCM-256|TLSv12|StaticDH|DSS|Camellia-GCM(256)|SHA384";
ciphers_desc["TLS12_DH_anon_WITH_CAMELLIA_128_GCM_SHA256"]     = "DH-CAMELLIA-GCM-128|TLSv12|DH|None|Camellia-GCM(128)|SHA256";
ciphers_desc["TLS12_DH_anon_WITH_CAMELLIA_256_GCM_SHA384"]     = "DH-CAMELLIA-GCM-256|TLSv12|DH|None|Camellia-GCM(256)|SHA384";
ciphers_desc["TLS12_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256"] = "ECDHE-ECDSA-CAMELLIA-GCM-128|TLSv12|ECDH|ECDSA|Camellia-GCM(128)|SHA256";
ciphers_desc["TLS12_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384"] = "ECDHE-ECDSA-CAMELLIA-GCM-256|TLSv12|ECDH|ECDSA|Camellia-GCM(256)|SHA384";
ciphers_desc["TLS12_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256"]  = "ECDH-ECDSA-CAMELLIA-GCM-128|TLSv12|StaticECDH|ECDSA|Camellia-GCM(128)|SHA256";
ciphers_desc["TLS12_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384"]  = "ECDH-ECDSA-CAMELLIA-GCM-256|TLSv12|StaticECDH|ECDSA|Camellia-GCM(256)|SHA384";
ciphers_desc["TLS12_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256"]   = "ECDHE-RSA-CAMELLIA-GCM-128|TLSv12|ECDH|RSA|Camellia-GCM(128)|SHA256";
ciphers_desc["TLS12_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384"]   = "ECDHE-RSA-CAMELLIA-GCM-256|TLSv12|ECDH|RSA|Camellia-GCM(256)|SHA384";
ciphers_desc["TLS12_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256"]    = "ECDH-RSA-CAMELLIA-GCM-128|TLSv12|StaticECDH|RSA|Camellia-GCM(128)|SHA256";
ciphers_desc["TLS12_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384"]    = "ECDH-RSA-CAMELLIA-GCM-256|TLSv12|StaticECDH|RSA|Camellia-GCM(256)|SHA384";
ciphers_desc["TLS12_PSK_WITH_CAMELLIA_128_GCM_SHA256"]         = "PSK-CAMELLIA-GCM-128|TLSv12|PSK|PSK|Camellia-GCM(128)|SHA256";
ciphers_desc["TLS12_PSK_WITH_CAMELLIA_256_GCM_SHA384"]         = "PSK-CAMELLIA-GCM-256|TLSv12|PSK|PSK|Camellia-GCM(256)|SHA384";
ciphers_desc["TLS12_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256"]     = "DHE-PSK-CAMELLIA-GCM-128|TLSv12|DH|PSK|Camellia-GCM(128)|SHA256";
ciphers_desc["TLS12_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384"]     = "DHE-PSK-CAMELLIA-GCM-256|TLSv12|DH|PSK|Camellia-GCM(256)|SHA384";
ciphers_desc["TLS12_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256"]     = "RSA-PSK-CAMELLIA-GCM-128|TLSv12|RSA|PSK|Camellia-GCM(128)|SHA256";
ciphers_desc["TLS12_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384"]     = "RSA-PSK-CAMELLIA-GCM-256|TLSv12|RSA|PSK|Camellia-GCM(256)|SHA384";
ciphers_desc["TLS12_PSK_WITH_CAMELLIA_128_CBC_SHA256"]         = "PSK-CAMELLIA-GCM-128|TLSv12|PSK|PSK|Camellia-CBC(128)|SHA256";
ciphers_desc["TLS12_PSK_WITH_CAMELLIA_256_CBC_SHA384"]         = "PSK-CAMELLIA-GCM-256|TLSv12|PSK|PSK|Camellia-CBC(256)|SHA384";
ciphers_desc["TLS12_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256"]     = "DHE-PSK-CAMELLIA-GCM-128|TLSv12|DH|PSK|Camellia-CBC(128)|SHA256";
ciphers_desc["TLS12_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384"]     = "DHE-PSK-CAMELLIA-GCM-256|TLSv12|DH|PSK|Camellia-CBC(256)|SHA384";
ciphers_desc["TLS12_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256"]     = "RSA-PSK-CAMELLIA-GCM-128|TLSv12|RSA|PSK|Camellia-CBC(128)|SHA256";
ciphers_desc["TLS12_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384"]     = "RSA-PSK-CAMELLIA-GCM-256|TLSv12|RSA|PSK|Camellia-CBC(256)|SHA384";
ciphers_desc["TLS12_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256"]   = "ECDHE-PSK-CAMELLIA-GCM-128|TLSv12|ECDHE_PSK|PSK|Camellia-CBC(128)|SHA256";
ciphers_desc["TLS12_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384"]   = "ECDHE-PSK-CAMELLIA-GCM-256|TLSv12|ECDHE_PSK|PSK|Camellia-CBC(256)|SHA384";
# RFC 6655
ciphers_desc["TLS12_RSA_WITH_AES_128_CCM"]                     = "RSA-AES-128-CCM-AEAD|TLSv12|RSA|RSA|AES-CCM(128)|AEAD";
ciphers_desc["TLS12_RSA_WITH_AES_256_CCM"]                     = "RSA-AES-256-CCM-AEAD|TLSv12|RSA|RSA|AES-CCM(256)|AEAD";
ciphers_desc["TLS12_DHE_RSA_WITH_AES_128_CCM"]                 = "DHE-RSA-AES-128-CCM-AEAD|TLSv12|DH|RSA|AES-CCM(128)|AEAD";
ciphers_desc["TLS12_DHE_RSA_WITH_AES_256_CCM"]                 = "DHE-RSA-AES-256-CCM-AEAD|TLSv12|DH|RSA|AES-CCM(256)|AEAD";
ciphers_desc["TLS12_RSA_WITH_AES_128_CCM_8"]                   = "RSA-AES-128-CCM8-AEAD|TLSv12|RSA|RSA|AES-CCM8(128)|AEAD";
ciphers_desc["TLS12_RSA_WITH_AES_256_CCM_8"]                   = "RSA-AES-256-CCM8-AEAD|TLSv12|RSA|RSA|AES-CCM8(256)|AEAD";
ciphers_desc["TLS12_DHE_RSA_WITH_AES_128_CCM_8"]               = "DHE-RSA-AES-128-CCM8-AEAD|TLSv12|DH|RSA|AES-CCM8(128)|AEAD";
ciphers_desc["TLS12_DHE_RSA_WITH_AES_256_CCM_8"]               = "DHE-RSA-AES-256-CCM8-AEAD|TLSv12|DH|RSA|AES-CCM8(256)|AEAD";
ciphers_desc["TLS12_PSK_WITH_AES_128_CCM"]                     = "PSK-AES-128-CCM-AEAD|TLSv12|PSK|PSK|AES-CCM(128)|AEAD";
ciphers_desc["TLS12_PSK_WITH_AES_256_CCM"]                     = "PSK-AES-256-CCM-AEAD|TLSv12|PSK|PSK|AES-CCM(256)|AEAD";
ciphers_desc["TLS12_DHE_PSK_WITH_AES_128_CCM"]                 = "DHE-PSK-AES-128-CCM-AEAD|TLSv12|DH|PSK|AES-CCM(128)|AEAD";
ciphers_desc["TLS12_DHE_PSK_WITH_AES_256_CCM"]                 = "DHE-PSK-AES-256-CCM-AEAD|TLSv12|DH|PSK|AES-CCM(256)|AEAD";
ciphers_desc["TLS12_PSK_WITH_AES_128_CCM_8"]                   = "PSK-AES-128-CCM8-AEAD|TLSv12|PSK|PSK|AES-CCM8(128)|AEAD";
ciphers_desc["TLS12_PSK_WITH_AES_256_CCM_8"]                   = "PSK-AES-256-CCM8-AEAD|TLSv12|PSK|PSK|AES-CCM8(256)|AEAD";
ciphers_desc["TLS12_PSK_DHE_WITH_AES_128_CCM_8"]               = "DHE-PSK-AES-128-CCM8-AEAD|TLSv12|DH|PSK|AES-CCM8(128)|AEAD";
ciphers_desc["TLS12_PSK_DHE_WITH_AES_256_CCM_8"]               = "DHE-PSK-AES-256-CCM8-AEAD|TLSv12|DH|PSK|AES-CCM8(256)|AEAD";
ciphers_desc["TLS12_ECDHE_ECDSA_WITH_AES_128_CCM"]             = "ECDHE-ECDSA-AES-128-CCM-AEAD|TLSv12|ECDH|ECDSA|AES-CCM(128)|AEAD";
ciphers_desc["TLS12_ECDHE_ECDSA_WITH_AES_256_CCM"]             = "ECDHE-ECDSA-AES-256-CCM-AEAD|TLSv12|ECDH|ECDSA|AES-CCM(256)|AEAD";
ciphers_desc["TLS12_ECDHE_ECDSA_WITH_AES_128_CCM_8"]           = "ECDHE-ECDSA-AES-128-CCM8-AEAD|TLSv12|ECDH|ECDSA|AES-CCM8(128)|AEAD";
ciphers_desc["TLS12_ECDHE_ECDSA_WITH_AES_256_CCM_8"]           = "ECDHE-ECDSA-AES-256-CCM8-AEAD|TLSv12|ECDH|ECDSA|AES-CCM8(256)|AEAD";
# RFC 7251
ciphers_desc["TLS12_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256"]   = "ECDHE-RSA-CHACHA20-POLY1305|TLSv12|ECDH|RSA|ChaCha20-Poly1305(256)|SHA256";
ciphers_desc["TLS12_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256"] = "ECDHE-ECDSA-CHACHA20-POLY1305|TLSv12|ECDH|ECDSA|ChaCha20-Poly1305(256)|SHA256";
ciphers_desc["TLS12_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256"]     = "DHE-RSA-CHACHA20-POLY1305|TLSv12|DH|RSA|ChaCha20-Poly1305(256)|SHA256";
ciphers_desc["TLS12_PSK_WITH_CHACHA20_POLY1305_SHA256"]         = "PSK-CHACHA20-POLY1305|TLSv12|PSK|PSK|ChaCha20-Poly1305(256)|SHA256";
ciphers_desc["TLS12_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256"]   = "ECDHE-PSK-CHACHA20-POLY1305|TLSv12|ECDHE_PSK|PSK|ChaCha20-Poly1305(256)|SHA256";
ciphers_desc["TLS12_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256"]     = "DHE-PSK-CHACHA20-POLY1305|TLSv12|DH|PSK|ChaCha20-Poly1305(256)|SHA256";
ciphers_desc["TLS12_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256"]     = "RSA-PSK-CHACHA20-POLY1305|TLSv12|RSA|PSK|ChaCha20-Poly1305(256)|SHA256";
# Other ciphers not in IANA registry
ciphers_desc["SSL3_FORTEZZA_KEA_WITH_NULL_SHA"]                 = "FORTEZZA-NULL-SHA1|SSLv3|FORTEZZA-KEA|FORTEZZA|None|SHA1";
ciphers_desc["SSL3_FORTEZZA_KEA_WITH_FORTEZZA_CBC_SHA"]         = "FORTEZZA-CBC-SHA1|SSLv3|FORTEZZA-KEA|FORTEZZA|FORTEZZA-CBC(80)|SHA1";
# http://www-archive.mozilla.org/projects/security/pki/nss/ssl/fips-ssl-ciphersuites.html
ciphers_desc["SSL3_RSA_FIPS_WITH_DES_CBC_SHA"]                  = "DES-CBC-SHA(FIPS)|SSLv3|RSA|RSA|DES-CBC(56)|SHA1";
ciphers_desc["SSL3_RSA_FIPS_WITH_3DES_EDE_CBC_SHA"]             = "DES-CBC3-SHA(FIPS)|SSLv3|RSA|RSA|3DES-CBC(168)|SHA1";
ciphers_desc["SSL3_RSA_FIPS_WITH_DES_CBC_SHA_PRIVATE"]          = "DES-CBC-SHA(FIPS, private)|SSLv3|RSA|RSA|DES-CBC(56)|SHA1";
ciphers_desc["SSL3_RSA_FIPS_WITH_3DES_EDE_CBC_SHA_PRIVATE"]     = "DES-CBC3-SHA(FIPS, private)|SSLv3|RSA|RSA|3DES-CBC(168)|SHA1";

# TLS 1.3 ciphers
ciphers_desc["TLS13_AES_128_GCM_SHA256"]                       = "TLS_AES_128_GCM_SHA256|TLSv13|-|-|AES-GCM(128)|AEAD";
ciphers_desc["TLS13_AES_256_GCM_SHA384"]                       = "TLS_AES_256_GCM_SHA384|TLSv13|-|-|AES-GCM(256)|AEAD";
ciphers_desc["TLS13_CHACHA20_POLY1305_SHA256"]                 = "TLS_CHACHA20_POLY1305_SHA256|TLSv13|-|-|ChaCha20-Poly1305(256)|AEAD";
ciphers_desc["TLS13_AES_128_CCM_SHA256"]                       = "TLS_AES_128_CCM_SHA256|TLSv13|-|-|AES-CCM(128)|AEAD";
ciphers_desc["TLS13_AES_128_CCM_8_SHA256"]                     = "TLS_AES_128_CCM_8_SHA256|TLSv13|-|-|AES-CCM8(128)|AEAD";

# From https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml and RFC4492
global_var elliptic_curves;
elliptic_curves["CURVE_SECT163K1"] = raw_string(0, 1);
elliptic_curves["CURVE_SECT163R1"] = raw_string(0, 2);
elliptic_curves["CURVE_SECT163R2"] = raw_string(0, 3);
elliptic_curves["CURVE_SECT193R1"] = raw_string(0, 4);
elliptic_curves["CURVE_SECT193R2"] = raw_string(0, 5);
elliptic_curves["CURVE_SECT233K1"] = raw_string(0, 6);
elliptic_curves["CURVE_SECT233R1"] = raw_string(0, 7);
elliptic_curves["CURVE_SECT239K1"] = raw_string(0, 8);
elliptic_curves["CURVE_SECT283K1"] = raw_string(0, 9);
elliptic_curves["CURVE_SECT283R1"] = raw_string(0, 10);
elliptic_curves["CURVE_SECT409K1"] = raw_string(0, 11);
elliptic_curves["CURVE_SECT409R1"] = raw_string(0, 12);
elliptic_curves["CURVE_SECT571K1"] = raw_string(0, 13);
elliptic_curves["CURVE_SECT571R1"] = raw_string(0, 14);
elliptic_curves["CURVE_SECP160K1"] = raw_string(0, 15);
elliptic_curves["CURVE_SECP160R1"] = raw_string(0, 16);
elliptic_curves["CURVE_SECP160R2"] = raw_string(0, 17);
elliptic_curves["CURVE_SECP192K1"] = raw_string(0, 18);
elliptic_curves["CURVE_SECP192R1"] = raw_string(0, 19);
elliptic_curves["CURVE_SECP224K1"] = raw_string(0, 20);
elliptic_curves["CURVE_SECP224R1"] = raw_string(0, 21);
elliptic_curves["CURVE_SECP256K1"] = raw_string(0, 22);
elliptic_curves["CURVE_SECP256R1"] = raw_string(0, 23);
elliptic_curves["CURVE_SECP384R1"] = raw_string(0, 24);
elliptic_curves["CURVE_SECP521R1"] = raw_string(0, 25);

##
# This is the list of all compression methods available in SSL / TLS.
##
global_var compressors;

compressors = make_array(
  0x00, "NULL",
  0x01, "DEFLATE",
  0x40, "LZS"
);

# As a transitional measure, the following encapsulation
# specifications will add basic support for newer versions of TLS.
# Support added in Nessus 6.4
global_var COMPAT_ENCAPS_TLSv11, COMPAT_ENCAPS_TLSv12, COMPAT_ENCAPS_TLSv13, COMPAT_ENCAPS_TEST, COMPAT_ENCAPS_DISABLE_TLSv1_3, COMPAT_ENCAPS_DISABLE_TLSv1_2, COMPAT_ENCAPS_DISABLE_TLSv1_1, COMPAT_ENCAPS_DISABLE_TLSv1, COMPAT_ENCAPS_DISABLE_SSLv3, COMPAT_ENCAPS_DISABLE_SSLv2;

if (ENCAPS_TLSv1_1)
  COMPAT_ENCAPS_TLSv11 = ENCAPS_TLSv1_1;
else
  COMPAT_ENCAPS_TLSv11 = 6;

if (ENCAPS_TLSv1_2)
  COMPAT_ENCAPS_TLSv12 = ENCAPS_TLSv1_2;
else
  COMPAT_ENCAPS_TLSv12 = 7;

if (ENCAPS_TLSv1_3)
  COMPAT_ENCAPS_TLSv13 = ENCAPS_TLSv1_3;
else
  COMPAT_ENCAPS_TLSv13 = 8;

if (ENCAPS_DISABLE_SSLv2)
  COMPAT_ENCAPS_DISABLE_SSLv2 = ENCAPS_DISABLE_SSLv2;
else
  COMPAT_ENCAPS_DISABLE_SSLv2 = NULL;

if (ENCAPS_DISABLE_SSLv3)
  COMPAT_ENCAPS_DISABLE_SSLv3 = ENCAPS_DISABLE_SSLv3;
else
  COMPAT_ENCAPS_DISABLE_SSLv3 = NULL;

if (ENCAPS_DISABLE_TLSv1)
  COMPAT_ENCAPS_DISABLE_TLSv1 = ENCAPS_DISABLE_TLSv1;
else
  COMPAT_ENCAPS_DISABLE_TLSv1 = NULL;

if (ENCAPS_DISABLE_TLSv1_1)
  COMPAT_ENCAPS_DISABLE_TLSv1_1 = ENCAPS_DISABLE_TLSv1_1;
else
  COMPAT_ENCAPS_DISABLE_TLSv1_1 = NULL;

if (ENCAPS_DISABLE_TLSv1_2)
  COMPAT_ENCAPS_DISABLE_TLSv1_2 = ENCAPS_DISABLE_TLSv1_2;
else
  COMPAT_ENCAPS_DISABLE_TLSv1_2 = NULL;

if (ENCAPS_DISABLE_TLSv1_3)
  COMPAT_ENCAPS_DISABLE_TLSv1_3 = ENCAPS_DISABLE_TLSv1_3;
else
  COMPAT_ENCAPS_DISABLE_TLSv1_3 = NULL;

# For debugging
global_var ENCAPS_NAMES = make_list();
ENCAPS_NAMES[ENCAPS_SSLv2] = "SSLv2";
ENCAPS_NAMES[ENCAPS_SSLv3] = "SSLv3";
ENCAPS_NAMES[ENCAPS_TLSv1] = "TLSv1";
ENCAPS_NAMES[COMPAT_ENCAPS_TLSv11] = "TLSv1.1";
ENCAPS_NAMES[COMPAT_ENCAPS_TLSv12] = "TLSv1.2";
ENCAPS_NAMES[COMPAT_ENCAPS_TLSv13] = "TLSv1.3";

# Define the IDs for the different versions of SSL/TLS.
var SSL_V2 = 0x0002;
var SSL_V3 = 0x0300;
var TLS_10 = 0x0301;
var TLS_11 = 0x0302;
var TLS_12 = 0x0303;
var TLS_13 = 0x0304;
var DTLS_10 = 0xfeff;
var DTLS_12 = 0xfefd;

var SSL2_CONTENT_TYPE_ERROR = 0;
var SSL2_CONTENT_TYPE_CLIENT_HELLO = 1;
var SSL2_CONTENT_TYPE_CLIENT_MASTER_KEY = 2;
var SSL2_CONTENT_TYPE_CLIENT_FINISHED = 3;
var SSL2_CONTENT_TYPE_SERVER_HELLO = 4;
var SSL2_CONTENT_TYPE_SERVER_VERIFY = 5;
var SSL2_CONTENT_TYPE_SERVER_FINISHED = 6;
var SSL2_CONTENT_TYPE_REQUEST_CERTIFICATE = 7;
var SSL2_CONTENT_TYPE_CLIENT_CERTIFICATE = 8;

var SSL3_CONTENT_TYPE_CHANGECIPHERSPEC = 20;
var SSL3_CONTENT_TYPE_ALERT = 21;
var SSL3_CONTENT_TYPE_HANDSHAKE = 22;
var SSL3_CONTENT_TYPE_APPLICATION_DATA = 23;

var SSL3_ALERT_TYPE_CLOSE_NOTIFY = 0;
var SSL3_ALERT_TYPE_WARNING = 1;
var SSL3_ALERT_TYPE_FATAL = 2;
var SSL3_ALERT_TYPE_UNEXPECTED_MESSAGE = 10;
var SSL3_ALERT_TYPE_BAD_RECORD_MAC = 20;
var SSL3_ALERT_TYPE_DECRYPTION_FAILED = 21;
var SSL3_ALERT_TYPE_RECORD_OVERFLOW = 22;
var SSL3_ALERT_TYPE_DECOMPRESSION_FAILURE = 30;
var SSL3_ALERT_TYPE_HANDSHAKE_FAILURE = 40;
var SSL3_ALERT_TYPE_BAD_CERTIFICATE = 42;
var SSL3_ALERT_TYPE_UNSUPPORTED_CERTIFICATE = 43;
var SSL3_ALERT_TYPE_CERTIFICATE_REVOKED = 44;
var SSL3_ALERT_TYPE_CERTIFICATE_EXPIRED = 45;
var SSL3_ALERT_TYPE_CERTIFICATE_UNKNOWN = 46;
var SSL3_ALERT_TYPE_ILLEGAL_PARAMETER = 47;
var SSL3_ALERT_TYPE_UNKNOWN_CA = 48;
var SSL3_ALERT_TYPE_ACCESS_DENIED = 49;
var SSL3_ALERT_TYPE_DECODE_ERROR = 50;
var SSL3_ALERT_TYPE_DECRYPT_ERROR = 51;
var SSL3_ALERT_TYPE_EXPORT_RESTRICTION = 60;
var SSL3_ALERT_TYPE_INAPPROPRIATE_FALLBACK = 86;
var SSL3_ALERT_TYPE_PROTOCOL_VERSION = 70;
var SSL3_ALERT_TYPE_INSUFFICIENT_SECURITY = 71;
var SSL3_ALERT_TYPE_INTERNAL_ERROR = 80;
var SSL3_ALERT_TYPE_USER_CANCELED = 90;
var SSL3_ALERT_TYPE_NO_RENEGOTIATION = 100;
var SSL3_ALERT_TYPE_UNSUPPORTED_EXTENSION = 110;
var SSL3_ALERT_TYPE_CERTIFICATE_UNOBTAINABLE = 111;
var SSL3_ALERT_TYPE_UNRECOGNIZED_NAME = 112;
var SSL3_ALERT_TYPE_BAD_CERTIFICATE_STATUS_RESPONSE = 113;
var SSL3_ALERT_TYPE_BAD_CERTIFICATE_HASH_VALUE = 114;

var SSL3_HANDSHAKE_TYPE_HELLO_REQUEST = 0;
var SSL3_HANDSHAKE_TYPE_CLIENT_HELLO = 1;
var SSL3_HANDSHAKE_TYPE_SERVER_HELLO = 2;
var SSL3_HANDSHAKE_TYPE_HELLO_VERIFY_REQUEST = 3;
var SSL3_HANDSHAKE_TYPE_NEW_SESSION_TICKET = 4;
var SSL3_HANDSHAKE_TYPE_CERTIFICATE = 11;
var SSL3_HANDSHAKE_TYPE_SERVER_KEY_EXCHANGE = 12;
var SSL3_HANDSHAKE_TYPE_CERTIFICATE_REQUEST = 13;
var SSL3_HANDSHAKE_TYPE_SERVER_HELLO_DONE = 14;
var SSL3_HANDSHAKE_TYPE_CERTIFICATE_VERIFY = 15;
var SSL3_HANDSHAKE_TYPE_CLIENT_KEY_EXCHANGE = 16;
var SSL3_HANDSHAKE_TYPE_FINISHED = 20;
var SSL3_HANDSHAKE_TYPE_CERTIFICATE_URL = 21;
var SSL3_HANDSHAKE_TYPE_CERTIFICATE_STATUS = 22;
var SSL3_HANDSHAKE_TYPE_SUPPLEMENTAL_DATA = 23;

#Added by https://www.rfc-editor.org/rfc/rfc8446.html
var TLS13_HANDSHAKE_TYPE_END_OF_EARLY_DATA = 5;
var TLS13_HANDSHAKE_TYPE_ENCRYPTED_EXTENSIONS = 8;
var TLS13_HANDSHAKE_TYPE_KEY_UPDATE = 24;
var TLS13_HANDSHAKE_TYPE_MESSAGE_HASH = 254;

##
# Filters an array of ciphersuites by the provided TLS
# encapsulation version according to published standards.
#
# @param [encaps:int]    A NASL TLS encapsulation enumerated value (i.e. ENCAPS_TLSv1_3)
# @param [ciphers:array] An array of Tenable ciphersuite names as keys
#                        and byte descriptions of ciphersuites as values or just a
#                        list of Tenable ciphersuite names..
# @param [tls1_3:bool]   Indicates TLS 1.3 because encaps is insufficient.
# @return [list|array|NULL] Returns a list or array of ciphersuites that is valid for the encapsulation.
#                           On error returns NULL.
##
function get_valid_ciphers_for_encaps(encaps, ciphers, tls1_3)
{
  if(isnull(tls1_3))
    tls1_3 = FALSE;

  if(isnull(encaps))
  {
    ssl_dbg(lvl:1, src:FUNCTION_NAME, msg:"No Encaps provided.");
    return NULL;
  }

  if(empty_or_null(ciphers))
  {
    ssl_dbg(lvl:1, src:FUNCTION_NAME, msg:"No ciphers provided.");
    return NULL;
  }

  var filter_func;
  if(tls1_3 || encaps == ENCAPS_TLSv1_3 || encaps == COMPAT_ENCAPS_TLSv13)
  {
    filter_func = function() {return "TLS13" >< _FCT_ANON_ARGS[0];};
  }
  else
  {
    switch(encaps)
    {
      case ENCAPS_TLSv1_2:
      case COMPAT_ENCAPS_TLSv12:
        filter_func = function() {return "TLS13" >!< _FCT_ANON_ARGS[0] &&
                                         "SSL2" >!< _FCT_ANON_ARGS[0];};
        break;
      case ENCAPS_TLSv1_1:
      case COMPAT_ENCAPS_TLSv11:
      case ENCAPS_TLSv1:
      case ENCAPS_SSLv3:
        filter_func = function() {return "TLS1_" >< _FCT_ANON_ARGS[0] ||
                                         "SSL3" >< _FCT_ANON_ARGS[0];};
        break;
      case ENCAPS_SSLv2:
        filter_func = function() {return "SSL2" >< _FCT_ANON_ARGS[0];};
        break;
      default:
        ssl_dbg(lvl:1, src:FUNCTION_NAME, msg:"Unrecognized encaps provided: " + serialize(hexstr(encaps)));
        return NULL;
    }
  }

  if(typeof_ex(ciphers) == "list")
  {
    return collib::filter(ciphers, f:filter_func);
  }
  else if(typeof_ex(ciphers) == "array")
  {
    return collib::filter_array_by_key(ciphers, f:filter_func);
  }
  else
  {
    ssl_dbg(lvl:1, src:FUNCTION_NAME, msg:"Supplied ciphers are neither a list nor array.");
    return NULL;
  }
}

##
# Returns a cipherspec (byte string) representing
# all ciphers in the supplied list of cipher names.
#
# @param [ciphernames:list] A list of Tenable ciphersuite names.
# @return [bytes] Returns the corresponding cipherspec
##
function get_cipherspec_from_names(ciphernames)
{
  if(typeof_ex(ciphernames) != "list")
  {
    ssl_dbg(lvl:1, src:FUNCTION_NAME, msg:"Supplied ciphernames are not a list.");
    return '';
  }

  var cipherspec = '';
  foreach var cipher(ciphernames)
  {
    if(!isnull(ciphers[cipher]))
      cipherspec += ciphers[cipher];
  }
  return cipherspec;
}

##
# Gets a cipherspec from an array or list of ciphersuites that is valid
# for the provided TLS encapsulation version according to published standards.
#
# @param [encaps:int]    A NASL TLS encapsulation enumerated value (i.e. ENCAPS_TLSv1_3)
# @param [ciphers:array] An array of Tenable ciphersuite names as keys
#                        and byte descriptions of ciphersuites as values or just a
#                        list of Tenable ciphersuite names..
# @param [tls1_3:bool]   Indicates TLS 1.3 because encaps is insufficient.
# @return [bytes] Returns a cipherspec that is valid for the encapsulation
##
function get_valid_cipherspec_for_encaps(encaps, ciphers, tls1_3)
{
  var valid_names;
  var valid_ciphers = get_valid_ciphers_for_encaps(encaps:encaps, ciphers:ciphers, tls1_3:tls1_3);
  if(typeof_ex(valid_ciphers) == "array")
    return get_cipherspec_from_names(ciphernames:keys(valid_ciphers));

  return get_cipherspec_from_names(ciphernames:valid_ciphers);
}

##
# Returns a cipherspec matching that sent by OpenSSL 3.0 for the given encapsulation.
#
# @param [encaps:int]  A NASL TLS encapsulation enumerated value (i.e. ENCAPS_TLSv1_3)
# @return [bytes] Returns the cipherspec for the provided encapsulation that OpenSSL 3.0 would have sent.
##
function get_openssl_cipherspec(encaps)
{
  var openssl_ciphers = [
    "TLS13_AES_256_GCM_SHA384",
    "TLS13_CHACHA20_POLY1305_SHA256",
    "TLS13_AES_128_GCM_SHA256",
    "TLS12_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
    "TLS12_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
    "TLS12_DHE_RSA_WITH_AES_256_GCM_SHA384",
    "TLS12_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256",
    "TLS12_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256",
    "TLS12_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256",
    "TLS12_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
    "TLS12_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
    "TLS12_DHE_RSA_WITH_AES_128_GCM_SHA256",
    "TLS1_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384",
    "TLS1_ECDHE_RSA_WITH_AES_256_CBC_SHA384",
    "TLS1_DHE_RSA_WITH_AES_256_CBC_SHA256",
    "TLS1_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256",
    "TLS1_ECDHE_RSA_WITH_AES_128_CBC_SHA256",
    "TLS12_DHE_RSA_WITH_AES_128_GCM_SHA256",
    "TLS1_CK_ECDHE_ECDSA_WITH_AES_256_CBC_SHA",
    "TLS1_CK_ECDHE_RSA_WITH_AES_256_CBC_SHA",
    "TLS1_CK_DHE_RSA_WITH_AES_256_CBC_SHA",
    "TLS1_CK_ECDHE_ECDSA_WITH_AES_128_CBC_SHA",
    "TLS1_CK_ECDHE_RSA_WITH_AES_128_CBC_SHA",
    "TLS1_CK_DHE_RSA_WITH_AES_128_CBC_SHA",
    "TLS12_RSA_WITH_AES_256_GCM_SHA384",
    "TLS12_RSA_WITH_AES_128_GCM_SHA256",
    "TLS1_RSA_WITH_AES_256_CBC_SHA256",
    "TLS1_RSA_WITH_AES_128_CBC_SHA256",
    "TLS1_SRP_SHA_RSA_WITH_AES_256_CBC_SHA",
    "TLS1_SRP_SHA_WITH_AES_256_CBC_SHA",
    "TLS1_CK_RSA_WITH_AES_256_CBC_SHA",
    "TLS1_SRP_SHA_RSA_WITH_AES_128_CBC_SHA",
    "TLS1_SRP_SHA_WITH_AES_128_CBC_SHA",
    "TLS1_CK_RSA_WITH_AES_128_CBC_SHA"
  ];

  return get_valid_cipherspec_for_encaps(encaps:encaps, ciphers:openssl_ciphers);
}

##
# This function generates an SSL / TLS Client Hello message.
#
# @param [mlen:int] message length after this byte.
# @param [mtype:int] handshake message type.
# @param [version:int] client SSL version.
# @param [v2hello:bool] whether to use v2 client hello format.
# @param [cipherspec:bytes] which ciphers are supported.
# @param [cspeclen:int] cipher spec len.
# @param [sessionid:bytes] session ID (defaults to empty string or random bytes if sessionidlen is non-zero).
# @param [sessionidlen:int] session ID length.
# @param [challenge:bytes] random bytes of challenge data. Prior to TLS 1.3 has unix time prepended to it.
# @param [challengelen:int] length of challenge.
# @param [compmeths:bytes] sequence of compression methods supported by client.
# @param [compmethslen:int] length of compression methods.
# @param [extensions:bytes] sequence of TLS extension data.
# @param [extensionslen:int] length of the list of extensions (optional)
# @param [securerenegotiation:bool] Advertise secure renegotiation in initial handshake using empty ciphersuite method.
# @return [bytes] Returns a raw string representing the Client Hello message.
# @remark
# For specs, see:
#   - http://www.mozilla.org/projects/security/pki/nss/ssl/draft02.html (SSL v2)
#   - http://www.mozilla.org/projects/security/pki/nss/ssl/draft302.txt (SSL v3)
#   - http://www.ietf.org/rfc/rfc2246.txt (TLS v1.0)
##
function client_hello(mlen, mtype, version, v2hello, cipherspec, cspeclen,
                      sessionid, sessionidlen, challenge, challengelen,
                      compmeths, compmethslen, extensions, extensionslen,
                      securerenegotiation, maxver)
{
  local_var chello, chellolen, handshake, myhello;

  # Assign some defaults.
  if ( (mtype <= 0) || isnull(version) ) mtype = raw_string(0x01);  # set to hello packet by default
  if (isnull(version)) version = raw_string(0x03, 0x00);
  if (isnull(v2hello)) v2hello = TRUE;
  if (isnull(securerenegotiation)) securerenegotiation = FALSE;

  # Generate the hello.
  #
  # - SSLv2, whether it's explicitly SSLv2 or in v2 compatibility mode.
  if (version == raw_string(0x00, 0x02) || v2hello == TRUE) {
    # Assign other defaults.
    #
    # - ciphers.
    if (isnull(cipherspec)) {
      if ( (isnull(cspeclen)) || (cspeclen <= 0 ) )
        cipherspec =
          ciphers["SSL2_CK_RC2_128_CBC_EXPORT40_WITH_MD5"] +
          ciphers["SSL2_CK_RC4_128_EXPORT40_WITH_MD5"] +
          ciphers["SSL2_CK_RC4_128_WITH_MD5"] +
          ciphers["SSL2_CK_DES_192_EDE3_CBC_WITH_MD5"];
      else
        # nb: fill it with random bytes.
        while (strlen(cipherspec) < cspeclen)
          cipherspec = cipherspec + (rand() % 256);
    }
    if (isnull(cspeclen)) {
      cspeclen = strlen(cipherspec);
      cspeclen = raw_string(cspeclen / 256, cspeclen % 256);
    }
    # - session ID.
    if (isnull(sessionid)) {
      if (sessionidlen)
        # nb: fill it with random bytes.
        while (strlen(sessionid) < sessionidlen)
          sessionid = sessionid + (rand() % 256);
      else sessionid = "";
    }
    if (isnull(sessionidlen)) {
      sessionidlen = strlen(sessionid);
      sessionidlen = raw_string(sessionidlen / 256, sessionidlen % 256);
    }
    # - challenge.
    if (isnull(challenge)) challenge = rand_str(length:16);
    if (isnull(challengelen)) {
      challengelen = strlen(challenge);
      challengelen = raw_string(challengelen / 256, challengelen % 256);
    }

    # Assemble the message.
    # nb: 2 byte length code is used since we don't need any padding.
    handshake = mtype +
                version +
                cspeclen +
                sessionidlen +
                challengelen +
                cipherspec;
    if (sessionid) handshake = handshake + sessionid;
    handshake = handshake + challenge;
    if ( (mlen <= 0) || isnull(mlen) ) mlen = strlen(handshake);
    myhello = raw_string(0x80 | (mlen / 256), mlen % 256) + handshake;
  }
  # - SSLv3 to TLSv1.3
  else if (
    version == raw_string(0x03, 0x00) ||
    version == raw_string(0x03, 0x01) ||
    version == raw_string(0x03, 0x02) ||
    version == raw_string(0x03, 0x03)
  )
  {
    if (isnull(cipherspec))
    {
      if (isnull(cspeclen))
      {
        var encaps = ENCAPS_TLSv1_1;
        if(version == raw_string(0x03, 0x03))
          encaps = ENCAPS_TLSv1_2;

        cipherspec = get_valid_cipherspec_for_encaps(encaps:encaps, ciphers:ciphers);
      }
      else
      {
        # nb: fill it with random bytes.
        while (strlen(cipherspec) < cspeclen)
          cipherspec = cipherspec + (rand() % 256);
      }
    }
    if (isnull(cspeclen)) {
      cspeclen = strlen(cipherspec);
      cspeclen = raw_string(cspeclen / 256, cspeclen % 256);
    }
    if (securerenegotiation)
    {
      # This value isn't actually a cipher, instead it signals to
      # the server that the client supports secure renegotiation.
      cipherspec += raw_string(0x00, 0xff);
      cspeclen = strlen(cipherspec);
      cspeclen = raw_string(cspeclen / 256, cspeclen % 256);
    }
    # - session ID.
    if (isnull(sessionid)) {
      if (sessionidlen) {
        # nb: fill out field with random bytes.
        while (strlen(sessionid) < sessionidlen)
          sessionid = sessionid + (rand() % 256);
      }
      else sessionid = "";
    }
    if (isnull(sessionidlen)) sessionidlen = raw_string(strlen(sessionid));
    # - challenge.
    if (isnull(challenge)) challenge = dec2hex(num:unixtime()) + rand_str(length:28);
    # - compression methods
    if (isnull(compmeths)) {
      compmeths = raw_string(0x00);
      # nb: fill out field with random bytes.
      while (strlen(compmeths) < compmethslen)
        compmeths = compmeths + (rand() % 256);
    }
    if (isnull(compmethslen)) compmethslen = raw_string(strlen(compmeths));

    # Assemble the message.
    if(isnull(maxver))
      maxver = version;
    chello = maxver +
             challenge +
             sessionidlen + sessionid +
             cspeclen + cipherspec +
             compmethslen + compmeths;
    if (!isnull(extensions))
    {
      if (isnull(extensionslen))
        extensionslen = mkword(strlen(extensions));
      chello += extensionslen + extensions;
    }

    chellolen = strlen(chello);
    handshake = mtype +
              raw_string(0, chellolen / 256, chellolen % 256) +
              chello;
    if (isnull(mlen)) mlen = strlen(handshake);
    myhello = raw_string(0x16) +
              version +
              raw_string(mlen / 256, mlen % 256) +
              handshake;
  }

  return(myhello);
}

##
# Generates a string of random bytes.
#
# @param [length:int] Length of the string to generate.
#
# @return [bytes] Returns a string of random bytes of the length specified.
##
function random_bytes(length)
{
  local_var i, bytes;

  for (i=0; i < length; i++)
    bytes += raw_string(rand() % 256);

  return bytes;
}


##
# This function generates a TLS 1.3 Client Hello message.
#
# @param [supported_groups:bytes] A sequence of the named groups the client supports for key exchange.
# @param [public_keys:array] An array with key exchange groups as keys and associated public keys as values.
# @param [cipher_suites:bytes] A sequence of cipher suite codes.
# @param [signature_algorithms:list] A list of signature algorithms codes.
# @param [supported_protos:list] A list of supported SSL/TLS protocol codes.
# @param [optional_exts:bytes] TLS extensions data - optional.
# @param [challenge:bytes] 32 bytes of TLS 1.3 challenge data.
#
# @return [bytes] A TLS 1.3 Client Hello message.
##
function tls13_client_hello(supported_groups, public_keys, cipher_suites, signature_algorithms,
                            supported_protos, optional_exts, challenge)
{
  local_var private_key, tls13_supported_groups, tls13_cipher_suites, tls13_cipher_suites_len,
            tls13_signature_algorithms, tls13_protocol_version, tls13_client_version, tls13_client_random,
            tls13_session_id, tls13_compression_methods, tls13_compression_methods_len, tls13_extensions,
            tls13_extensions_len, chello, result;

  if(isnull(optional_exts))
    optional_exts = '';

  if(isnull(supported_protos))
    supported_protos = [];

  # default to only sending one pubkey for group 0x17 (secp256r1)
  # but say we support everything defined in rfc 8446
  if (isnull(public_keys)) {
    public_keys = {};

    private_key = "";
    private_key = random_bytes(length:32);

    if (ecc_functions_available())
    {
      result = ecc_scalar_multiply(
        curve_nid:curve_nid.tls[23], # secp256r1
        scalar:private_key
      );

      public_keys[0x17] = mkbyte(0x04) + result.x + result.y;
    }
    else
    {
      # just send random data if we can't calc an x point
      public_keys[0x17] = mkbyte(0x04) + random_bytes(length:64);
    }
  }

  if (isnull(supported_groups))
  {
    # from rfc8446
    # Elliptic Curve Groups (ECDHE)
    #   secp256r1(0x0017), secp384r1(0x0018), secp521r1(0x0019), x25519(0x001D), x448(0x001E),
    # Finite Field Groups (DHE)
    #   ffdhe2048(0x0100), ffdhe3072(0x0101), ffdhe4096(0x0102), ffdhe6144(0x0103), ffdhe8192(0x0104),
    tls13_supported_groups = make_list(0x0017, 0x0018, 0x0019, 0x001D, 0x001E, 0x0100, 0x0101, 0x0102, 0x0103, 0x0104);
  }
  else
  {
    tls13_supported_groups = supported_groups;
  }

  if (isnull(cipher_suites))
    tls13_cipher_suites = get_valid_cipherspec_for_encaps(encaps:ENCAPS_TLSv1_3, ciphers:ciphers, tls1_3:TRUE);
  else
    tls13_cipher_suites = cipher_suites;

  tls13_cipher_suites_len = mkword(strlen(tls13_cipher_suites));

  if (isnull(signature_algorithms))
  {
    # default as per rfc 8446
    tls13_signature_algorithms = make_list(
      0x0401, 0x0501, 0x0601,
      0x0403, 0x0503, 0x0603,
      0x0804, 0x0805, 0x0806,
      0x0807, 0x0808,
      0x0809, 0x080a, 0x080b,
      0x0201, 0x0203
    );
  }
  else
  {
    tls13_signature_algorithms = signature_algorithms;
  }

  # record header protocol version
  tls13_protocol_version = raw_string(3,1);

  # handshake
  tls13_client_version = raw_string(3,3);
  if(isnull(challenge))
    tls13_client_random = random_bytes(length:32);
  else
    tls13_client_random = challenge;

  tls13_compression_methods = mkbyte(0);
  tls13_compression_methods_len = mkbyte(1);
  tls13_extensions =
    tls_ext_sni(hostname:get_host_name()) +
    tls_ext_ec(tls13_supported_groups) +
    tls_ext_ec_pt_fmt() +
    tls_ext_alpn(supported_protos) +
    tls_ext_sig_algs(tls13_signature_algorithms) +
    tls_ext_key_share(public_keys:public_keys) +
    tls_ext_psk_key_exchange_modes() +
    tls_ext_sv_tls13() +
    optional_exts;
  tls13_extensions_len  = mkword(strlen(tls13_extensions));

  chello = client_hello(
    v2hello: FALSE,
    version: tls13_protocol_version,
    maxver: tls13_client_version,
    cipherspec: tls13_cipher_suites,
    cspeclen: tls13_cipher_suites_len,
    challenge: tls13_client_random,
    compmeths: tls13_compression_methods,
    compmethslen: tls13_compression_methods_len,
    extensions: tls13_extensions,
    extensionslen: tls13_extensions_len
  );

  return chello;
}

##
# Creates an SSLv3 Client Certificate handshake message.
#
# @param [contenttype:bytes] content type (1 byte) -- handshake is 0x16 - optional
# @param [version:bytes] version (2 bytes) -- SSL v3 is 0x03 0x00 - optional
# @param [length:bytes] length (2 bytes) of record following this length field - optional
# @param [hshaketype:bytes] handshake type (1 byte) -- certificate is 0x0B - optional
# @param [hlength:bytes] handshake length (3 bytes) (also equal to length - 4) - optional
# @param [clength:bytes] certificate length (3 bytes) (or hlength - 3) - optional
# @param [clength2:bytes] actual cert length (3 bytes) (just subtract another 3 from clength) - optional
# @param [certificate:bytes] clength2 bytes of certificate
#
# @return [bytes] Returns the SSLv3 Client Certificate handshake message.
##
function client_send_cert (contenttype, version, length, hshaketype, hlength, clength, clength2, certificate)
{
  local_var certlen, client_cert, tlen;

  if (!certificate) exit(0);                      # must have a cert...

  certlen = strlen(certificate);

  if (!contenttype) contenttype = raw_string(0x16);
  if (!version) version = raw_string(0x03, 0x00);
  if (!hshaketype) hshaketype = raw_string(0x0B);

  if (!clength2) {
    clength2 = certlen;
    if (clength2 <= 0xFF) clength2 = raw_string(0x00, 0x00, clength2);
    else clength2 = raw_string(0x00, clength2 / 256, clength2 % 256);
  }

  if (!clength) {
      tlen = certlen + 3;
      if (tlen <= 0xFF) clength = raw_string(0x00, 0x00, tlen);
      else clength = raw_string(0x00, tlen / 256, tlen % 256);
  }

  if (!hlength) {
      tlen = certlen + 6;
      if (certlen <= 0xFF) hlength = raw_string(0x00, 0x00, tlen);
      else hlength = raw_string(0x00, tlen / 256, tlen % 256);
  }

  if (!length) {
    length = certlen + 10;
    if (length <= 0xFF) length = raw_string(0x00, strlen(length));
    else length = raw_string(length / 256, length % 256);
  }

  client_cert = contenttype + version + length + hshaketype + hlength + clength + clength2 + certificate;
  return (client_cert);
}

##
# This function returns the message digest (fingerprint) of a string.
#
# @param [str:string]  The string to fingerprint.
# @param [type:string] Describes the type of message digest to use. Valid values "md5", "md2", "sha1", "sha256".
#
# @return [string] Returns a string of hex numbers, each separated by a colon, representing
#                  the string's fingerprint.
##
function fingerprint_string(str, type) {
  local_var digest;

  if (isnull(str)) return(NULL);
  if (isnull(type)) type = "md5";

  if (type =~ "md2") {
    digest = MD2(str);
  }
  else if (type =~ "md5") {
    digest = MD5(str);
  }
  else if (type =~ "sha1") {
    digest = SHA1(str);
  }
  else if (type =~ "sha256" && defined_func("SHA256")) {
    digest = SHA256(str);
  }
  else {
    # unsupported digest type.
    return(NULL);
  }

  digest = ereg_replace(string:hexstr(digest), pattern:"(..)", replace:"\1:");
  digest = substr(digest, 0, strlen(digest)-2);

  return(digest);
}

##
# This function returns the message digest (fingerprint) of an SSL
# certificate.
#
# @param [cert:bytes] The certificate (either PEM or DER-encoded).
# @param [type:string] Describes the type of message digest to use. Valid values "md5", "md2", "sha1", "sha256".
#
# @return [string] Returns a string of hex numbers, each separated by a colon, representing
#                  the certificate's fingerprint.
##
function fingerprint_cert(cert, type) {
  local_var der, line;;

  if (isnull(type)) type = "md5";

  # If the cert is PEM-encoded, convert it to DER-encoding.
  if (egrep(string:cert, pattern:"(BEGIN CERTIFICATE|^.{64}$)")) {
    der = "";
    foreach line (split(cert, keep:TRUE)) {
      if (line !~ "^-+(BEGIN|END) CERTIFICATE-+$") {
        der += line;
      }
    }
    cert = base64_decode(str:der);
  }

  return(fingerprint_string(str:cert, type:type));
}

##
# Talks to TLS 1.3 server and extracts decrypted handshake records
#
# @param [socket:object]       An already opened socket to TLS 1.3 server.
# @param [cipherspec:bytes]   Ciphersuite codes to offer. (optional)
# @param [optional_exts:bytes] Additional extension data to add to the client hello. (optional)
# @return [bytes|NULL] Returns all handshake records sent by the server or if an error occurs, NULL.
##
function get_tls13_handshake_recs(socket, cipherspec, optional_exts)
{
  var recs, curve, coordinate_length, record_header, authentication_tag;
  var encrypted_data, new_iv, decrypted_data, ext_len;

  var public_keys = {};

  var client_private_key = random_bytes(length:32);

  if (!ecc_functions_available())
  {
    ssl_dbg(src:FUNCTION_NAME, msg:'error: ECC functions not available, bailing!');
    return NULL;
  }

  # send valid secp384r1 and secp256r1 keys
  var result = ecc_scalar_multiply(
    curve_nid:curve_nid.tls[0x18], # secp384r1
    scalar:client_private_key
  );
  public_keys[0x18] = mkbyte(0x04) + result.x + result.y;

  result = ecc_scalar_multiply(
    curve_nid:curve_nid.tls[0x17], # secp256r1
    scalar:client_private_key
  );
  public_keys[0x17] = mkbyte(0x04) + result.x + result.y;

  var supported_groups = make_list(0x0018, 0x0017); # secp384r1, secp256r1

  if(isnull(cipherspec))
    cipherspec = ciphers["TLS13_AES_128_GCM_SHA256"];

  var chello = tls13_client_hello(public_keys:public_keys,
                                  supported_groups:supported_groups,
                                  cipher_suites:cipherspec,
                                  optional_exts:optional_exts);

  ssl_dbg(src:FUNCTION_NAME, msg:'sending tls13 client hello...');
  send(socket:socket, data:chello);

  var data = recv_ssl(socket:socket, hard_timeout:TRUE);

  ssl_dbg(src:FUNCTION_NAME, msg:'got back ' + hexstr(data));

  # Server hello or HelloRetryRequest
  var rec = ssl_find(
    blob:data,
    tls13:TRUE,
    'content_type', SSL3_CONTENT_TYPE_HANDSHAKE,
    'handshake_type', SSL3_HANDSHAKE_TYPE_SERVER_HELLO
  );
  # sanity check our server version is 3,3 and our extension supported version is TLS 1.3
  if ( isnull(rec) || rec['handshake_version'] != TLS_12 || rec['extension_supported_versions'][0] != TLS_13)
  {
    ssl_dbg(src:FUNCTION_NAME, msg:'error: did not receive TLS 1.3 server hello in return, bailing!');
    return NULL;
  }
  ssl_dbg(src:FUNCTION_NAME, msg:'got a TLS 1.3 server hello back');
  recs = substr(data, 5);

  var hello_hash_data = substr(chello, 5) + substr(data, 5);
  var hello_hash = SHA256(hello_hash_data);

  var server_public_key = {};
  if (rec['extension_key_share_group'] == 0x0018) # secp384r1
  {
    curve = curve_nid.tls[0x18];
    coordinate_length = 48;
  }
  else if (rec['extension_key_share_group'] == 0x0017) # secp256r1
  {
    curve = curve_nid.tls[0x17];
    coordinate_length = 32;
  }
  else
  {
    ssl_dbg(src:FUNCTION_NAME, msg:'error: server sent unsupported key share group ' + hexstr(rec['extension_key_share_group']));
    return NULL;
  }

  if(mkword(rec['cipher_spec']) == ciphers["TLS13_AES_128_GCM_SHA256"])
  {
    server_public_key.x = substr(rec['extension_key_share_key_exchange_data'], 1, coordinate_length);
    server_public_key.y = substr(rec['extension_key_share_key_exchange_data'], coordinate_length+1, coordinate_length+coordinate_length+1);

    ssl_dbg(src:FUNCTION_NAME, msg:'server public key x: ' + hexstr(server_public_key.x));
    ssl_dbg(src:FUNCTION_NAME, msg:'server public key y: ' + hexstr(server_public_key.y));

    result = ecc_scalar_multiply(
      curve_nid:curve,
      x:server_public_key.x,
      y:server_public_key.y,
      scalar:client_private_key
    );

    var shared_secret = result.x;

    ssl_dbg(src:FUNCTION_NAME, msg:'shared secret: ' + hexstr(shared_secret));
    var early_secret = hkdf_extract(key:hex2str('0000000000000000000000000000000000000000000000000000000000000000'));

    ssl_dbg(src:FUNCTION_NAME, msg:'early secret: ' + hexstr(early_secret));

    var empty_hash = SHA256('');

    ssl_dbg(src:FUNCTION_NAME, msg:'empty hash: ' + hexstr(empty_hash));

    var derived_secret = hkdf_expand_label(
      secret:early_secret,
      label:'derived',
      context:empty_hash,
      length:32
    );

    ssl_dbg(src:FUNCTION_NAME, msg:'derived secret: ' + hexstr(derived_secret));

    var handshake_secret = hkdf_extract(
      salt:derived_secret,
      key:shared_secret
    );

    ssl_dbg(src:FUNCTION_NAME, msg:'handshake secret: ' + hexstr(handshake_secret));

    var server_handshake_traffic_secret = hkdf_expand_label(
      secret:handshake_secret,
      label:'s hs traffic',
      context:hello_hash,
      length:32
    );

    ssl_dbg(src:FUNCTION_NAME, msg:'server handshake traffic secret: ' + hexstr(server_handshake_traffic_secret));

    var server_handshake_key = hkdf_expand_label(
      secret:server_handshake_traffic_secret,
      label:'key',
      context:'',
      length:16
    );

    ssl_dbg(src:FUNCTION_NAME, msg:'server handshake key: ' + hexstr(server_handshake_key));

    var server_handshake_iv = hkdf_expand_label(
      secret:server_handshake_traffic_secret,
      label:'iv',
      context:'',
      length:12
    );

    ssl_dbg(src:FUNCTION_NAME, msg:'server handshake iv: ' + hexstr(server_handshake_iv));

    # loop over application data blobs until we find the certificate info
    var record_number = 0;

    while (!isnull(data))
    {
      data = recv_ssl(socket:socket, hard_timeout:TRUE);
      if (isnull(data))
        break;

      ssl_dbg(src:FUNCTION_NAME, msg:'got back ' + hexstr(data));

      rec = ssl_find(
        blob:data,
        'content_type', SSL3_CONTENT_TYPE_APPLICATION_DATA
      );

      if (isnull(rec))
        continue;

      record_header = substr(data, 0, 4);
      ssl_dbg(src:FUNCTION_NAME, msg:'record header: ' + hexstr(record_header));

      authentication_tag = substr(rec['data'], strlen(rec['data']) - 16);

      ssl_dbg(src:FUNCTION_NAME, msg:'authentication tag: ' + hexstr(authentication_tag));

      encrypted_data = substr(rec['data'], 0, strlen(rec['data']) - 17);

      ssl_dbg(src:FUNCTION_NAME, msg:'encrypted data: ' + hexstr(encrypted_data));

      new_iv = server_handshake_iv;
      new_iv[11] = mkbyte(ord(server_handshake_iv[11]) ^ record_number);

      ssl_dbg(src:FUNCTION_NAME, msg:'old_iv is ' + hexstr(server_handshake_iv));
      ssl_dbg(src:FUNCTION_NAME, msg:'record_number is ' + record_number);
      ssl_dbg(src:FUNCTION_NAME, msg:'new_iv is ' + hexstr(new_iv));

      decrypted_data = crypto_decrypt(
        type:'aes_gcm',
        data:encrypted_data,
        key:server_handshake_key,
        iv:new_iv,
        options:{tag:authentication_tag, aad:record_header}
      );
      record_number += 1;
      if(!empty_or_null(decrypted_data))
      {
        ext_len = 4 + getword(blob:decrypted_data, pos:2);
        if(strlen(decrypted_data) >= ext_len)
          recs += substr(decrypted_data, 0, ext_len - 1);
      }
    }
  }
  else
  {
    record_header = substr(data, 0, 4);
    ssl_dbg(src:FUNCTION_NAME, msg:'record header: ' + hexstr(record_header));
  }

  recs = mkbyte(SSL3_CONTENT_TYPE_HANDSHAKE) + substr(record_header,1,2) + mkword(strlen(recs)) + recs;
  return recs;
}

##
# talks to TLS 1.3 server and extracts certificates
#
# @param [socket:object]    required already opened socket to TLS 1.3 server
# @param [encoding:string]  format of certificate, either pem (default) or der
# @param [sort:boolean]     if the cert chain should be sorted
# @param [getchain:boolean] if TRUE, return whole chain, otherwise just return primary cert
# @param [port:integer]     remote port supplying the certificates
#
# @remark
#   Internal library function, you probably want to just call get_server_cert() instead
#
# @return [list] list of certificates
##
function __tls13_get_server_cert(socket, encoding, sort, getchain, port)
{
  var rec, recs, cert, i;
  var fn = '__tls13_get_server_cert';

  ssl_dbg(src:fn, msg:'entering function');
  # at this point socket is a valid newly opened socket
  # and encoding, sort, and getchain were already validated by get_server_cert()

  recs = get_tls13_handshake_recs(socket:socket);
  rec = ssl_find(
    blob:recs,
    'content_type', SSL3_CONTENT_TYPE_HANDSHAKE,
    'handshake_type', SSL3_HANDSHAKE_TYPE_CERTIFICATE,
    tls13:TRUE
  );

  cert = rec['certificates'];

  if (isnull(cert))
  {
    ssl_dbg(src:fn, msg:"Couldn't extract certificates.");
    return NULL;
  }

  for ( i = 0 ; i < max_index(cert); i ++ )
  {
    cert[i] = blob_to_pem(cert[i]);
    ssl_dbg(src:fn, msg:"Successfully retrieved certificates on port "+port+", setting them in the KB.");
    if ( i == 0 ) replace_kb_item(name:"SSL/Certificate/" + port, value:cert[i]);
    else replace_kb_item(name:"SSL/Certificate/" + port + "/" + i, value:cert[i]);
  }

  if (encoding =~ "der") {
    local_var der, line;
    for ( i = 0 ; i < max_index(cert) ; i ++ )
    {
      cert[i] = pem_to_blob(cert[i]);
    }
  }
  else if (encoding !~ "pem") {
    # unsupported encoding.
    ssl_dbg(src:fn, msg:'Unsupported encoding "'+encoding+'".');
    return(NULL);
  }

  if ( sort ) cert = sort_cert_chain(cert);

  if ( getchain == TRUE )
  {
   if ( max_index(cert) == 0 )
   {
     ssl_dbg(src:fn, msg:'No certificates to return.');
     return NULL;
   }
   ssl_dbg(src:fn, msg:'Returning certificate chain.');
   return cert;
  }
  else
  {
    if(isnull(cert[0])) ssl_dbg(src:fn, msg:'No certificate to return.');
    else ssl_dbg(src:fn, msg:'Returning certificate.');
    return cert[0];
  }
}

##
# Sends a TLS ClientHello to the server and returns the server response.
#
# @param [port:int] The port the service is listening on.
# @param [soc:int] An already open socket (optional).
# @param [encaps:int] The type of encapsulation to use.
# @param [cipherspec:bytes] Ciphersuite codes to offer.
# @param [exts:bytes] TLS extension codes and parameters.
# @param [cmps:bytes] Byte string of TLS compression methods.
# @param [securerenegotiation:bool] Advertise secure renegotiation using empty ciphersuite method.
# @param [test_mode:bool] Boolean tells function not to open sockets during test execution.
#
# @return [bytes|NULL] Returns all server messages in response to the ClientHello, or NULL on error.
##
function get_tls_server_response(port, soc, encaps, cipherspec, exts, cmps, securerenegotiation, test_mode)
{
  var buf, hello, socket, ssl_ver;
  var fn = "get_tls_server_response";

  if(!soc)
  {
    if(!test_mode)
    {
      socket = open_sock_ssl(port);

      if (!socket)
      {
        ssl_dbg(lvl:1, src:fn, msg:'Failed to open socket on port ' + port + '.');
        return NULL;
      }

      ssl_dbg(lvl:2, src:fn, msg:'Opened socket ' + socket + ' on port ' + port + '.');
    }
  }
  else
  {
    socket = soc;
  }

  var retry = FALSE;

  do
  {
    #Retry for servers sensitive to long cipherspec offerings
    if(retry)
      cipherspec = get_openssl_cipherspec(encaps:encaps);

    if(isnull(cipherspec))
      cipherspec = get_valid_cipherspec_for_encaps(encaps:encaps, ciphers:ciphers);

    # Send client hello.
    if (encaps == ENCAPS_SSLv2) {
      ssl_dbg(lvl:2, src:fn, msg:'Trying SSLv2 ClientHello.');
      hello = client_hello(version:raw_string(0x00, 0x02));
    }
    # TLS 1.3 is special
    else if (encaps == COMPAT_ENCAPS_TLSv13) {
      ssl_dbg(lvl:2, src:fn, msg:'Trying TLS 1.3 handshake.');
      return get_tls13_handshake_recs(socket:socket, cipherspec:cipherspec, optional_exts:exts);
    }
    else
    {
      ssl_dbg(lvl:2, src:fn, msg:'Trying SSL ClientHello with encapsulation = ' + serialize(encaps) + '.');
      if (encaps == ENCAPS_SSLv3) ssl_ver = raw_string(0x03, 0x00);
      else if (encaps == ENCAPS_TLSv1) ssl_ver = raw_string(0x03, 0x01);
      else if (encaps == COMPAT_ENCAPS_TLSv11) ssl_ver = raw_string(0x03, 0x02);
      else if (encaps == COMPAT_ENCAPS_TLSv12) ssl_ver = raw_string(0x03, 0x03);

      hello = client_hello(v2hello:FALSE,
                           version:ssl_ver,
                           extensions:exts,
                           compmeths:cmps,
                           cipherspec:cipherspec,
                           securerenegotiation:securerenegotiation);
    }

    ssl_dbg(src:fn, msg:'Sending client hello and receiving response.');
    if(!test_mode)
      send(socket:socket, data:hello);

    buf = recv_ssl_recs(socket:socket, timeout:20);

    if(empty_or_null(buf) && !retry)
      retry = TRUE;
    else
      retry = FALSE;

  } while(retry)

  if(!soc && !test_mode && socket)
  {
    ssl_dbg(src:fn, msg:'Closing socket ' + socket + '.');
    close(socket);
  }

  return buf;
}


##
# Performs DTLS ClientHello handshake and returns the server response.
#
# @param [port:int] The port the service is listening on.
# @param [soc:int]  An already open socket (optional).
# @param [encaps:int] The type of encapsulation to use.
# @param [cipherspec:bytes] Ciphersuite codes to offer.
# @param [exts:bytes] TLS extension codes and parameters.
# @param [cmps:bytes] TLS compression methods.
# @param [securerenegotiation:bool] Advertise secure renegotiation using empty ciphersuite method.
# @param [test_mode:bool] Tells function not to open sockets during test execution.
#
# @return [bytes|NULL] Returns server response to the ClientHello, or NULL on error.
##
function get_dtls_server_response(port, soc, encaps, cipherspec, exts, cmps, securerenegotiation, test_mode)
{
  var fn = "get_dtls_server_response";
  var socket;

  if(!soc)
  {
    if(!test_mode)
    {
      soc = open_sock_udp(port);

      if (!soc)
      {
        ssl_dbg(src:fn, msg:'Failed to open socket on port ' + port + '.');
        return NULL;
      }

      ssl_dbg(src:fn, msg:'Opened socket ' + soc + ' on port ' + port + '.');
    }
  }
  else
  {
    socket = soc;
  }

  var ver;
  if(encaps == COMPAT_ENCAPS_TLSv11)
  {
    ver = DTLS_10;
    if(isnull(cipherspec))
      cipherspec = dtls10_ciphers;
  }
  else if(encaps == COMPAT_ENCAPS_TLSv12)
  {
    ver = DTLS_12;
    if(isnull(cipherspec))
      cipherspec = dtls12_ciphers;
  }
  else
  {
    ssl_dbg(src:fn, msg: "Attempt to use DTLS with an unsupported encapsulation (" + encaps + ") on port " + port + ".");
    return NULL;
  }

  var dtls = new("dtls", soc, port);

  dtls.set_version(ver);

  var res = dtls.init(suites:cipherspec, exts:exts, compmeths:cmps, securerenegotiation:securerenegotiation);
  if(!res)
  {
    ssl_dbg(src:fn, msg:"Failed to initialize DTLS.");
    return NULL;
  }

  var hfrags = [];
  var clt_random = dec2hex(num:unixtime()) + rand_str(length:28);

  return dtls.do_client_hello(hfrags:hfrags, clt_random:clt_random);
}

##
# Determine whether or not to add an ECC extension to the ClientHello message
#
# @param [cipher_set:array] The array of ciphers to encode in the ClientHello
# @param [encaps:string]    The protocol being tested
# @return [boolean] TRUE if an extension should be added, FALSE otherwise
##
function is_ec_extension_required(cipher_set, encaps)
{
  var cipher;

  # We can only include extensions if this is TLSv1 or greater
  if (encaps >= ENCAPS_TLSv1)
  {
    foreach cipher (keys(cipher_set))
    {
      # Some SSL implementations require a supported named curve for it
      # to return a ServerHello, so we will send EC extensions, claiming
      # to support all curves and EC point formats.
      if(!isnull(cipher_set[cipher]) && tls_is_ec_cipher(cipher))
        return TRUE;
    }
  }

  return FALSE;
}


##
# This function retrieves the server certificate from the SSL-enabled
# service on a given port.
#
# @param [port:int] a port number.
# @param [encoding:string] format of certificate, either PEM (default) or DER.
# @param [socket:int] an already open socket (optional).
# @param [encaps:int] the type of encapsulation to use (optional).
# @param [dtls:bool] indicates whether to look for a DTLS server cert.
# @param [sort:bool] indicate whether the cert chain should be reordered.
# @param [securerenegotiation:bool] Advertise secure renegotiation in initial
#   handshake using empty ciphersuite method. SSLv3 and up.
# @param [sni:bool] Enable(default)/Disable TLS SNI extension. TLSv1.0/v1.1/v1.2
# @param [testing_mode:bool] TRUE if we are running flatlines or unit tests
#
# @return [bytes|NULL] Returns the server's SSL certificate.  Returns NULL if an error occurs.
##
function get_server_cert(port, encoding, socket, encaps, dtls, getchain, sort, securerenegotiation, sni, testing_mode)
{
  local_var buf, hello, done, hexmsg, host, soc, ssl;
  local_var extensions, servername;
  local_var msg, msg_len, msg_type;
  local_var hand, hand_len, hand_type;
  local_var cert, cert_len, cipherspec;
  local_var alert_desc, alert_lvl, err_code;
  local_var i, n;
  local_var idx;
  local_var kb, sni_kb, list, ret;
  local_var fn = "get_server_cert";

  if (isnull(port)) return(NULL);
  if (isnull(encoding)) encoding = "pem";
  if (isnull(sort)) sort = TRUE;
  if (isnull(securerenegotiation)) securerenegotiation = FALSE;
  if (isnull(sni)) sni = TRUE;
  if (isnull(dtls)) dtls = FALSE;
  if (isnull(testing_mode)) testing_mode = FALSE;

  cert = make_list();
  n = 0;

  if (get_kb_item("SSL/NO_SNI/" + port))
  {
    sni = FALSE;
  }

  host = get_host_name();

  if (sni && host == get_host_ip())
  {
    sni = FALSE;
    replace_kb_item(name:"SSL/NO_SNI/" + port, value:TRUE);
    set_kb_item(name:"SSL/NO_SNI/" + port + "/reason", value:"hostname-is-ip-address");
  }

  if (sni)
  {
    sni_kb = "SNI/";
  }
  else
  {
    sni_kb = "";
  }

  # Try to get cert from the KB.
  cert[0] = get_kb_item("SSL/Certificate/" + sni_kb + port);
  if ( !isnull(cert[0]) )
  {
   ssl_dbg(lvl:2, src:fn, msg:'Retrieving certificate chain for port '+port+
      ' from KB.');
   for ( i = 1;  TRUE ; i ++ )
    {
     kb = get_kb_item("SSL/Certificate/" + sni_kb + port + "/" + i);
     if ( isnull(kb) ) break;
     cert[i] = kb;
    }
  }
  # If that didn't work, retrieve it directly.
  else {
    ssl_dbg(lvl:2, src:fn, msg:'Retrieving certificate chain from target '+
      'on port '+port+'.');
    if ((!dtls && !get_port_state(port)) || (dtls && !get_udp_port_state(port)))
    {
      ssl_dbg(lvl:1, src:fn, msg:'Port '+port+' is closed.');
      return(NULL);
    }

    if (!isnull(socket))
    {
      ssl_dbg(lvl:2, src:fn, msg:'Using socket '+socket+' passed as argument.');
      soc = socket;
    }
    else
    {
      soc = NULL;
    }

    if (isnull(encaps))
    {
      if (dtls)
        encaps = get_one_kb_item("Transports/UDP/" + port);
      else
        encaps = get_one_kb_item("Transports/TCP/" + port);
    }

    if (isnull(encaps) || encaps == ENCAPS_IP)
    {
      if (dtls)
        encaps = get_one_kb_item("DTLS/Transport" + port);
      else
        encaps = get_one_kb_item("SSL/Transport/" + port);

      if (isnull(encaps) || encaps == ENCAPS_IP)
      {
        ssl_dbg(lvl:1, src:fn, msg:'No SSL transport found in KB for port '+
          port+'.');
        return (NULL);
      }
    }

    # nb: see nessus-libraries/include/libnessus.h for defines
    #     mapping encapsulations to SSL / TLS version.
    if (encaps == ENCAPS_SSLv2) ssl = "SSLv2";
    else if (encaps == ENCAPS_SSLv3 || encaps == ENCAPS_SSLv23) ssl = "SSLv3";
    else if (encaps == ENCAPS_TLSv1) ssl = "TLSv1";
    else if (encaps == COMPAT_ENCAPS_TLSv11) ssl = "TLSv11";
    else if (encaps == COMPAT_ENCAPS_TLSv12) ssl = "TLSv12";
    else if (encaps == COMPAT_ENCAPS_TLSv13) ssl = "TLSv13";
    else return(NULL);

    if (isnull(soc))
    {
      soc = open_sock_ssl(port);
      if (!soc)
      {
        ssl_dbg(lvl:1, src:fn, msg:'Failed to open socket on port '+port+'.');
        return(NULL);
      }
    }

    # TLS 1.3 is special
    if (ssl == "TLSv13")
    {
      ssl_dbg(lvl:2, src:fn, msg:'Retrieving server cert using TLS 1.3.');
      return __tls13_get_server_cert(socket:soc, encoding:encoding, sort:sort, getchain:getchain, port:port);
    }

    if (sni && (ssl == "SSLv2" || ssl == "SSLv3"))
    {
      sni = FALSE;
      replace_kb_item(name:"SSL/NO_SNI/" + port, value:TRUE);
      set_kb_item(name:"SSL/NO_SNI/" + port + "/reason", value:"sslv3-or-v3");
    }

    #No extensions for SSLv3 or SSLv2
    if (encaps >= ENCAPS_TLSv1)
      extensions = tls_ext_ec() + tls_ext_ec_pt_fmt();

    if (sni)
      extensions += tls_ext_sni(hostname:host);

    if(encaps == COMPAT_ENCAPS_TLSv12)
      extensions += tls_ext_sig_algs();

    ssl_dbg(lvl:2, src:fn, msg:'Retrieving server cert ...');

    if (dtls)
    {
      buf = get_dtls_server_response(soc:soc, port:port, exts:extensions, encaps:encaps,
                                     securerenegotiation:securerenegotiation, test_mode:testing_mode);
    }
    else
    {
      var certciphers = get_valid_ciphers_for_encaps(encaps:encaps, ciphers:keys(ciphers));
      certciphers = collib::filter(certciphers, f:function(){return "DH_anon" >!< _FCT_ANON_ARGS[0];});
      cipherspec = get_cipherspec_from_names(ciphernames:certciphers);

      buf = get_tls_server_response(soc:soc, port:port, exts:extensions, encaps:encaps, cipherspec:cipherspec,
                                    securerenegotiation:securerenegotiation, test_mode:testing_mode);
    }

    if(empty_or_null(buf))
      ssl_dbg(lvl:1, src:fn, msg:'Failed to receive a server response.');

    # Process server message(s).
    done = 0;
    if (ssl == 'SSLv2') {
      # Isolate a message.
      while (!done && strlen(buf) > 3) {
        msg_type = ord(buf[2]);
        msg_len = ((ord(buf[0]) & 0x7f) << 8) | ord(buf[1]);
        msg = substr(buf, 0, msg_len+2-1);
        buf = substr(buf, msg_len);

        # Handshake message.
        if (msg_type == 4 && strlen(msg) > 14) {
          # X.509 certificate.
          if (ord(msg[4]) == 1) {
            cert_len = ord(msg[7])*256 + ord(msg[8]);
            cert[0] = substr(msg, 13, cert_len+13-1);
            done = 1;
            ssl_dbg(src:fn, msg:'SSLv2: Received X.509 certificate.');
          }
        }
        # Error message.
        else if (msg_type == 0 && strlen(msg) == 2) {
          err_code = ord(msg[0]) * 256 + ord(msg[1]);
          ssl_dbg(src:fn, msg:'SSLv2: Received error code: '+err_code);
        }
        # Something else.
        else {
          ssl_dbg(src:fn, msg:"SSLv2: Message of type "+msg_type+
            " received from "+host+":"+port+"!");
        }
      }
    }
    else if (ssl == 'SSLv3' || ssl == 'TLSv1' || ssl == 'TLSv11' || ssl == 'TLSv12') {
      ret = ssl_find(
          blob:buf,
          'content_type', SSL3_CONTENT_TYPE_HANDSHAKE,
          'handshake_type', SSL3_HANDSHAKE_TYPE_CERTIFICATE
      );
      if (!isnull(ret) && max_index(ret['certificates']) > 0)
      {
        cert = ret['certificates'];
      }

      if(!empty_or_null(cert))
      {
        done = TRUE;
      }
      else
      {
        ret = ssl_find( blob:buf, "content_type", SSL3_CONTENT_TYPE_ALERT);
        if(!isnull(ret))
        {
          if(sni && ret['level'] == SSL3_ALERT_TYPE_FATAL &&
             ret['description'] == SSL3_ALERT_TYPE_UNRECOGNIZED_NAME)
          {
            # Try again without SNI
            ssl_dbg(src:fn, msg:'Received alert for unrecognized name,'+
              'retrying without SNI.');
            replace_kb_item(name:"SSL/NO_SNI/" + port, value:TRUE);
            set_kb_item(name:"SSL/NO_SNI/" + port + "/reason", value:"name(" + host + ") returned fatal unrecognized-name");
            return get_server_cert(port:port,
                                   encoding:encoding,
                                   socket:socket,
                                   encaps:encaps,
                                   getchain:getchain,
                                   sort:sort,
                                   securerenegotiation:securerenegotiation,
                                   sni:FALSE,
                                   dtls:dtls,
                                   testing_mode:testing_mode);
          }
          else if(ret['level'] == SSL3_ALERT_TYPE_FATAL)
          {
            ssl_dbg(src:fn, msg:'Received fatal alert, type code: ' + ret['description']+ '.');
          }
        }
      }
    }

    if (done) {
      for ( i = 0 ; i < max_index(cert); i ++ )
      {
        cert[i] = blob_to_pem(cert[i]);

        ssl_dbg(src:fn, msg:"Successfully retrieved certificates "+
          "on port "+port+", setting them in the KB.");
        if ( i == 0 ) replace_kb_item(name:"SSL/Certificate/" + sni_kb + port, value:cert[i]);
        else replace_kb_item(name:"SSL/Certificate/" + sni_kb + port + "/" + i, value:cert[i]);
      }
    }
    else {
      # The port was open but we couldn't get the certificate for some reason
      # so let the user know if we're verbosely logging.
      ssl_dbg(src:fn, msg:"Can't get SSL certificate on "+host+":"+ port+"!");

      return NULL;
    }
  }

  if (encoding =~ "der") {
    local_var der, line;
    for ( i = 0 ; i < max_index(cert) ; i ++ )
    {
      cert[i] = pem_to_blob(cert[i]);
    }
  }
  else if (encoding !~ "pem") {
    # unsupported encoding.
    ssl_dbg(src:fn, msg:'Unsupported encoding "'+encoding+'".');
    return(NULL);
  }

  if ( sort ) cert = sort_cert_chain(cert);

  if ( getchain == TRUE )
  {
   if ( max_index(cert) == 0 )
   {
     ssl_dbg(src:fn, msg:'No certificates to return.');
     return NULL;
   }
   ssl_dbg(src:fn, msg:'Returning certificate chain.');
   return cert;
  }
  else
  {
    if(isnull(cert[0])) ssl_dbg(src:fn, msg:'No certificate to return.');
    else ssl_dbg(src:fn, msg:'Returning certificate.');
    return cert[0];
  }
}

##
# Receives SSL packet(s)
#
# @param [socket:object] Socket used by send() or similiar function
# @param [partial:boolean] If true return first packet received
# @param [timeout:integer] Soft timeout in seconds
# @param [hard_timeout:boolean] If true use recv_ex() to enforce hard timeout
#
# @remark
#   The 'hard_timeout' parameter was introduced to handle services that continually
#   send small amounts of data under the timeout period resulting in performance degradation.
#
# @return [bytes|NULL] SSL/TLS packet or NULL if error or no packets were received.
##
function recv_ssl(socket, partial, timeout, hard_timeout)
{
  local_var b1, b2, l, r1, r2;

  var err = socket_get_error(socket);
  if (isnull(err)) return NULL;
  if (err != NOERR && err != ETIMEDOUT) return NULL;

  r1 = recv(socket:socket, length:5, min:5, timeout:timeout);
  if (strlen(r1) != 5) return NULL;

  b1 = ord(r1[1]);
  b2 = ord(r1[2]);
  if (b1 == 3 && b2 >= 0 && b2 <= 3)                        # SSL3 to TLS1.2
    l = ord(r1[3])*256 + ord(r1[4]);
  else                                                      # SSL2
  {
    # 2-byte record header
    if(ord(r1[0]) & 0x80)
    {
      l = ((ord(r1[0]) & 0x7f) << 8) | ord(r1[1]);
      l -= 3;
    }
    # 3-byte record header
    else
    {
      l = ((ord(r1[0]) & 0x3f) << 8) | ord(r1[1]);
      l -= 2; # account for 1-byte padlen
    }
  }
  if (l > 0)
  {
    if (hard_timeout && defined_func("recv_ex"))
    {
      if (!timeout) timeout = get_read_timeout();
      r2 = recv_ex(socket:socket, length:l, min:l, timeout_sec:timeout);
    }
    else
    {
      r2 = recv(socket:socket, length:l, min:l, timeout:timeout);
    }

    if (partial || strlen(r2) == l) return r1+r2;
  }

  return NULL;
}

##
# Collects all trusted CAs from the scan environment.  Sources include known_CA.inc, custom_CA.inc files,
# and the "Trusted CAs" advanced scan setting.
#
# @return [list|NULL]  Returns a nested list [parsed certs, raw certs, whitelisted]. Returns NULL on error.
# @remark
# The sublists returned by this function are as follows:
#   parsed certs: Each element is an array of parsed certificate data - see x509_func.static
#   raw certs: Each element is the raw byte sequence of the certificate.
#   whitelisted: Each element is a bool indicating whether the certificate is whitelisted
##
function load_CA()
{
  local_var data, data_custom, data_input;
  local_var r, ret, raw, whitelist;
  local_var ca_list, ca_file;
  local_var system_CAs, custom_CAs, input_CAs;

  data = data_custom = data_input = '';
  r = ret = raw = whitelist = make_list();

  # Check if we already have CAs stored in a Global Var
  if (defined_func("get_global_var"))
  {
    mutex_lock("ssl_func.inc:load_CA");
    ret = get_global_var("CA");

    # If we already have valid results, return them!
    if (!isnull(ret))
    {
      mutex_unlock("ssl_func.inc:load_CA");
      return ret;
    }
    # Else, continue as normal, and we'll set the value at the end!
  }

  # Read in data from listed CA files
  ca_list = get_kb_list("SSL/CA_list");

  foreach ca_file (ca_list)
  {
    if ('custom_CA' >< ca_file)
    {
      if (file_stat(ca_file) > 0) data_custom += fread(ca_file);
    }
    else
    {
      if (file_stat(ca_file) > 0) data += fread(ca_file);
    }
  }

  # Read in data from the UI input
  data_input = get_kb_item("SSL/CA_input");

  # If we didn't find any data, go ahead and exit early
  if ((strlen(data) + strlen(data_custom) + strlen(data_input)) <= 0)
  {
    # If using get_global_var, make sure to unlock the mutex before returning!
    if (defined_func("get_global_var")) mutex_unlock("ssl_func.inc:load_CA");

    return NULL;
  }

  system_CAs = parse_certs(data:data);
  custom_CAs = parse_certs(data:data_custom, is_custom:TRUE);
  input_CAs = parse_certs(data:data_input, is_custom:TRUE);

  # Combine the results!
  ret = make_list(system_CAs[0], custom_CAs[0], input_CAs[0]);
  raw = make_list(system_CAs[1], custom_CAs[1], input_CAs[1]);
  whitelist = make_list(system_CAs[2], custom_CAs[2], input_CAs[2]);

  r[0] = ret;
  r[1] = raw;
  r[2] = whitelist;

  # If get_global_var didn't have a valid value, let's set it!
  if (defined_func("get_global_var"))
  {
    # But only if we actually have something
    if (!isnull(r)) set_global_var(name:"CA", value:r);

    mutex_unlock("ssl_func.inc:load_CA");
  }

  return r;
}

##
# Parse out valid PEM certs from the string of data provided
#
# @param [data:bytes] The String to look for certs in
# @param [is_custom:bool] Indicates whether we're looking for custom/user defined certs
#
# @return [list|NULL]  Returns a nested list [parsed certs, raw certs, whitelisted, n]. Returns NULL on error.
# @remark
# The sublists returned by this function are as follows:
#   parsed certs: Each element is an array of parsed certificate data - see x509_func.static
#   raw certs: Each element is the raw byte sequence of the certificate.
#   whitelisted: Each element is a bool indicating whether the certificate is whitelisted
#   n: Index of the associated certificate.
##
function parse_certs(data, is_custom)
{
  local_var line, der;
  local_var n;
  local_var inCert, whitelist_current;
  local_var ret, raw, whitelist, results, match;

  ret = raw = whitelist = results = make_list();

  whitelist_current = FALSE;
  inCert = FALSE;
  der = '';
  n = 0;

  foreach line (split(data, keep:FALSE))
  {
    if (is_custom && "#whitelist#" >< line)
    {
      whitelist_current = TRUE;
    }
    else if (line =~ "^-+BEGIN CERTIFICATE-+$")
    {
      inCert = TRUE;
      der = '';
    }
    else if (line =~ "^-+END CERTIFICATE-+$")
    {
      if (!empty_or_null(der)) # Only process and add the cert if we actually have data
      {
        raw[n] = base64_decode(str:der);
        ret[n] = parse_der_cert(cert:raw[n], customCA:is_custom);
        whitelist[n] = whitelist_current;
        n++;
      }
      der = '';
      inCert = FALSE;
      whitelist_current = FALSE;
    }
    else if (inCert)
    {
      match = pregmatch(pattern:'^[A-Za-z0-9+/=]+$', string:line);

      if (!isnull(match) && !isnull(match[0]))
      {
        der += line;
      }
      else # If we found invalid body data, the whole cert is bad. So scrap it!
      {
        der = '';
        inCert = FALSE;
      }
    }
  }

  results[0] = ret;
  results[1] = raw;
  results[2] = whitelist;
  results[3] = n;

  return results;
}

##
# Encode variable-length data for inclusion in SSL records.
#
# @param [data:bytes] The data to be stored in the record.
# @param [len:int] The number of bytes required to store the maximum length
#            of the data for the record's field, two by default.
#
# @remark
#   Works for SSL version 3.0 and later, but probably not for
#   version 2.0.
#
# @remark
#   Can only handle fields up to 4 bytes, currently. Since NASL
#   has no unsigned types, [strlen] can't return a full 4 byte
#   length.
#
# @return [bytes] The data prepended with the length.
##
function ssl_vldata_put(data, len)
{
  local_var dlen, i, n;

  # Sanity check parameters.
  if (isnull(len))
    return NULL;
  if (len > 4)
    return NULL;

  # Get the length of the data.
  dlen = strlen(data);
  if (
    (len == 1 && dlen > 0x000000FF) ||
    (len == 2 && dlen > 0x0000FFFF) ||
    (len == 3 && dlen > 0x00FFFFFF)
  ) return NULL;

  # Encode the data length, padded as necessary.
  n = "";
  for (i = len - 1; i >= 0; i--)
    n += mkbyte((dlen >> (i * 8)) & 0xff);

  return n + data;
}

##
# Extract variable-length data from SSL records.
#
# @param [blob:bytes] Data blob in which the data resides.
# @param [len:int] The number of bytes required to store the maximum length
#            of the data for the record's field, two by default.
# @param [pos:int] Position where the data starts, zero by default.
#
# @remark
#   Works for SSL version 3.0 and later, but probably not for
#   version 2.0.
#
# @remark
#   Can only handle fields up to 4 bytes, currently. Since NASL
#   has no unsigned types, [strlen] can't return a full 4 byte
#   length.
#
# @return [array] An array containing the data and number of bytes consumed.
# @remark
# The returned array looks like:
# ```
# {
#   "data": <bytes>,
#   "len": <length
# }
# ```
##
function ssl_vldata_get(blob, len, pos)
{
  local_var i, n;

  # Sanity check parameters.
  if (isnull(blob) || isnull(len))
    return NULL;
  if (len > 4)
    return NULL;

  # Set defaults.
  if (isnull(len))
    len = 2;
  if (isnull(pos))
    pos = 0;

  # prevent errors in nessusd.dump for out of range index
  if((len + pos) > strlen(blob))
    return NULL;

  # Extract the data length.
  n = 0;
  for (i = len - 1; i >= 0; i--)
    n += ord(blob[pos++]) << (i * 8);

  # Check that the length won't run past the end of the blob.
  if (pos + n > strlen(blob))
    return NULL;

  return make_array(
    "data", substr(blob, pos, pos + n - 1),
    "len", len + n
  );
}

##
# Parse SSL/TLS handshake extensions records
#
# @param [blob:bytes]               A stream of records
# @param [offset:int]               Byte offset at which to begin parsing
# @param [tls13_random_offset:int]  Offset to TLS 1.3 ServerHello random bytes - optional
# @param [rec:array]                Reference to partial record parsing result
#
# @return [int:NULL] Returns an updated parsing offset to the caller,
#                    or NULL if there is an error.
##
function parse_tls_extensions(blob, offset, tls13_random_offset, &rec)
{
  var id, len, end, length, subend, num;

  if(empty_or_null(blob) || offset < 0 || isnull(rec["end_offset"]))
    return NULL;

  if(offset + 2 > rec["end_offset"])
    return NULL;
  rec["extensions_length"] = getword(blob:blob, pos:offset);
  offset += 2;

  # Calculate the end of all extensions.
  end = offset + rec["extensions_length"];
  if(end > rec["end_offset"])
    return NULL;

  while(offset < end)
  {
    # Parse out elements common to every extension.
    if(offset + 4 > rec["end_offset"])
      return NULL;
    id = getword(blob:blob, pos:offset);
    offset += 2;
    length = getword(blob:blob, pos:offset);
    offset += 2;

    # Calculate the end of this extension.
    subend = offset + length;
    if(subend > end)
      return NULL;

    # Parse extension-specific fields.
    if(id == 0xff01)
    {
      if(offset + 1 > subend)
        return NULL;
      rec["extension_renegotiation_info_renegotiated_connection"] = getbyte(blob:blob, pos:offset);
      offset += 1;
    }
    else if(id == 0xf)
    {
      if( offset + 1 > subend)
        return NULL;
      rec["extension_heartbeat_mode"] = getbyte(blob:blob, pos:offset);
      offset += 1;
    }
    else if(id == 0x10)
    {
      # alpn length
      length = getword(pos:offset, blob:blob);
      offset += 2;
      # string length
      len = getbyte(pos:offset, blob:blob);
      offset += 1;
      rec['extension_alpn_protocol'] = substr(blob, offset, offset + len - 1);
      offset += (length - 1);
    }
    else if(id == 0x3374)
    {
      rec["extension_next_protocol_negotiation"] = make_list();

      # Parse out a limited number of protocols.
      for(num = 0; num < 64 && offset < subend; num++)
      {
        if(offset + 1 > subend)
          return NULL;
        len = getbyte(blob:blob, pos:offset);
        offset += 1;

        if(offset + len > subend)
          return NULL;

        rec["extension_next_protocol_negotiation"] = make_list(
          rec["extension_next_protocol_negotiation"],
          substr(blob, offset, offset + len - 1)
        );
        offset += len;
      }

      # Force the offset, in case we bailed out of the loop early.
      offset = subend;
    }
    # TLS Session Ticket extension
    else if(id == 0x0023)
    {
      # For ServerHello, this should always be zero bytes per
      # RFC 5077. Its presence just indicates that the actual
      # session ticket will be coming in the NewSessionTicket
      # handshake message.
      # Possibly there is a few bytes in here (an older,
      # deprecated RFC 4507 says so) so instead of presenting
      # the actual bytes, we just say whether the extension
      # is present or not.
      rec['extension_session_ticket'] = TRUE;
      offset += length;
    }
    # TLS Supported Versions extension
    else if(id == 0x002b)
    {
      rec['extension_supported_versions'] = make_list();

      # Parse out a limited number of versions.
      for(num = 0; num < (length/2) && offset < subend; num++)
      {
        # Parse out a supported version
        rec['extension_supported_versions'] = make_list(
          rec['extension_supported_versions'],
          getword(blob:blob, pos:offset)
        );

        if( !isnull(tls13_random_offset) &&
            rec['extension_supported_versions'][num] == TLS_13 &&
            rec["end_offset"] >= tls13_random_offset + 32)
        {
          # in TLS 1.3 time is not used and instead it is 32 random bytes
          rec['random'] = substr(blob, tls13_random_offset, tls13_random_offset + 32 - 1);
          rec['time'] = NULL;
        }

        offset += 2;
      }

      # Force the offset, in case we bailed out of the loop early.
      offset = subend;
    }
    # TLS Key Share extension
    else if (id == 0x0033)
    {
      rec['extension_key_share_group'] = getword(blob:blob, pos:offset);
      offset += 2;
      rec['extension_key_share_key_exchange_length'] = getword(blob:blob, pos:offset);
      offset += 2;
      rec['extension_key_share_key_exchange_data'] =
        substr(blob, offset, offset + rec['extension_key_share_key_exchange_length'] - 1);
      offset += rec['extension_key_share_key_exchange_length'];
    }
    #QUIC transport parameters
    else if (id == 0x0039)
    {
      rec['quic_transport_params'] = substr(blob, offset, offset + length - 1);
      offset += length;
    }
    else
    {
      offset += length;
    }
  }

  return offset;
}

##
# Parses the SSL record at a given offset.
#
# In the case of SSLv3/TLSv1, multiple higher-level elements can be
# put inside of a single record. The element parameter exists to allow
# the caller to specify which of these higher-level elements they want
# parsed.
#
# SSLv3/TLSv1 also permit a single higher-level element to span # multiple records.
# That isn't supported by this function.
#
# TLS 1.3 specifies no version at the record layer except the
# "legacy_record_version" which must be set to a prior version "for compatibility"
# even though there are many record format differences from earlier versions.
#
# @param [blob:bytes] A stream of records
# @param [element:int] Index of an element inside a record
# @param [encrypted:bool] Indicates whether the record is encrypted, false by default
# @param [offset:int] Byte offset at which to begin parsing
# @param [tls13:bool] TRUE if we know we are parsing a TLS13 record - optional
#
# @return [array|int|NULL] NULL on error, integer on end of record, and an array
#         representing the parsed record on success
##
function ssl_parse(blob, element, encrypted, offset, tls13)
{
  local_var end, i, id, len, length, rec, ver, dtls, tls13_random_offset;

  # Sanity check arguments.
  if ( isnull(blob) ) return NULL;
  if ( isnull(offset) ) offset = 0;
  if ( strlen(blob) - offset < 5 ) return NULL;
  if ( isnull(element) ) element = 0;
  if ( isnull(encrypted) ) encrypted = FALSE;
  if ( isnull(tls13) ) tls13 = FALSE;

  # Initialize record.
  rec = make_array();
  rec["start_offset"] = offset;

  ver = getword(blob:blob, pos:offset + 1);
  if(ver >= DTLS_10)  # The likely minimum for DTLS versions
    dtls = ver;

  if ( (ver >= 0x0300 && ver <= TLS_12) || (ver >= DTLS_12 && ver <= DTLS_10) )
  {
    # Parse SSLv3 and TLSv1 header.
    rec["content_type"] = getbyte(blob:blob, pos:offset);
    offset += 1;
    rec["version"] = ver;
    offset += 2;
    if(!isnull(dtls))
    {
      rec["epoch"] = getword(blob:blob, pos:offset);
      offset += 2;
      rec["seq_no"] = getword(blob:blob, pos:offset) + getdword(blob:blob, pos:offset + 2);
      offset += 6;
    }
    rec["length"] = getword(blob:blob, pos:offset);
    offset += 2;

    # Set end offset based on declared length.
    rec["end_offset"] = rec["start_offset"] + 5 + rec["length"];
    if ( rec["end_offset"] > strlen(blob) ) return NULL;

    # If the record is encrypted, we can't look any further than this.
    # Consider the rest of the record as a blob.
    if ( encrypted )
    {
      # We can't look inside, so we can't check for higher-level
      # elements.
      if (element != 0) return rec["end_offset"];

      rec["data"] = substr(blob, offset, offset + rec["end_offset"] - 1);
      return rec;
    }

    # A single SSL record may contain several higher-level elements.
    # We need to find the element specified by the caller.
    for ( i = 0; i < element; i++ )
    {
      # Check if there's more higher-level elements.
      if ( offset + 4 >= rec["end_offset"] ) return rec["end_offset"];

      # Only handshake elements tend to be concatenated.
      if ( rec["content_type"] != SSL3_CONTENT_TYPE_HANDSHAKE ) return rec["end_offset"];

      # Skip this element's type, length, and body.
      offset += 1;
      length = (ord(blob[offset]) << 16) | (ord(blob[offset + 1]) << 8) | ord(blob[offset + 2]);
      offset += 3;
      if(!isnull(dtls))
        offset += 8;
      offset += length;
    }
    rec["element"] = i;
    if ( offset >= rec["end_offset"] ) return rec["end_offset"];

    if ( rec["content_type"] == SSL3_CONTENT_TYPE_HANDSHAKE )
    {
      # Parse handshake header.
      if ( offset + 4 > rec["end_offset"] ) return NULL;
      rec["handshake_type"] = getbyte(blob:blob, pos:offset);
      offset += 1;
      rec["handshake_length"] = (ord(blob[offset]) << 16) | (ord(blob[offset + 1]) << 8) | ord(blob[offset + 2]);
      offset += 3;

      if(!isnull(dtls))
      {
        rec["mseq"] = getword(blob:blob, pos:offset);
        offset += 2;
        rec["fragoff"] = get_int24(blob:blob, pos:offset);
        offset += 3;
        rec["fraglen"] = get_int24(blob:blob, pos:offset);
        offset += 3;
      }

      # Handshake messages may end before the packet, since multiple
      # messages are often concatenated.
      rec["end_offset"] = offset + rec["handshake_length"];
      if ( rec["end_offset"] > strlen(blob) ) return NULL;

      if ( rec["handshake_type"] == SSL3_HANDSHAKE_TYPE_SERVER_HELLO )
      {
        if ( offset + 38 > rec["end_offset"] ) return NULL;
        rec["handshake_version"] = getword(blob:blob, pos:offset);
        offset += 2;
        rec["time"] = getdword(blob:blob, pos:offset);
        tls13_random_offset = offset;
        offset += 4;
        rec["random"] = substr(blob, offset, offset + 28 - 1);
        offset += 28;
        rec["session_id_length"] = getbyte(blob:blob, pos:offset);
        offset += 1;
        rec["session_id"] = substr(blob, offset, offset + rec["session_id_length"] - 1);
        offset += rec["session_id_length"];
        rec["cipher_spec"] = getword(blob:blob, pos:offset);
        offset += 2;
        rec["compression_method"] = getbyte(blob:blob, pos:offset);
        offset += 1;

        # A record without extensions might not have an extensions
        # length field.
        if ( offset < rec["end_offset"] )
        {
          offset = parse_tls_extensions(blob:blob, offset:offset, tls13_random_offset:tls13_random_offset, rec:rec);
          if(isnull(offset))
            return NULL;
        }
        else
        {
          rec["extensions_length"] = 0;
        }
      }
      else if ( rec["handshake_type"] == SSL3_HANDSHAKE_TYPE_SERVER_HELLO_DONE )
      {
        # This handshake type contains no fields.
      }
      else if ( rec["handshake_type"] == SSL3_HANDSHAKE_TYPE_CLIENT_HELLO )
      {
        if ( offset + 35 > rec["end_offset"] ) return NULL;
        rec["handshake_version"] = getword(blob:blob, pos:offset);
        offset += 2;
        rec["time"] = getdword(blob:blob, pos:offset);
        offset += 4;
        rec["random"] = substr(blob, offset, offset + 28 - 1);
        offset += 28;
        rec["session_id_length"] = getbyte(blob:blob, pos:offset);
        offset += 1;
        if ( offset + rec["session_id_length"] > rec["end_offset"] ) return NULL;
        rec["session_id"] = substr(blob, offset, offset + rec["session_id_length"] - 1);
        offset += rec["session_id_length"];
        if ( offset + 2 > rec["end_offset"] ) return NULL;
        rec["cipher_specs_length"] = getword(blob:blob, pos:offset);
        offset += 2;

        end = offset + rec["cipher_specs_length"];
        if ( end > rec["end_offset"] ) return NULL;
        rec["cipher_specs"] = make_list();
        while ( offset < end )
        {
          rec["cipher_specs"] = make_list(
            rec["cipher_specs"],
            getword(blob:blob, pos:offset)
          );
          offset += 2;
        }

        if ( offset + 1 > rec["end_offset"] ) return NULL;
        rec["compression_methods_length"] = getbyte(blob:blob, pos:offset);
        offset += 1;

        end = offset + rec["compression_methods_length"];
        if ( end > rec["end_offset"] ) return NULL;
        rec["compression_methods"] = make_list();
        while ( offset < end )
        {
          rec["compression_methods"] = make_list(
            rec["compression_methods"],
            getbyte(blob:blob, pos:offset)
          );
          offset += 1;
        }
      }
      else if ( rec["handshake_type"] == SSL3_HANDSHAKE_TYPE_NEW_SESSION_TICKET )
      {
        if ( offset + 4 > rec["end_offset"] ) return NULL;
        # 32-bit unsigned seconds: how long to keep the ticket
        rec["ticket_lifetime_hint"] = getdword(blob:blob, pos:offset);
        offset += 4;

        if(tls13)
        {
          #Age add
          if ( offset + 4 > rec["end_offset"] ) return NULL;
          rec["ticket_age_add"] = getdword(blob:blob, pos:offset);
          offset += 4;

          #Nonce
          if ( offset + 1 > rec["end_offset"] ) return NULL;
          len = getbyte(blob:blob, pos:offset);
          offset += 1;
          if(len > 0)
          {
            if ( offset + len > rec["end_offset"] ) return NULL;
            rec["ticket_nonce"] = substr(blob, offset, offset + len - 1);
            offset += len;
          }
        }

        # Length field for the ticket
        if ( offset + 2 > rec["end_offset"] ) return NULL;
        rec["ticket_length"] = getword(substr(blob, offset, offset + 2));
        offset += 2;

        # The ticket is an opaque byte buffer
        if ( offset + rec["ticket_length"] > rec["end_offset"] ) return NULL;
        rec["ticket"] = substr(blob, offset, offset + rec["ticket_length"] - 1);
        offset += rec["ticket_length"];
      }
      else if ( rec["handshake_type"] == SSL3_HANDSHAKE_TYPE_SERVER_KEY_EXCHANGE )
      {
        if ( offset + rec["handshake_length"] > rec["end_offset"] ) return NULL;
        rec["data"] = substr(blob, offset, offset + rec["handshake_length"] - 1);
      }
      else if ( rec["handshake_type"] == SSL3_HANDSHAKE_TYPE_CERTIFICATE )
      {
        if ( offset + 3 > rec["end_offset"] ) return NULL;
        if(tls13)
        {
          len = ord(blob[offset]);
          offset ++;

          if(len > 0)
          {
            rec["certificate_request_context"] = substr(blob, offset, offset + len - 1);
            offset += len;
          }
        }

        rec["certificates_length"] = (ord(blob[offset]) << 16) | (ord(blob[offset + 1]) << 8) | ord(blob[offset + 2]);
        offset += 3;
        end = offset + rec["certificates_length"];

        if ( end > rec["end_offset"] ) return NULL;
        rec["certificates"] = make_list();
        while ( offset < end )
        {
          if ( offset + 3 > rec["end_offset"] ) return NULL;
          length = (ord(blob[offset]) << 16) | (ord(blob[offset + 1]) << 8) | ord(blob[offset + 2]);
          offset += 3;

          if ( offset + length > rec["end_offset"] ) return NULL;

          rec["certificates"] = make_list(
            rec["certificates"],
            substr(blob, offset, offset + length - 1)
          );

          offset += length;

          if(tls13)
          {
            offset = parse_tls_extensions(blob:blob, offset:offset, rec:rec);
            if(isnull(offset))
              return NULL;
          }

        }
      }
      else if ( rec["handshake_type"] == SSL3_HANDSHAKE_TYPE_CERTIFICATE_REQUEST )
      {
        if ( offset + rec["handshake_length"] > rec["end_offset"] ) return NULL;
        rec["data"] = substr(blob, offset, offset + rec["handshake_length"] - 1);
      }
      else if ( rec["handshake_type"] == SSL3_HANDSHAKE_TYPE_HELLO_VERIFY_REQUEST )
      {
        if ( offset + rec["handshake_length"] > strlen(blob)) return NULL;

        rec["server_version"] = getword(blob:blob, pos:offset);
        offset += 2;
        # The cookie can be 0-32 bytes long, so the length field is only ever one byte
        rec["cookie_len"] = getbyte(blob:blob, pos:offset);
        offset += 1;
        if ( offset + rec["cookie_len"] > strlen(blob)) return NULL;
        rec["cookie"] = substr(blob, offset, offset + rec["cookie_len"] - 1);

      }
      else if ( rec["handshake_type"] == TLS13_HANDSHAKE_TYPE_ENCRYPTED_EXTENSIONS )
      {
        offset = parse_tls_extensions(blob:blob, offset:offset, rec:rec);
        if(isnull(offset))
          return NULL;
      }
      else
      {
        if ( offset + rec["handshake_length"] > rec["end_offset"] ) return NULL;
        rec["data"] = substr(blob, offset, offset + rec["handshake_length"] - 1);
      }
    }
    else if ( rec["content_type"] == SSL3_CONTENT_TYPE_APPLICATION_DATA )
    {
      rec["data"] = substr(blob, offset, rec["end_offset"] - 1);
    }
    else if ( rec["content_type"] == SSL3_CONTENT_TYPE_ALERT )
    {
      if ( offset + 2 > rec["end_offset"] ) return NULL;
      rec["level"] = getbyte(blob:blob, pos:offset);
      offset += 1;
      rec["description"] = getbyte(blob:blob, pos:offset);
      offset += 1;
    }
  }
  else
  {
    # Parse SSLv2.
    # 2-byte record header
    if(ord(blob[offset]) & 0x80)
    {
      rec["length"] = ((ord(blob[offset]) & 0x7f) << 8) | ord(blob[offset + 1]);
      offset += 2;
    }
    # 3-byte record header
    else
    {
      rec["length"] = ((ord(blob[offset]) & 0x3f) << 8) | ord(blob[offset + 1]);
      offset += 3;
    }

    # Set end offset based on declared length.
    rec["end_offset"] = rec["start_offset"] + 2 + rec["length"];
    if ( rec["end_offset"] > strlen(blob) ) return NULL;

    # Set the element to zero, since there can only ever be one
    # higher-level record in SSLv2.
    if ( element > 0) return rec["end_offset"];
    rec["element"] = 0;

    if ( offset + 1 > rec["end_offset"] ) return NULL;
    rec["content_type"] = getbyte(blob:blob, pos:offset);
    offset += 1;

    if ( rec["content_type"] == SSL2_CONTENT_TYPE_SERVER_HELLO )
    {
      if ( offset + 10 > rec["end_offset"] ) return NULL;
      rec["session_id_hit"] = getbyte(blob:blob, pos:offset);
      offset += 1;
      rec["certificate_type"] = getbyte(blob:blob, pos:offset);
      offset += 1;
      rec["version"] = getword(blob:blob, pos:offset);
      offset += 2;
      rec["certificate_length"] = getword(blob:blob, pos:offset);
      offset += 2;
      rec["cipher_specs_length"] = getword(blob:blob, pos:offset);
      offset += 2;
      rec["conn_id_length"] = getword(blob:blob, pos:offset);
      offset += 2;
      if ( offset + rec["certificate_length"] > rec["end_offset"] ) return NULL;
      rec["certificate"] = substr(blob, offset, offset + rec["certificate_length"] - 1);
      offset += rec["certificate_length"];

      end = offset + rec["cipher_specs_length"];
      if ( end > rec["end_offset"] ) return NULL;
      rec["cipher_specs"] = make_list();
      while ( offset < end )
      {
        rec["cipher_specs"] = make_list(
          rec["cipher_specs"],
          (ord(blob[offset]) << 16) | (ord(blob[offset + 1]) << 8) | ord(blob[offset + 2])
        );
        offset += 3;
      }

      if ( offset + rec["conn_id_length"] > rec["end_offset"] ) return NULL;
      rec["conn_id"] = substr(blob, offset, offset + rec["conn_id_length"] - 1);
      offset += rec["conn_id_length"];
    }
  }

  return rec;
}

##
# Parses the ServerKeyExchange record.
#
# @param [blob:bytes] Body of the ServerKeyExchange record.
# @param [cipher:string] Description of cipher suite.
# @param [version:int] A SSL/TLS encapsulation code.
#
# @remark
# [ssl_parse] cannot parse the contents of the ServerKeyExchange record you need information
#             from previous records in the connection to know its format.
#
# @return [array|NULL] On success, returns the encryption parameters, otherwise returns NULL.
##
function ssl_parse_srv_kex(blob, cipher, version)
{
  local_var curve_type, kex, pos, res;

  # Sanity check parameters.
  if (isnull(blob) || isnull(cipher))
    return NULL;

  cipher = cipher_field(name:cipher, field:"kex");

  kex = make_array();

  pos = 0;
  # Determine how the key should be parsed.
  if (cipher =~ "RSA(\(|$)")
  {
    kex["kex"] = "rsa";

    # Modulus
    res = ssl_vldata_get(blob:blob, pos:pos, len:2);
    if (isnull(res)) return NULL;
    kex['rsa_n'] = res["data"];
    pos += res["len"];

    # Public exponent
    res = ssl_vldata_get(blob:blob, pos:pos, len:2);
    if (isnull(res)) return NULL;
    kex['rsa_e'] = res["data"];
    pos += res["len"];

  }
  # RFC 4492, section 5.4
  else if (cipher =~ "ECDH(\(|$)")
  {
    kex["kex"] = "ecdh";
    curve_type = ord(blob[pos]); pos += 1;

    kex['curve_type'] = curve_type;
    # NamedCurve
    if(curve_type == 3)
    {
      if(pos + 2 > strlen(blob)) return NULL;
      kex['named_curve'] = (ord(blob[pos]) << 8 ) + ord(blob[pos + 1]);
      pos += 2;
    }
    # explicit_prime or explicit_char2
    else if (curve_type == 1 || curve_type == 2)
    {
      # explicit_prime
      if(curve_type == 1)
      {
        # prime
        res = ssl_vldata_get(blob:blob, pos:pos, len:1);
        if (isnull(res)) return NULL;
        kex['prime'] = res["data"];
        pos += res["len"];
      }
      # explicit_char2
      else
      {
        if(pos + 3 > strlen(blob)) return NULL;
        kex['m'] = (ord(blob[pos]) << 8 ) + ord(blob[pos + 1]);
        pos += 2;

        kex['basis'] = ord(blob[pos]); pos += 1;

        # ec_basis_trinomial or ec_basis_pentanomial
        if(kex['basis'] == 1 || kex['basis'] == 2)
        {
          # k1
          res = ssl_vldata_get(blob:blob, pos:pos, len:1);
          if (isnull(res)) return NULL;
          kex['k1'] = res["data"];
          pos += res["len"];

          # ec_basis_pentanomial
          if(kex['basis'] == 2)
          {
            # k2
            res = ssl_vldata_get(blob:blob, pos:pos, len:1);
            if (isnull(res)) return NULL;
            kex['k2'] = res["data"];
            pos += res["len"];

            # k3
            res = ssl_vldata_get(blob:blob, pos:pos, len:1);
            if (isnull(res)) return NULL;
            kex['k3'] = res["data"];
            pos += res["len"];
          }
        }
        else return NULL;
      }

      # coefficient a of the curve
      res = ssl_vldata_get(blob:blob, pos:pos, len:1);
      if (isnull(res)) return NULL;
      kex['curve_a'] = res["data"];
      pos += res["len"];

      # coefficient b of the curve
      res = ssl_vldata_get(blob:blob, pos:pos, len:1);
      if (isnull(res)) return NULL;
      kex['curve_b'] = res["data"];
      pos += res["len"];

      # base
      res = ssl_vldata_get(blob:blob, pos:pos, len:1);
      if (isnull(res)) return NULL;
      kex['base'] = res["data"];
      pos += res["len"];

      # order
      res = ssl_vldata_get(blob:blob, pos:pos, len:1);
      if (isnull(res)) return NULL;
      kex['order'] = res["data"];
      pos += res["len"];

      # cofactor
      res = ssl_vldata_get(blob:blob, pos:pos, len:1);
      if (isnull(res)) return NULL;
      kex['cofactor'] = res["data"];
      pos += res["len"];
    }
    # Unknown curve type
    else return NULL;

    # Public key in ECPOINT fmt
    res = ssl_vldata_get(blob:blob, pos:pos, len:1);
    if (isnull(res)) return NULL;
    kex['pubkey'] = res["data"];
    pos += res["len"];

  }
  else if (cipher =~ "DH(\(|$)")
  {
    kex["kex"] = "dh";

    # Prime modulus
    res = ssl_vldata_get(blob:blob, pos:pos, len:2);
    if (isnull(res)) return NULL;
    kex['dh_p'] = res["data"];
    pos += res["len"];

    # Generator
    res = ssl_vldata_get(blob:blob, pos:pos, len:2);
    if (isnull(res)) return NULL;
    kex['dh_g'] = res["data"];
    pos += res["len"];

    # The server's DH public value (g^X mod p)
    res = ssl_vldata_get(blob:blob, pos:pos, len:2);
    if (isnull(res)) return NULL;
    kex['dh_y'] = res["data"];
    pos += res["len"];

  }
  # Currently not support
  else
  {
    return NULL;
  }


  # Parse the signature.
  # tls 1.0 and 1.1:
  #   A digitally-signed element is encoded as an opaque
  #   vector <0..2^16-1>,
  #
  # tls 1.2:
  #   A digitally-signed element is encoded as a struct DigitallySigned:
  #
  #   struct {
  #       SignatureAndHashAlgorithm algorithm;
  #       opaque signature<0..2^16-1>;
  #    } DigitallySigned
  if(version == TLS_12)
  {
    if(pos + 2 > strlen(blob))
      return NULL;

    kex["hash_alg"] = ord(blob[pos]);
    kex["sig_alg"]  = ord(blob[pos + 1]);
    pos += 2;
  }

  res = ssl_vldata_get(blob:blob, pos:pos, len:2);
  if (isnull(res))
    return NULL;
  kex["sig"] = res["data"];

  return kex;
}

##
# Tries to find an SSL record matching a specific set of criteria.
#
# This function accepts pairs of anonymous arguments that specify the
# values expected in certain fields, and returns the first record that
# matches all expectations.
#
# If the element parameter is passed, the function will begin the
# search at a given higher-level element inside the SSLv3/TLSv1 record
# found at the offset.
#
# @param [blob:bytes] A stream of records
# @param [element:int] Index of an element inside a record
# @param [encrypted:bool] Indicates whether the record is encrypted, false by default
# @param [offset:int] Byte offset at which to begin parsing
# @param [tls13:bool] TRUE for TLS 1.3, FALSE otherwise (optional)
#
# @anonparam [first:string] Field in record, must be followed by a value
# @anonparam [second:int] Value of field, must be preceded by a field
#
# @return [array] An array representing the first record that matched the
#         given filters, or NULL if no match was found.
##
function ssl_find(blob, element, encrypted, offset, tls13)
{
  local_var filter, i, key, passed, rec, value;

  # Sanity check arguments.
  if ( isnull(blob) ) return NULL;
  if ( isnull(offset) ) offset = 0;
  if ( isnull(element) ) element = 0;
  if ( isnull(tls13) ) tls13 = FALSE;

  # Make anonymous arguments into a filter.
  filter = make_array();
  for ( i = 0; i < max_index(_FCT_ANON_ARGS); i += 2 )
    filter[_FCT_ANON_ARGS[i]] = _FCT_ANON_ARGS[i + 1];

  while ( offset < strlen(blob) )
  {
    for ( i = element; TRUE; i++ )
    {
      # Get the next record in the stream.
      rec = ssl_parse(blob:blob, element:i, encrypted:encrypted, offset:offset, tls13:tls13);
      if ( isnull(rec) ) return NULL;
      if ( typeof(rec) == "int" ) break;

      # Test the record against all the filters.
      passed = TRUE;
      foreach key ( keys(filter) )
      {
        value = rec[key];
        if ( ! isnull(value) && value == filter[key] ) continue;

        passed = FALSE;
        break;
      }

      # If all the filters passed, we've found our target.
      if ( passed ) return rec;
    }

    # While we may have wanted to start searching partway into a
    # record, we want to start at the first element of subsequent
    # records.
    element = 0;
    offset = rec;
  }

  return NULL;
}

##
# Retrieves all available SSL/TLS data on a TCP port.  Retries receiving up to a prescribed number of attempts.
#
# @param [socket:int]  The socket.
# @param [timeout:int] Soft timeout in seconds.
# @param [max:int]     Maximum number of times to retry while there is still pending data on the socket.
#
# @return [bytes|NULL] The raw retrieved data.  On error returns NULL.
##
function recv_ssl_recs(socket, timeout, max)
{
  local_var err, nr, r, recs;

  if(isnull(max)) max = 32;

  nr = 0;
  recs = NULL;

  while(1)
  {
    err = socket_get_error(socket);
    if (isnull(err)) break;
    if (err != NOERR && err != ETIMEDOUT) break;

    r = recv_ssl(socket:socket, timeout:timeout);
    if(isnull(r)) break;
    recs += r;
    if(max && nr++ > max) break;

    if(! socket_pending(socket))
    {
      sleep(1);
      if(! socket_pending(socket)) break;
    }
  }

  if (recs && !(ord(recs[1]) == 3 && ord(recs[2]) >= 0 && ord(recs[2]) <= 3)) # If not SSLv3+
    return recs;
  else
    return adjust_recs(recs);
}


##
# Parses out TLS handshake records from the input data.
#
# @anonparam [first:bytes] Data received from a SSL/TLS enabled service.
#
# @return [bytes|NULL] TLS handshake records embedded in the supplied data.
##
function adjust_recs()
{
  local_var data, out, r, rec_type, rec_len;
  local_var h, hs, hs_frag, hs_len;
  local_var dend, hend, rend;
  local_var left, n, pt, t, ver;
  local_var nf, nh, nr;

  data = _FCT_ANON_ARGS[0];
  r = 0;
  dend = strlen(data);

  nr = 0;
  hs_frag = 0;
  while (r < dend)
  {
    # A record should at least have a 5-byte header
    if(r  +  5 > dend) return NULL;

    rec_type = getbyte(blob: data, pos: r);
    rec_len = getword(blob: data, pos: r + 3);
    rend = r +  5 + rec_len;

    # Record past the end of the input data
    if(rend > dend) return NULL;

    # Unexpectedly too many received records
    if(nr++ > 32) return NULL;

    if(rec_type == SSL3_CONTENT_TYPE_HANDSHAKE)
    {
      nh = 0;
      h = r + 5;
      while (h < rend)
      {
        # A handshake msg should at least have a 4-byte header
        if (h + 4 > rend) return NULL;

        hs_len =
          (ord(data[h + 1]) << 16) +
          (ord(data[h + 2]) << 8) +
          ord(data[h + 3]);

        hend = h +  4 + hs_len;

        # Handshake msg past the end of the input data
        if(hend > dend) return NULL;

        # Unexpectedly too many handshake msgs in a record
        if(nh++ > 32) return NULL;

        # Handshake msg past the end of the record
        if(hend > rend)
        {
          hs_frag = 1;
          break;
        }
        h = hend;
      }

      if(hs_frag) break;
    }
    r =  rend;
  }

  # No HS frags, return the original data
  if(! hs_frag) return data;

  # Data preceding the first record containing HS frags
  out = substr(data, 0, r -1 );

  # Start with first record containing HS frags
  nr = 0;
  while(r < dend)
  {
    # A record should at least have a 5-byte header
    if(r  +  5 > dend) return NULL;

    rec_type = getbyte(blob: data, pos: r);
    ver      = substr(data, r + 1, r + 2);
    rec_len = getword(blob: data, pos: r + 3);
    rend = r +  5 + rec_len;

    # Record past the end of the input data
    if(rend > dend) return NULL;

    # Unexpectedly too many received records
    if(nr++ > 32) return NULL;

    if(rec_type == SSL3_CONTENT_TYPE_HANDSHAKE)
    {
      nh = 0;
      h = r + 5;
      while (h < rend)
      {
        # A handshake msg should at least have a 4-byte header
        if (h + 4 > rend) return NULL;
        hs = "";

        hs_len =
          (ord(data[h + 1]) << 16) +
          (ord(data[h + 2]) << 8) +
          ord(data[h + 3]);

        hend = h +  4 + hs_len;

        # Handshake msg past the end of the input data
        if(hend > dend) return NULL;

        # Unexpectedly too many handshake msgs
        if(nh++ > 32) return NULL;

        # Can only assemble hs up to 2^16 -1 bytes
        if(hs_len > 0xffff) return NULL;

        # Handshake msg fragment detected
        if(hend > rend)
        {
          # Data in first frag
          hs = substr(data, h, rend - 1);

          # Remaining hs len
          left = hs_len - (rend - (h + 4));

          # Process subsequent frag(s)
          h = r = rend;

          nf = 0;
          while(r < dend)
          {
            # A record should at least have a 5-byte header
            if(r  +  5 > dend) return NULL;

            rec_type = getbyte(blob: data, pos: r);
            ver      = substr(data, r + 1, r + 2);
            rec_len = getword(blob: data, pos: r + 3);
            rend = r + 5 + rec_len;

            # Record past the end of the input data
            if(rend > dend) return NULL;

            # We can only assemble handshake msgs
            if(rec_type != SSL3_CONTENT_TYPE_HANDSHAKE)
            {
              out += substr(r, rend -1);
              h = r = rend;
              continue;
            }

            # Unexpectedly too many fragments for a handshake msg
            if(nf++ > 32) return NULL;

            if (left >= rec_len)
            {
              n = rec_len;
            }
            else
            {
              n = left;
            }
            pt = r + 5 + n;
            hs += substr(data, r + 5, pt - 1);
            left -= n;
            h += 5 + n;

            if(left > 0)
              r = rend;
            else
              break;
          }

          # Assemble handshake fragments
          out +=  mkbyte(rec_type) +
                  ver +
                  mkword(strlen(hs)) +
                  hs;

        }
        # hs within rec
        else
        {
          hs = substr(data, h, h + 4 + hs_len -1);
          out +=  mkbyte(rec_type) +
                  ver +
                  mkword(strlen(hs)) +
                  hs;

          h += 4 + hs_len;
        }
      } // while hs
    }
    # Other record types
    else
    {
      out += substr(r, rend -1);
    }
    r = rend;
  } // while record

  return out;
}

##
# Performs a SSLv3 handshake.
#
# @param [exit_on_fail:bool] Will exit the current plugin on error if TRUE - optional (default FALSE)
# @param [port:int]          Port on the target hosting the SSLv3 service.
# @param [socket:int]        Socket open to the target SSLv3 service.
# @param [transport:int]     A SSL/TLS encapsulation code.
#
# @return [array|NULL] Returns an array of SSL record data if successful, otherwise returns NULL.
##
function ssl3_handshake(exit_on_fail, port, socket, transport)
{
  local_var inner, middle, msg, offset, outer, pair, rec, recs, result;

  # Provide defaults for arguments.
  if ( isnull(exit_on_fail) ) exit_on_fail = FALSE;


  # Make sure we support the encapsulation method this port uses.
  if ( transport < ENCAPS_SSLv3 || transport > COMPAT_ENCAPS_TLSv12 )
  {
    msg = "Unsupported encapsulation method.";
    if ( exit_on_fail ) exit(1, msg);
    debug_print(msg);
    return NULL;
  }

  # The three sockets we use will be arranged as follows:
  #   inner <-> middle <-> MITM code <-> outer <-> target
  pair = socketpair();
  inner = pair[0];
  middle = pair[1];

  outer = socket;
  if ( isnull(outer) )
  {
    # We need a port if we weren't given a socket.
    if ( isnull(port) )
    {
      msg = "Port not specified and socket not provided.";
      if ( exit_on_fail ) exit(1, msg);
      debug_print(msg);
      close(inner);
      close(middle);
      return NULL;
    }

    outer = open_sock_tcp(port, transport:ENCAPS_IP);
    if ( ! outer )
    {
      msg = "Port "+port+" is not open.";
      if ( exit_on_fail ) exit(1, msg);
      debug_print(msg);
      close(inner);
      close(middle);
      return NULL;
    }
  }

  # Collect all SSL records to return to caller.
  result = "";

  # Receive handshake part 1 of 4:
  #   ClientHello
  socket_negotiate_ssl(socket:inner, transport:transport, async:TRUE);
  socket_ready(inner);
  recs = recv_ssl(socket:middle);
  if ( recs == "" )
  {
    msg = "Error generating ClientHello.";
    if ( exit_on_fail ) exit(1, msg);
    debug_print(msg);
    close(inner);
    close(middle);
    if ( isnull(socket) ) close(outer);
    return NULL;
  }
  send(socket:outer, data:recs);
  result += recs;

  # Receive handshake part 2 of 4:
  #   ServerHello, Certificate, ServerKeyExchange, ServerHelloDone
  recs = "";
  while ( TRUE )
  {
    rec = recv_ssl(socket:outer);
    if ( isnull(rec) ) break;
    recs += rec;

    socket_ready(inner);
    send(socket:middle, data:rec);

    rec = ssl_find(
      blob:rec,
      "content_type", SSL3_CONTENT_TYPE_HANDSHAKE,
      "handshake_type", SSL3_HANDSHAKE_TYPE_SERVER_HELLO_DONE
    );
    if ( ! isnull(rec) ) break;
  }
  if ( recs == "" )
  {
    msg = "Target didn't respond to ClientHello.";
    if ( exit_on_fail ) exit(1, msg);
    debug_print(msg);
    close(inner);
    close(middle);
    if ( isnull(socket) ) close(outer);
    return NULL;
  }
  result += recs;

  # Receive handshake part 3 of 4:
  #   ClientKeyExchange, ChangeCipherSpec, Finished
  socket_ready(inner);
  recs = "";
  while ( TRUE )
  {
    rec = recv_ssl(socket:middle);
    if ( isnull(rec) ) break;
    recs += rec;

    send(socket:outer, data:rec);

    rec = ssl_find(
      blob:rec,
      "content_type", SSL3_CONTENT_TYPE_CHANGECIPHERSPEC
    );
    if ( ! isnull(rec) ) break;
  }
  rec = recv_ssl(socket:middle);
  if ( isnull(rec) || recs == "" )
  {
    msg = "OpenSSL didn't accept target's ServerHello.";
    if ( exit_on_fail ) exit(1, msg);
    debug_print(msg);
    close(inner);
    close(middle);
    if ( isnull(socket) ) close(outer);
    return NULL;
  }
  recs += rec;
  send(socket:outer, data:rec);
  result += recs;

  # Receive handshake part 4 of 4:
  #   ChangeCipherSpec, Finished
  recs = "";
  while ( TRUE )
  {
    rec = recv_ssl(socket:outer);
    if ( isnull(rec) ) break;
    recs += rec;

    rec = ssl_find(
      blob:rec,
      "content_type", SSL3_CONTENT_TYPE_CHANGECIPHERSPEC
    );
    if ( ! isnull(rec) ) break;
  }
  rec = recv_ssl(socket:outer);
  recs += rec;
  if ( recs == "" )
  {
    msg = "Target didn't respond to Finished.";
    if ( exit_on_fail ) exit(1, msg);
    debug_print(msg);
    close(inner);
    close(middle);
    if ( isnull(socket) ) close(outer);
    return NULL;
  }
  result += recs;

  # Close our initial session. This will not perform a proper SSL
  # shutdown.
  close(inner);
  close(middle);

  # Only close the outer socket if we made it ourselves.
  if ( isnull(socket) ) close(outer);

  return result;
}

##
# TLS pseudorandom number generation function
#
# @param [secret:bytes] key to the HMAC function
# @param [seed:bytes]   initial seed
# @param [label:string] label identifying the output data
# @param [nb:int]       number of bytes to generate
# @param [version:int]  A SSL/TLS encapsulation code.
# @param [cipher_desc:string]  a cipher description (optional)
#
# @return [bytes|NULL] Returns bytes of pseudorandom numbers or NULL if an error occurred.
##
function tls_prf(secret, seed, label, nb, version, cipher_desc)
{
  local_var data, slen, hslen, s1, s2;
  local_var i, j, k, hmac, A, out, result;

  if(isnull(version)) version = TLS_10;

  if(version < TLS_10 || version > TLS_12)
  {
    debug_print("tls_prf() does not support SSL version ", hexstr(mkword(version)), ".");
    return NULL;
  }

  data = label + seed;
  result = NULL;

  if(version == TLS_12)
  {
    var prf = @HMAC_SHA256;
    var prf_len = 32;

    if(!isnull(cipher_desc))
    {
      var prf_desc = cipher_field(name:cipher_desc, field:"mac");
      if(prf_desc == "SHA384")
      {
        prf = @HMAC_SHA384;
        prf_len = 48;
      }
      #None of these are defined for TLS 1.2, but just in case....
      else if(prf_desc == "SHA512")
      {
        prf = @HMAC_SHA512;
        prf_len = 64;
      }
    }

    A = data; # A(0)
    for(i = 0; i < nb; i += prf_len)
    {
      A = prf(key:secret, data:A); # A(i)
      result += prf(key:secret, data:A + data);
    }
    return substr(result, 0, nb - 1);
  }

  if(strlen(secret) == 0)
    s1 = s2 = '';
  else # split secret into equal halves
  {
    slen = strlen(secret);
    hslen = (slen + 1)/2;

    s1 = substr(secret, 0, hslen - 1);
    s2 = substr(secret, slen - hslen, slen -1);
  }

  #
  # P_MD5(S1, label+seed)
  #
  # A(1)
  A = HMAC_MD5(key:s1, data:data);
  for(i = 0 ; i < nb; i += 16)
  {
    hmac = HMAC_MD5(key:s1, data:A + data);

    if ( i + 16 > nb )  k = nb % 16;
    else                k = 16;

    for( j = 0; j < k; j++ )
      out[i + j]  = hmac[j];

    A = HMAC_MD5(key:s1, data:A);
  }

  #
  # XOR with P_SHA1(S2, label+seed)
  #
  # A(1)
  A = HMAC_SHA1(key:s2, data:data);
  for(i = 0 ; i < nb; i += 20)
  {
    hmac = HMAC_SHA1(key:s2, data:A + data);
    if ( i + 20 > nb )  k = nb % 20;
    else                k = 20;

    for( j = 0; j < k; j++ )
      result  += raw_string(ord(out[i + j]) ^ ord(hmac[j]));

    A = HMAC_SHA1(key:s2, data:A);
  }

  return result;
}

##
# Computes the master secret from pre master secret and random values
#
# @param [premaster:bytes] premaster secret
# @param [c_random:bytes]  32-byte client random value
# @param [s_random:bytes]  32-byte server random value
# @param [version:int]     A SSL/TLS encapsulation code.
# @param [cipher_desc:string] A cipher description (optional)
#
# @return [bytes] 48-byte master secret
#
##
function tls_calc_master(premaster, c_random, s_random, version, cipher_desc)
{
  local_var  master, seed;

  seed = c_random + s_random;

  master = tls_prf(secret:premaster, seed:seed,label:"master secret", nb:48, version:version, cipher_desc:cipher_desc);

  return master;
}

##
# Computes the master secret from pre master secret and random values
#
# @param [premaster:bytes] premaster secret
# @param [c_random:bytes] 32-byte client random value
# @param [s_random:bytes] 32-byte server random value
# @param [version:int] a SSL/TLS encapsulation code
# @param [cipher_desc:string] a cipher description (optional)
#
# @return [bytes|NULL] On success, returns a 48-byte master secret, otherwise returns NULL.
##
function ssl_calc_master(premaster, c_random, s_random, version, cipher_desc)
{
  local_var seed, master,sha1;

  if(isnull(version))
    version = SSL_V3;

  # SSL2 and below currently not supported
  if(version < SSL_V3)
    return NULL;

  if(version >= TLS_10)
    return tls_calc_master(premaster:premaster, c_random:c_random, s_random:s_random, version:version, cipher_desc:cipher_desc);

  # SSL v3
  # master =
  #       MD5( premaster + SHA1( 'A'   + premaster + randbytes ) ) +
  #       MD5( premaster + SHA1( 'BB'  + premaster + randbytes ) ) +
  #       MD5( premaster + SHA1( 'CCC' + premaster + randbytes ) )

  seed = c_random + s_random;
  master  = MD5(premaster + SHA1('A'  + premaster + seed)) +
            MD5(premaster + SHA1('BB' + premaster + seed)) +
            MD5(premaster + SHA1('CCC'+ premaster + seed));

  return master;

}

##
# Derives key material from the master secret
#
# @param [master:bytes] master secret
# @param [c_random:bytes] 32-byte client random value
# @param [s_random:bytes] 32-byte server random value
# @param [nb:int] number of bytes to generate
# @param [version:int] a SSL/TLS encapsulation code
# @param [cipher_desc:string] a cipher description (optional)
#
# @return [bytes] <nb>-byte key material for encryption, MAC, and IV
#                 if <nb> is not specified, the default is 256 bytes
##
function tls_derive_keyblk(master, c_random, s_random, nb,version, cipher_desc)
{
  local_var  seed, keyblk;

  if(isnull(nb)) nb = 256;

  seed = s_random + c_random;
  keyblk= tls_prf(secret:master, seed:seed,label:"key expansion", nb:nb, version:version, cipher_desc:cipher_desc);

  return keyblk;
}

##
# Derives key material from the master secret
#
# @param [master:bytes] master secret
# @param [c_random:bytes] 32-byte client random value
# @param [s_random:bytes] 32-byte server random value
# @param [nb:int] number of bytes to generate
# @param [version:int] a SSL/TLS encapsulation code
# @param [cipher_desc:string] a cipher description (optional)
#
# @return [bytes] <nb>-byte key material for encryption, MAC, and IV
#                 if <nb> is not specified, the default is 256 bytes
##
function ssl_derive_keyblk(master, c_random, s_random, nb,version, cipher_desc)
{
  local_var  seed, prefix,keyblk, i;

  # default to SSL v3
  if(isnull(version))
    version = SSL_V3;

  # SSL2 and below currently not supported
  if(version < SSL_V3)
    return NULL;

  if(isnull(nb)) nb = 256;

  if(version >= TLS_10)
    return tls_derive_keyblk(master:master, c_random:c_random, s_random:s_random, version:version, cipher_desc:cipher_desc);

  # SSL v3
  # key block =
  #   MD5( master + SHA1( 'A'    + master + randbytes ) ) +
  #   MD5( master + SHA1( 'BB'   + master + randbytes ) ) +
  #   MD5( master + SHA1( 'CCC'  + master + randbytes ) ) +
  #   MD5( master + SHA1( 'DDDD' + master + randbytes ) ) +
  #   ...

  keyblk = NULL;
  seed = s_random + c_random;
  for(i = 0; nb > 0; i++)
  {
    prefix = crap(data:mkbyte(ord('A') + i), length: i + 1);
    keyblk += MD5(master + SHA1(prefix+ master + seed));
    nb -= 16;
  }

  return keyblk;
}

##
# compute the Finished message
#
# @param [master:bytes] master secret
# @param [handshake:bytes] all plaintext handshake messages concatenated, excluding the
#                          record layer headers and MACs (http://tools.ietf.org/html/rfc2246#section-7.4.9)
# @param [version:int] a SSL/TLS encapsulation code
# @param [is_client:bool] is it the client side
# @param [cipher_desc:string] a cipher description (optional)
#
# @return [bytes|NULL] On success, returns a finished message, otherwise returns NULL.
##
function ssl_calc_finished(master, handshake, is_client, version, cipher_desc)
{
  local_var finished, sender, md5sum, sha1sum;

  # default to SSL v3
  if(isnull(version))
    version = SSL_V3;

  # SSL2 and below currently not supported
  if(version < SSL_V3)
    return NULL;

  #
  # SSLv3:
  # hash =
  #  MD5(  master + pad2 + MD5( handshake + sender + master + pad1 ) ) +
  #  SHA1( master + pad2 +SHA1( handshake + sender + master + pad1 ) )
  #
  #
  # TLSv1:
  #    hash = PRF( master, finished_label,MD5( handshake ) + SHA1( handshake ) )[0..11]
  #
  # TLSv12:
  #   hash = PRF( master, finished_labal, ciphersuite_hash(handshake))[0..n]
  #   nb: Supports only the default of P_SHA256, which is what all TLS1.0
  #   ciphers use when being used with TLS 1.2.
  if(version == SSL_V3)
  {
    if(is_client)
      sender = "CLNT";
    else
      sender = "SRVR";

    md5sum  = MD5( handshake + sender + master +  crap(data:'\x36',length:48));
    sha1sum = SHA1(handshake + sender + master +  crap(data:'\x36',length:40));

    finished = MD5( master + crap(data:'\x5c', length:48) + md5sum) +
               SHA1(master + crap(data:'\x5c', length:40) + sha1sum);
  }
  else if (version == TLS_10 || version == TLS_11)
  {
    if(is_client)
      sender = "client finished";
    else
      sender = "server finished";

    finished = tls_prf(secret:master, seed:MD5(handshake) + SHA1(handshake), label:sender, nb:12, version:version);
  }
  else if (version == TLS_12)
  {
    if(is_client)
      sender = "client finished";
    else
      sender = "server finished";

    var mac_fn = @SHA256;
    var mac = cipher_field(name:cipher_desc, field:"mac");
    if(mac == "SHA384")
      mac_fn = @SHA384;
    else if(mac == "SHA512")  #No TLS 1.2 ciphers exist with this MAC, but maybe in the future...
      mac_fn = @SHA512;

    finished = tls_prf(secret:master, seed:mac_fn(handshake), label:sender, nb:12, version:version, cipher_desc:cipher_desc);
  }

  return finished;
}

##
# Creates a TLS record
#
# @param [type:int]    record type
# @param [data:bytes]  record data
# @param [version:int] SSL/TLS encapsulation code
#
# @return [bytes|NULL] Returns an TLS record on success. Returns NULL if an error occurred.
##
function tls_mk_record(type, data, version)
{
  local_var rec, len;

  # default to TLS 1.0
  if(isnull(version)) version = TLS_10;

  if(version < TLS_10) return NULL;
  #if(isnull(data))     return NULL;

  return ssl_mk_record(type:type, data:data, version:version);

}

##
# Creates a SSL record,
#
# @param [type:int]    record type
# @param [data:bytes]  record data
# @param [version:int] SSL/TLS encapsulation code
#
# @return [bytes|NULL] Returns a TLS record on success. Returns NULL if an error occurred.
##
function ssl_mk_record(type, data, version)
{
  local_var rec, len;

  # default to SSL 3
  if(isnull(version)) version = SSL_V3;

  if(version < SSL_V3)
  {
    debug_print("ssl_mk_record() does not support SSL version 2 or below.\n");
    return NULL;
  }

  # allow empty records
  #if(isnull(data))     return NULL;

  version = mkbyte((version >>> 8) & 0xff) + mkbyte(version & 0xff);

  len = strlen(data);

  # max record size
  if(len > 16384) return NULL;

  len = mkbyte((len >>> 8) & 0xff) + mkbyte(len & 0xff);

  type = mkbyte(type);

  rec = type + version + len + data;

  return rec;
}

##
# Creates a TLS handshake message
#
# @param [type:int]   handshake message type
# @param [data:bytes] handshake message data
#
# @return [bytes|NULL] Returns a handshake message. Returns NULL if an error occurred.
##
function tls_mk_handshake_msg(type, data)
{
 return ssl_mk_handshake_msg(type:type, data:data);
}

##
# Creates a SSL handshake message
#
# @param [type:int]   handshake message type
# @param [data:bytes] handshake message data
#
# @return [bytes|NULL] Returns a handshake message. Returns NULL if an error occurred.
##
function ssl_mk_handshake_msg(type, data)
{
  local_var len, msg;

  #if(isnull(data)) return NULL;
  if(isnull(type)) return NULL;

  type = mkbyte(type);

  len = strlen(data);
  len = mkbyte((len >>> 16) & 0xff) + mkbyte((len >>> 8) & 0xff) + mkbyte(len & 0xff);

  msg = type + len + data;

  return msg;
}

##
# Reorders and filters certificate chains.
#
# Certificate chains should be ordered in ascending order from the
# lowest-level certificate which signs no others, then through
# intermediate CAs, ending with a root CA. This function sorts
# certificate chains to match that ordering, filtering out extraneous
# certificates in the process.
#
# @anonparam [first:bytes] The certificate chain, either parsed or raw.
#
# @param [filter:bool] If true (default) don't return unused certificates.
# @param [raw:bool]    If true (default) return certificates in raw format.
#
# @remark
#   If a chain of parsed certificates are passed in, the raw
#   parameter cannot be used.
#
# @return [array] The certificate chain in ascending order.
##
function sort_cert_chain(filter, raw)
{
  local_var bottom, ca, cert, certs, chain_arr, chain_str, found, i;
  local_var n, nonsigners, res, signed, sorted, top, unused, used;

  # Process arguments.
  chain_str = _FCT_ANON_ARGS[0];
  if (isnull(chain_str))
    return NULL;
  if (isnull(filter))
    filter = TRUE;
  if (isnull(raw))
    raw = TRUE;

  # Parse each certificate in the chain so that we can access their
  # fields to compare subjects and issuers.
  chain_arr = parse_cert_chain(chain_str);
  if (isnull(chain_arr))
    return NULL;

  # Since we can make no assumptions about what is in this chain, we
  # need to find the bottom of the chain by looking for certificates
  # that are not used to sign other certificates.
  bottom = NULL;

  for (i = 0; i < max_index(chain_arr); i++)
  {
    # Check if the certificate we're looking at has signed any of the
    # certificates in the chain, including itself.
    signed = FALSE;

    foreach cert (chain_arr)
    {
      if (is_signed_by(cert, chain_arr[i]))
      {
        signed = TRUE;
        break;
      }
    }

    # If the certificate hasn't signed any others, including itself,
    # it is a candidate for the bottom of the chain.
    if (!signed)
    {
      bottom = i;
      break;
    }
  }

  # If there was no bottom, it means that we either have a self-signed
  # certificate, or there is a signing loop of some sort.
  if (isnull(bottom))
  {
    for (i = 0; i < max_index(chain_arr); i++)
    {
      if (is_self_signed(chain_arr[i]))
      {
        bottom = i;
        break;
      }
    }

    # If there was no bottom, and no self-signed certs, we have a loop
    # which is something this function can't handle.
    if (isnull(bottom))
      return NULL;

    # The sorted chain will consist of only the self-signed certificate.
    sorted = make_list(bottom);
  }
  else
  {
    # Regardless of how many candidates there were for the bottom of
    # the chain, we've arbitrarily pick the first one we encountered
    # in the unsorted chain.
    n = 0;
    sorted = make_list();
    sorted[n++] = bottom;

    # From here on, we build up the rest of the chain by connecting
    # issuers to subjects. Theoretically a chain can branch and merge,
    # but we're only interested in a linear path, so we'll cut out
    # everything but the shortest path from the bottom cert to the
    # root CA.
    while (TRUE)
    {
      # Extract the issuer that we're looking for from the certificate
      # at the top of the current chain.
      top = sorted[n - 1];

      # Look for a certificate in the chain with a subject that
      # matches the issuer.
      i = find_issuer_idx(CA:chain_arr, cert:chain_arr[top]);

      # If the issuer is missing, it's considered as an unknown CA, so
      # we end the chain.
      if (i < 0)
        break;

      # A self-signed certificate will end the chain.
      if (i == top)
        break;

      # Add the issuer to the top of the sorted chain.
      sorted[n++] = i;
    }
  }

  # The caller either expects an array of parsed or unparsed certs.
  if (raw)
    certs = chain_str;
  else
    certs = chain_arr;

  # At this point we have the indexes of certificates that form the
  # sorted chain.
  n = 0;
  used = make_list();

  for (i = 0; i < max_index(sorted); i++)
  {
    used[n++] = certs[sorted[i]];
  }

  # Return only the certificates that are required to make a linear
  # chain.
  if (filter)
    return used;

  # If the caller requested unused certificates as well, we'll now
  # create an array for those.
  n = 0;
  unused = make_list();

  for (i = 0; i < max_index(certs); i++)
  {
    found = FALSE;

    foreach cert (sorted)
    {
      if (cert == i)
      {
        found = TRUE;
        break;
      }
    }

    if (!found)
      unused[n++] = certs[i];
  }

  # Return all the certificates.
  res = make_list();
  res[0] = used;
  res[1] = unused;

  return res;
}

##
# Gets the name associated with a TLS cipherspec code.
#
# @param [id:bytes]    The cipherspec code of a TLS cipher.
# @param [encaps:int]  A SSL/TLS encapsulation code.
# @param [pretty:bool] If TRUE formats the output with the name and code, otherwise just returns the name.
#
# @return [string|NULL] Returns a ciphersuite name on success, otherwise returns NULL.
##
function cipher_name(id, encaps, pretty)
{
  local_var cipher, i, len, name, type;

  # Sanity check parameters.
  if (isnull(id)) return NULL;

  # Set defaults.
  if (isnull(pretty)) pretty = FALSE;

  name = NULL;

  # Convert the cipher from whatever representation we were given to a
  # name.
  type = typeof(id);
  if (type == "int")
  {
    id = mkword(id);
  }
  else if (type == "data" || type == "string")
  {
    # All ciphers are represented by either two or three bytes.
    # Anything longer than that is probably already the name of a
    # cipher.
    len = strlen(id);
    if (len < 2) return NULL;
    if (len > 3) name = id;
  }
  else
  {
    return NULL;
  }

  # Try to match encapsulation to a similarly named cipher.
  #
  # Sometimes SSL and TLS use each other's ciphers. If we can't find a
  # matching cipher the first time, remove the name restrictions and
  # try again.
  for (i = 0; i < 2 && isnull(name); i++)
  {
    # Skip the phase of comparing cipher names to encapsulations if we
    # don't know what encapsulation is being used.
    if (i == 0 && isnull(encaps)) continue;

    foreach cipher (sort(keys(ciphers)))
    {
      # Skip ciphers that don't match transport.
      if (i == 0)
      {
        if (encaps == ENCAPS_SSLv2 && "SSL2_" >!< cipher) continue;
        if (encaps == ENCAPS_SSLv3 && "SSL3_" >!< cipher) continue;
        if (encaps == ENCAPS_TLSv1 && "TLS1_" >!< cipher) continue;
        if (encaps == COMPAT_ENCAPS_TLSv11 && cipher !~ "^TLS11?_") continue;
        if (encaps == COMPAT_ENCAPS_TLSv12 && cipher !~ "^TLS12?_") continue;
      }

      if (ciphers[cipher] == id)
      {
        name = cipher;
        break;
      }
    }
  }

  if (isnull(name)) name = "Unknown";

  if (pretty)
  {
    if (type != "int") id = ciphers[name];
    if (!isnull(id)) name += ' (0x' + hexstr(id) + ')';
  }

  return name;
}

###
# These are the relative strengths of ciphers, categorized by key
# length.
###
global_var CIPHER_STRENGTH_NULL, CIPHER_STRENGTH_LOW, CIPHER_STRENGTH_MEDIUM, CIPHER_STRENGTH_HIGH, CIPHER_STRENGTH_MAX;

CIPHER_STRENGTH_NULL   = 0; # = 0-bit key
CIPHER_STRENGTH_LOW    = 1; # <= 64-bit key
CIPHER_STRENGTH_MEDIUM = 2; # > 64-bit and < 112-bit key
CIPHER_STRENGTH_HIGH   = 3; # > 112-bit key
CIPHER_STRENGTH_MAX    = 4; # Unknown key

##
# Categorizes the strength of a cipher, using key length as a heuristic.
#
# @param [encaps:int]  A SSL/TLS encapsulation code.
#
# @anonparam [first:bytes] The cipherspec code of a TLS cipher.
#
# @return [int|null] Returns a constant representing the strength of the cipher, if successful.  Returns NULL otherwise.
##
function cipher_strength(encaps)
{
  local_var bits, desc, len, matches, name, enc;

  # Sanity check parameters.
  if (max_index(_FCT_ANON_ARGS) != 1)
    return NULL;

  # Get the name of the cipher, since that's the key for all the
  # cipher arrays.
  name = cipher_name(id:_FCT_ANON_ARGS[0], encaps:encaps);
  if (isnull(name))
    return NULL;


  # Get the text description of the cipher. If we can't find a
  # description for a cipher, we assume it's the maximum strength.
  desc = ciphers_desc[name];
  if (isnull(desc))
    return CIPHER_STRENGTH_MAX;

  enc = cipher_field(name:desc, field:"encrypt");
  if ("None" >< enc)
    return CIPHER_STRENGTH_NULL;

  if ("AES" >< enc)
    return CIPHER_STRENGTH_HIGH;

  # 3DES to Medium because of CVE-2016-2183.
  if ("3DES-CBC" >< enc)
  	return CIPHER_STRENGTH_MEDIUM;

  # Parse the key length from the description.
  matches = pregmatch(string:enc, pattern:"^[a-zA-Z0-9-]+\(([0-9]+\))$");
  if (isnull(matches))
    return CIPHER_STRENGTH_MAX;

  bits = int(matches[1]);

  if (bits == 0)
    return CIPHER_STRENGTH_NULL;

  if (bits <= 64)
    return CIPHER_STRENGTH_LOW;

  if (bits < 112)
    return CIPHER_STRENGTH_MEDIUM;

  return CIPHER_STRENGTH_HIGH;
}

##
# Compares the strength of two ciphers.
#
# @anonparam [first:bytes]  First TLS cipherspec to compare.
# @anonparam [second:bytes] Second TLS cipherspec to compare.
#
# @return [int|NULL] Returns a number indicating the relative strength of two ciphersuites.
#                    If an error occurs, returns NULL.
# @remark
# -1 (first is weaker), 0 (equal strength), or 1 (first is stronger).
##
function cipher_cmp()
{
  local_var c1, c2, s1, s2;

  # Sanity check parameters.
  if (max_index(_FCT_ANON_ARGS) != 2)
    return NULL;

  c1 = _FCT_ANON_ARGS[0];
  c2 = _FCT_ANON_ARGS[1];

  # Check if we're comparing a cipher to itself.
  if (c1 == c2)
    return 0;

  # Get the strength of each cipher.
  s1 = cipher_strength(c1);
  if (isnull(s1))
    return NULL;

  s2 = cipher_strength(c2);
  if (isnull(s2))
    return NULL;

  # Compare the strengths.
  if (s1 < s2)
    return -1;

  if (s1 > s2)
    return 1;

  return 0;
}

##
# Formats one line of plugin cipher report text.
#
# @param [fields:list] Cipher description items to format.
#
# @return [string] Returns the supplied ciphersuite description fields as a column aligned string.
##
function _make_cipher_report_line(fields)
{
  var col;
  var i = 0;
  var report = "";
  foreach var field (fields)
  {
    # Determine proper alignment for column.
    if (i == 0) col = 29;
    else if (i == 1) col = 16;
    else if (i == 3) col = 13;
    else if (i == 4) col = 8;
    else if (i == 5) col = 22;
    else col = 9;

    if (col < strlen(field))
      col = strlen(field);

    # Add column to report for this cipher.
    if (i != 2)
      report += field + crap(data:" ", length:col - strlen(field)) + " ";

    i++;
  }

  return chomp(report);
}


##
# Return a field from a Tenable SSL ciphersuite name.
#
# @param [name:string] The Tenable ciphersuite name.
# @param [field:string] Name of the field to retrieve. Valid names:
#                       "Name", "Kex", "Auth", "Encrypt", "MAC"
#
# @return [string] Returns the requested field if the ciphersuite name contains that field
#         and if the field name is correct.  Otherwise returns an empty string
##
function cipher_field(name, field)
{
  var fields = split(name, sep:"|", keep:FALSE);
  switch(tolower(field))
  {
    case "name":
      return fields[0];
    case "kex":
      return fields[2];
    case "auth":
      return fields[3];
    case "encrypt":
      return fields[4];
    case "mac":
      return fields[5];
  }

  return "";
}

##
# Create a report of the selected ciphers.
#
# @param [desc:string] Only report on ciphers whose description matches regex
# @param [field:string] Name of the field to retrieve. Valid names:
#                       "Name", "Kex", "Auth", "Encrypt", "MAC"
# @param [eq:int] Only report on ciphers equal to this strength
# @param [max:int] Only report on ciphers less than this strength
# @param [min:int] Only report on ciphers greater than this strength
# @param [name:string] Only report on ciphers whose name matches regex
#
# @anonparam [ciphers:list] Ciphers to process
#
# @return [string|NULL] Returns a formatted report of the selected ciphers.  If an error occurs, returns NULL.
##
function cipher_report(desc, field, eq, max, min, name)
{
  local_var cipher, fields, labels, list;
  local_var report, reports, strength, header, col_headers;
  local_var code_text, code_hex, col_spacers;

  col_headers = [
    'Name',
    'Code',
    '',            # Protocol - not reported
    'KEX',
    'Auth',
    'Encryption',
    'MAC'
  ];

  col_spacers = [
    '----------------------',
    '----------',
    '',            # Protocol - not reported
    '---',
    '----',
    '---------------------',
    '---'
  ];

  header = '    ' + _make_cipher_report_line(fields:col_headers) + '\n';
  header += '    ' + _make_cipher_report_line(fields:col_spacers) + '\n';

  # Sanity check parameters.
  if (max_index(_FCT_ANON_ARGS) != 1)
    return NULL;

  # Don't allow duplicate ciphers in the list to bubble up through to
  # the report.
  list = list_uniq(_FCT_ANON_ARGS[0]);

  # Format and categorize ciphers.
  reports = make_array();
  foreach cipher (sort(list))
  {
    # Find the strength of the cipher.
    strength = cipher_strength(cipher);
    if (isnull(strength))
      continue;

    # Filter based on the regex, if given.
    if (!isnull(desc))
    {
      if(isnull(field) && ciphers_desc[cipher] !~ desc)
        continue;
      else if(cipher_field(name:ciphers_desc[cipher], field:field) !~ desc)
        continue;
    }

    if (!isnull(name) && cipher !~ name)
      continue;

    # Filter the cipher if it's outside our bounds.
    if (!isnull(eq) && strength != eq)
      continue;

    if (!isnull(min) && strength < min)
      continue;

    if (!isnull(max) && strength > max)
      continue;

    # Initialize the report for ciphers of this strength.
    if (isnull(reports[strength]))
      reports[strength] = "";

    # We don't have descriptions for maximum strength ciphers.
    if (strength == CIPHER_STRENGTH_MAX)
    {
      reports[strength] += '    ' + cipher + '\n';
      continue;
    }

    # Extract fields from cipher's description.
    fields = split(ciphers_desc[cipher], sep:"|", keep:FALSE);

    # Make cipher ID text
    code_text = '';
    code_hex = ciphers[cipher];
    for(var i = 0; i < strlen(code_hex); i ++)
    {
      if(i > 0) code_text += ', ';
      code_text += '0x' + toupper(hexstr(code_hex[i]));
    }
    insert_element(idx:1, value:code_text, var:fields);

    report = _make_cipher_report_line(fields:fields);
    reports[strength] += '    ' + report + '\n';
  }

  # Skip generating a report if no ciphers matched our conditions.
  if (max_index(keys(reports)) == 0)
    return NULL;

  # Flatten the report.
  labels = make_array(
    CIPHER_STRENGTH_NULL, "Null Ciphers (no encryption)",
    CIPHER_STRENGTH_LOW, "Low Strength Ciphers (<= 64-bit key)",
    CIPHER_STRENGTH_MEDIUM, "Medium Strength Ciphers (> 64-bit and < 112-bit key, or 3DES)",
    CIPHER_STRENGTH_HIGH, "High Strength Ciphers (>= 112-bit key)",
    CIPHER_STRENGTH_MAX, "Unrecognized Ciphers"
  );

  report = "";
  foreach strength (sort(keys(reports)))
  {
    # Add the label for ciphers of a certain strength.
    report += '  ' + labels[strength] + '\n\n';
    report += header;
    if (!isnull(reports[strength]))
      report += reports[strength] + '\n';
  }

  # Generate report.
  return
    '\n' + report +
    'The fields above are :' +
    '\n' +
    '\n  {Tenable ciphername}' +
    '\n  {Cipher ID code}' +
    '\n  Kex={key exchange}' +
    '\n  Auth={authentication}' +
    '\n  Encrypt={symmetric encryption method}' +
    '\n  MAC={message authentication code}' +
    '\n  {export flag}' +
    '\n';
}

##
# Converts a raw certificate to PEM format.
#
# @anonparam [first:bytes] The raw certificate.
#
# @return [string] The certificate in PEM format.
##
function blob_to_pem()
{
  local_var cert;

  # Sanity check parameters.
  if (max_index(_FCT_ANON_ARGS) != 1)
    return NULL;

  cert = _FCT_ANON_ARGS[0];

  return
    '-----BEGIN CERTIFICATE-----\n' +
    ereg_replace(
      string  : base64(str:cert),
      pattern : "(.{1,64})",
      replace : '\\1\n'
    ) +
    '-----END CERTIFICATE-----\n';
}

##
# Converts a PEM certificate to raw format.
#
# @anonparam [first:string] The PEM certificate.
#
# @return [bytes] Returns the raw certificate on success; returns NULL otherwise.
##
function pem_to_blob()
{
  local_var blob, cert, line;

  # Sanity check parameters.
  if (max_index(_FCT_ANON_ARGS) != 1)
    return NULL;

  blob = _FCT_ANON_ARGS[0];

  cert = "";
  foreach line (split(blob, keep:FALSE))
  {
    if (line !~ "^-+(BEGIN|END) CERTIFICATE-+$")
      cert += line;
  }

  return base64_decode(str:cert);
}

##
# Formats certificates to be suitable for reports.
#
# @anonparam [first:list] The certificates to be included in the report.
#
# @param [chain:bool] Whether the report represents a certificate chain, true by default.
# @param [bar:string] prefix displayed before attributes in report, '|-' by default
#
# @return [string|NULL] Returns the formatted certificate report on success; returns NULL otherwise.
##
function cert_report(chain, bar)
{
  local_var certs, i, len, line, report;

  # Sanity check parameters.
  if (max_index(_FCT_ANON_ARGS) != 1)
    return NULL;

  # Set defaults.
  if (isnull(chain))
    chain = TRUE;

  certs = _FCT_ANON_ARGS[0];

  if (isnull(bar))
    bar = "|-";
  report = "";
  len = max_index(certs);

  # Walk the chain from the top downwards.
  for (i = len - 1; i >= 0; i--)
  {
    # Format each of the certificate's attributes.
    foreach line (split(certs[i]))
    {
      # Skip blank lines.
      if (line =~ "^ *$")
        continue;

      report += ereg_replace(string:line, pattern:"^", replace:bar);
    }

    if (chain)
      bar += "-";

    if (i != 0)
    {
      if (chain)
        report += "|";
      report += '\n';
    }
  }

  return report;
}

##
# Opens a socket for SSL communication.
#
# This function will open a raw TCP connection to the given port. If
# the port supports StartTLS, the proper command(s) will be given to
# bring the socket to the point at which SSL negotiation is possible.
# If an encapsulation method is declared, that encapsulation method
# will be negotiated. Otherwise, the raw socket will be returned.
#
# @anonparam [first:int] The TCP port to attempt connecting to.
#
# @param [encaps:int] A SSL/TLS encapsulation code.
#
# @return [int|NULL] On success returns the opened socket; returns NULL otherwise.
##
function open_sock_ssl(encaps)
{
  local_var key, port, ret, soc, starttls, svc;
  local_var fn = "open_sock_ssl";

  # Sanity check parameters.
  if (max_index(_FCT_ANON_ARGS) != 1)
    return NULL;

  port = _FCT_ANON_ARGS[0];

  # Open a socket, explicitly stating that we don't want Nessus to
  # negotiate SSL.
  soc = open_sock_tcp(port, transport:ENCAPS_IP);
  if (!soc)
  {
    ssl_dbg(src:fn, msg:'Failed to open socket on port '+port+'.');
    return NULL;
  }
  ssl_dbg(src:fn, msg:'Opened socket '+soc+' on port '+port+'.');
  # Check if this port is StartTLS.
  key = "/" + port + "/starttls";
  starttls = get_kb_list("*" + key);

  # If the port is straight SSL/TLS, perform the negotiation if we
  # were asked to by the caller.
  if (isnull(starttls))
  {
    if (isnull(encaps) || encaps == ENCAPS_IP)
    {
      ssl_dbg(src:fn, msg:'Encapsulation not specified, returning '+
        'socket '+soc+' for negotiation.');
      return soc;
    }

    if (!defined_func("socket_negotiate_ssl"))
      return NULL;

    ssl_dbg(src:fn, msg:'Returning socket_negotiate_ssl(socket:'+
      soc+', transport:'+encaps+') ('+ENCAPS_NAMES[encaps]+').');
    return socket_negotiate_ssl(socket:soc, transport:encaps);
  }

  # If there is more than one service declared on this port, we have
  # no way to decide what kind of StartTLS command to send, so fail.
  starttls = keys(starttls);
  if (max_index(starttls) > 1)
  {
    ssl_dbg(src:fn, msg:'More than one service is declared on this '+
      'port, unable to determine which StartTLS command to send.');
    return NULL;
  }

  # Extract the service name and send the proper StartTLS commands.
  ret = NULL;
  svc = starttls[0] - key;
  ssl_dbg(src:fn, msg:'Service "'+svc+'" on port '+port+' supports '+
    'StartTLS, calling function to handle StartTLS command.');
  if (svc == "acap")
    ret = acap_starttls(socket:soc, encaps:encaps);
  else if (svc == "amqp")
    ret = amqp_starttls(socket:soc, encaps:encaps);
  else if (svc == "ftp")
    ret = ftp_starttls(socket:soc, encaps:encaps);
  else if (svc == "imap")
    ret = imap_starttls(socket:soc, encaps:encaps);
  else if (svc == "ldap")
  {
    ldap_init(socket:soc);
    ret = ldap_starttls();
  }
  else if (svc == "mssql")
    ret = mssql_starttls(socket:soc, encaps:encaps);
  else if (svc == "nntp")
    ret = nntp_starttls(socket:soc, encaps:encaps);
  else if (svc == "nut")
    ret = nut_starttls(socket:soc, encaps:encaps);
  else if (svc == "pop3")
    ret = pop3_starttls(socket:soc, encaps:encaps);
  else if (svc == "rdp")
    ret = rdp_starttls(socket:soc, encaps:encaps);
  else if (svc == "smtp")
    ret = smtp_starttls(socket:soc, encaps:encaps);
  else if (svc == "telnet")
    ret = telnet_starttls(socket:soc, encaps:encaps);
  else if (svc == "xmpp")
    ret = xmpp_starttls(socket:soc, encaps:encaps);
  else if (svc == "irc")
    ret = ircd_starttls(socket:soc, encaps:encaps);
  else if (svc == "postgresql")
    ret = postgresql_starttls(socket:soc, encaps:encaps);
  else if (svc == "vmware902")
    ret = vmware_902_starttls(socket:soc, encaps:encaps);
  else if (svc == "rsyncd")
  {
    rsync_init(socket:soc);
    ret = rsync_starttls(socket:soc, encaps:encaps);
  }
  # Service not supported
  else
  {
    ssl_dbg(src:fn, msg:'Service "'+svc+'" on port '+port+' is not '+
      'currently supported for StartTLS, closing socket.');
    close(soc);
    return NULL;
  }

  if (!ret)
  {
    # If socket_negotiate_ssl() fails, the underlying TCP socket is
    # closed automatically, so no need to close the socket if
    # xxx_starttls() is instructed to call socket_negotiate_ssl() via
    # the encaps param.
    ssl_dbg(src:fn, msg:'StartTLS failed for service "'+svc+
      '" on port '+port+'.');
    if (!encaps)
    {
      ssl_dbg(src:fn, msg:'Closing socket '+soc+'.');
      close(soc);
    }
  }

  ssl_dbg(src:fn, msg:'Returning: '+ret+'\n');
  return ret;
}

##
# Find all ports that support TLS or DTLS, either directly or
# with StartTLS.
#
# @param [fork:bool]       Forks if TRUE, once per port per protocol.
# @param [ssl:bool]        Include SSL ports, true by default.
# @param [dtls:bool]       Include DTLS ports, false by default.
# @param [starttls:bool]   Include StartTLS ports, true by default.
# @param [check_port:bool] Checks if port is open, audits on close if forking.
# @param [ciphers:bool]    Retrieves ciphers if TRUE
#
# @return [list|NULL] Returns a list of [port, proto] tuples if successful.  Returns NULL on error.
# @remark
#   For the return value tuples proto is "tls" or "dtls".  If fork is TRUE, then one tuple
#   is returned per forked branch.
##
function get_tls_dtls_ports(fork, ssl, dtls, starttls, check_port, ciphers)
{
  var ports = get_ssl_ports(fork:FALSE, ssl:ssl, dtls:dtls, starttls:starttls);

  # Set defaults.
  if (isnull(fork))
    fork = FALSE;

  if (isnull(ports))
    return NULL;

  if (isnull(check_port))
    check_port = FALSE;

  if (isnull(ciphers))
    ciphers = FALSE;

  if(typeof_ex(ports) != "list")
    ports = [ports];

  var port_proto = [];

  foreach var port(ports)
  {
    var pval = {"port" : port};
    var dtls_proto = get_kb_item("Transports/UDP/" + port);
    if(!isnull(dtls_proto) && dtls_proto > ENCAPS_IP)
    {
      if(check_port && !fork && !get_udp_port_state(port))
        continue;

      pval["proto"] = "dtls";
      pval["l4_proto"] = "UDP";
      if(ciphers)
        pval["ciphers"] = get_kb_list("DTLS/Ciphers/" + port);

      append_element(var:port_proto, value:pval);
    }

    var tls_proto = get_kb_item("Transports/TCP/" + port);
    if(!isnull(tls_proto) && tls_proto > ENCAPS_IP)
    {
      if(check_port && !fork && !get_port_state(port))
        continue;

      pval["proto"] = "tls";
      pval["l4_proto"] = "TCP";
      if(ciphers)
        pval["ciphers"] = get_kb_list("SSL/Ciphers/" + port);

      append_element(var:port_proto, value:pval);
    }

  }

  #Fork if one port number is hosting both TLS and DTLS services.
  #UDP and TCP port numbers represent distinct ports.
  var result = branch(port_proto, fork:fork);

  if(check_port && fork)
  {
    if(result["proto"] == "tls" && !get_port_state(result["port"]))
      audit(AUDIT_PORT_CLOSED, result["port"]);

    if(result["proto"] == "dtls" && !get_udp_port_state(result["port"]))
      audit(AUDIT_PORT_CLOSED, result["port"]);
  }

  return result;
}


##
# Find all ports that support SSL, either directly or with StartTLS.
#
# @param [fork:bool]     Whether we should fork and return one port per child, false by default.
# @param [ssl:bool]      Include SSL ports, true by default.
# @param [dtls:bool]     Include DTLS ports, false by default.
# @param [starttls:bool] Include StartTLS ports, true by default.
#
# @return [list] A list of ports supporting SSL.
##
function get_ssl_ports(fork, ssl, dtls, starttls)
{
  local_var key, list, port, ports;

  # Set defaults.
  if (isnull(fork))
    fork = FALSE;

  if (isnull(dtls))
    dtls = FALSE;

  if (isnull(ssl))
    ssl = TRUE;

  if (isnull(starttls))
    starttls = TRUE;

  # Sanity check parameters.
  if (!ssl && !starttls && !dtls)
    return NULL;

  ports = make_list();

  # Get list of ports that use DTLS. Do this before SSL because add_port_in_list
  # checks the TCP port state.
  if (dtls)
  {
    list = get_kb_list("Transport/DTLS");
    if (!isnull(list))
      ports = make_list(list);
  }

  # Get list of ports that use SSL.
  if (ssl)
  {
    list = get_kb_list("Transport/SSL");
    if (!isnull(list))
    {
      list = make_list(list);
      foreach var p (list)
        ports = add_port_in_list(list:ports, port:p);
    }
  }

  if (!starttls)
    return branch(ports, fork:fork);

  # Get list of ports that use StartTLS.
  list = get_kb_list("*/*/starttls");
  if (isnull(list))
    return branch(ports, fork:fork);

  foreach key (keys(list))
  {
    # Extract port from KB item name.
    port = split(key, sep:"/", keep:FALSE);
    port = int(port[1]);

    # Ignore invalid ports.
    if (port < 1 || port > 65535)
      continue;

    ports = add_port_in_list(list:ports, port:port);
  }

  return branch(ports, fork:fork);
}

##
# Parse a list of certificates.
#
# @param [chain:list] Certificates to parse.
#
# @remark
#   This function will correctly handle lists containing both
#   unparsed (data or string) and parsed (array) elements.
#
# @return [list|NULL] On success returns a list of parsed certificates.  On error returns NULL.
##
function parse_cert_chain()
{
  local_var chain, i, parsed, raw;

  # Sanity check parameters.
  if (max_index(_FCT_ANON_ARGS) != 1)
    return NULL;

  chain = _FCT_ANON_ARGS[0];

  for (i = 0; i < max_index(chain); i++)
  {
    raw = chain[i];

    # Skip parsed certs.
    if (typeof(raw) == "array")
      continue;

    # Parse raw certificate.
    parsed = parse_der_cert(cert:raw);
    if (isnull(parsed))
      return NULL;
    parsed["raw"] = raw;

    # Replace raw cert with parsed cert.
    chain[i] = parsed;
  }

  return chain;
}

##
# Versions before 6.4
# Return versions TLSv1 when SSL is enabled
# Return ENCAPS_IP when SSL is disabled
#
# Version 6.4 and later
# Prepares SSL transport using all TLS versions
# and disabling SSLv3 and lower when SSL is enabled.
# ENCAPS_SSLv23 # enable all versions of SSL
# ENCAPS_DISABLE_SSLv3 # disable all below SSLv3
# ENCAPS_IP = TCP when SSL is disabled
#
# @param [ssl:bool]    Sets SSL flag, default TRUE.
# @param [verify:bool] Sets verification flag, default FALSE.
#
# @return [int] Transport flags for the connection.
##
function ssl_transport(ssl, verify)
{
  if (isnull(ssl))
    ssl = TRUE;

  if (isnull(verify))
    verify = FALSE;

  if (!ssl)
    return ENCAPS_IP;

  if (nasl_level() < 6400)
  {
    if (!verify)
      return ENCAPS_TLSv1;

    return ENCAPS_TLSv1 | ENCAPS_VERIFY_PEER;
  }
  else
  {
    if (!verify)
      return ENCAPS_SSLv23 | COMPAT_ENCAPS_DISABLE_SSLv3;

    return ENCAPS_SSLv23 | COMPAT_ENCAPS_DISABLE_SSLv3 | ENCAPS_VERIFY_PEER;
  }
}

##
# Creates a TLS extension
#
# @param [type:int] Extension type
# @param [len:int]  Extension len, defaulted to strlen(data)
# @param [data:bytes] Extension data
#
# @return [bytes] Formatted TLS extension
##
function tls_ext(type, len, data)
{
  local_var ext;

  if(isnull(len))
    len = strlen(data);

  ext = raw_string((type >> 8) & 0xff, type & 0xff) +
        raw_string((len >> 8) & 0xff, len & 0xff) +
        data;

  return ext;
}

##
# Create a TLSv1.2 Signature Algorithm Extension
#
# @anonparam [first:list] signature algorithms
# @return [bytes] a formatted Signature Algorithm TLSv1.2 extension
# @remark
#   if the algorithm list is not specified, a default list is used.
##
function tls_ext_sig_algs()
{
  local_var ext, list, hash;

  list = _FCT_ANON_ARGS[0];
  if(isnull(list))
  {
    list = make_list(
      0x0201,
      0x0203,
      0x0202,
      0x0401,
      0x0403,
      0x0501,
      0x0503,
      0x0601,
      0x0603
    );
  }
  foreach hash (list)
    ext += raw_string((hash >> 8) & 0xff, hash & 0xff);

  ext = ssl_vldata_put(data:ext, len:2);

  return tls_ext(type:13, data:ext);
}

##
# Creates a elliptic_curves TLS extension
#
# @anonparam [first:list] named elliptic curves
#
# @return [bytes] a formatted elliptic_curves TLS extension
# @remark
#   if the curve list is not specified, a default list is used.
##
function tls_ext_ec()
{
  local_var curve, ext, list;

  list = _FCT_ANON_ARGS[0];

  if(isnull(list))
  {
    # See TLS IANA registry for the most recent list
    list = make_list(
                      1, 2, 3, 4, 5, 6, 7, 8,
                      9, 10, 11, 12, 13, 14, 15, 16,
                      17, 18, 19, 20, 21, 22, 23, 24,
                      25, 26, 27, 28,
                      0xFF01, 0xFF02
                    );
  }

  ext = NULL;
  foreach curve (list)
  {
    ext += raw_string((curve >> 8) & 0xff, curve & 0xff);
  }

  # Encode EllipticCurveList
  #      struct {
  #          NamedCurve elliptic_curve_list<1..2^16-1>
  #      } EllipticCurveList;
  ext = ssl_vldata_put(data:ext, len:2);


  return tls_ext(type: 10, data: ext);
}

##
# Creates a ec_point_formats TLS extension
#
# @anonparam [first:list] named elliptic curves
# @return [bytes] a formatted ec_point_formats TLS extension
# @remark
#   if the format list is not specified, a default list is used.
##
function tls_ext_ec_pt_fmt()
{
  local_var fmt, ext, list;

  list = _FCT_ANON_ARGS[0];

  if(isnull(list))
  {
    # See TLS IANA registry for the most recent list
    list = make_list(0, 1, 2);
  }

  ext = NULL;
  foreach fmt (list)
  {
    ext += raw_string(fmt);
  }

  # Encode ECPointFormatList
  #        struct {
  #          ECPointFormat ec_point_format_list<1..2^8-1>
  #      } ECPointFormatList;
  ext = ssl_vldata_put(data:ext, len:1);


  return tls_ext(type: 11, data: ext);
}

##
# Determines whether a cipher suite uses Elliptic Curve Cryptography
#
# @anonparam [first:string] cipher suite name
# @return [bool] TRUE/FALSE
#
##
function tls_is_ec_cipher()
{
  local_var cipher;

  cipher = _FCT_ANON_ARGS[0];

  if('_EC' >< cipher) return TRUE;

  return FALSE;
}

##
# Creates a TLS Server Name Indication extension.
# See RFC 6066 section 3.
#
# @param [hostname:string] The hostname or FQDN of the target
# @return [bytes] The extension data, in TLS wire format.
# @remark
#   Can be passed directly to client_hello's "exts" parameter.
##
function tls_ext_sni(hostname)
{
  local_var servername;

  # RFC 6066
  # 00XXXX[host string]
  # 00 specifies host_name type
  # XXXX is length of host string
  servername = mkbyte(0) + mkword(strlen(hostname)) + hostname;

  # 0000XXXXYYYY[servername string]
  # 0000 specifies server_name (SNI) extension type
  # XXXX is the total length (length of YYYY and servername string)
  # YYYY is the length of the servername list (servername string)
  return mkword(0) + mkword(strlen(servername) + 2) + mkword(strlen(servername)) + servername;
}

##
# Creates a TLS 1.3 supported versions extension advertising support for only TLS 1.3
#
# @return [bytes] The extension data.
##
function tls_ext_sv_tls13()
{
  local_var ext;
  ext = raw_string(0x02, 0x03, 0x04);
  return tls_ext(type:0x2b, data:ext);
}

##
# Creates a TLS 1.3 key share extension.
#
# @param [public_keys:array] An array with key exchange codes as keys and raw public keys as values.
#
# @return [bytes] The key share extension data.
##
function tls_ext_key_share(public_keys)
{
  local_var ext, group, key;

  ext = "";
  foreach group (keys(public_keys))
  {
    key = public_keys[group];
    ext += mkword(group) + mkword(strlen(key)) + key;
  }

  ext = mkword(strlen(ext)) + ext;

  return tls_ext(type:0x33, data:ext);
}

##
# Creates a TLS 1.3 pre-shared key exchange modes extension advertising support only for Diffie-Hellman.
#
# @return [bytes] Returns the extension data.
##
function tls_ext_psk_key_exchange_modes()
{
  local_var ext;
  ext = raw_string(1,1);
  return tls_ext(type:0x2d, data:ext);
}

##
# Creates a TLS 1.3 application layer protocol negotiation extension.
#
# @anonparam [first:list] A list of protocol strings.
#
# @return [bytes] Returns the extension data.
# @remark
# Valid protocol strings are described in https://datatracker.ietf.org/doc/html/rfc7301 and
# other standards that update the IANA "ExtensionType Values" registry.  Some include:
#     "http/1.1"
#     "spdy/1"
#     "spdy/2"
#     "spdy/3"
#     "h3"
##
function tls_ext_alpn()
{
  var proto;
  var encoded_protos = '';
  var supported_protos = _FCT_ANON_ARGS[0];
  if(empty_or_null(supported_protos))
    return '';

  foreach proto (supported_protos)
    encoded_protos += mkbyte(strlen(proto)) + proto;

  encoded_protos = mkword(strlen(encoded_protos)) + encoded_protos;
  return tls_ext(type:0x10, data:encoded_protos);
}

##########################################################################
# RSASSA-PSS signature validation
##########################################################################
##
# Integer to Octet String. Encodes an integer as a base256 string (compatible
# with our `bn_` functions), padding with zeroes as needed. This is part of the
# spec of MGF1 as used in RSASSA-PSS.
#
# @param [x:int]    A NASL integer, to be encoded.
# @param [xlen:int] The length of the resulting string.
#
# @return [bytes|NULL] An integer encoded as base256 string padded with zeros to xlen, or NULL on error.
# @remark
# Tested with defaults: SHA1, MGF1 with SHA1, 20-byte salt, Trailer = \xBC
##
function rsa_pss_i2osp(x, xlen)
{
  x = bn_dec2raw(x);
  if (isnull(xlen))
    return x;

  # xlen is both used for padding and also as a "maximum length" check.
  if (xlen < strlen(x))
    return NULL;

  return crap(data:'\x00', length:xlen - strlen(x)) + x;
}

##
# The default (and only at the time of this writing) Mask Generation Function
# specified for use with RSASSA-PSS. Is pluggable to use a different hash
# function.
#
# @param [seed:string]  The salt from the signature, referred to (confusingly) as a 'seed' when defining MGF1.
# @param [masklen:int]  The length of the mask to generate, in bytes.
# @param [hash:funcref] The hash function to use.
#
# @return [string] The generated mask bytes.
##
function rsa_pss_mgf1(seed, masklen, hash)
{
  local_var hlen, c, t, i;
  hlen = strlen(hash(""));

  # This is the name in the spec. This is the mask as we build it up.
  t = "";
  for (i = 0; i < (masklen / hlen) + 1; ++i)
  {
    c = rsa_pss_i2osp(x:i, xlen:4);
    t += hash(seed + c);
  }
  return substr(t, 0, masklen - 1);
}

##
# Decrypts a signature to an EM ("Encoded Message") for later verification.
#
# @param [sig:bytes] The signature of the message, in base256 encoding. Must be the same length as the modulus.
# @param [e:bytes]   The exponent used when signing the original message, in base256 encoding
# @param [n:bytes]   The modulus of the signer's public key, in base256 encoding.
#
# @return [bytes|NULL] If successful, the "Encoded Message", otherwise NULL.
# @remark
# Signature verification uses rsa_pss_emsa_verify() instead of rsa_public_decrypt() because that function
# assumes PKCS#1 v1.5 padding which is not present here.
##
function rsa_pss_decrypt_em(sig, e, n)
{
  local_var em;

  if (isnull(n) || isnull(e) || isnull(sig))
    return NULL;

  if (strlen(n) != strlen(sig))
    return NULL;

  em = bn_mod_exp(sig, e, n);
  if (isnull(em))
    return NULL;

  return em;
}

##
# Implements OpenSSL's "BN_num_bits". Returns the number of bits required to represent the number 'n'.
#
# @param [n:bytes]  A bignum, usually an RSA public key modulus 'n'
#
# @return [int|NULL] On success, returns the number of bits required to represent 'n', otherwise returns NULL.
##
function num_bits(n)
{
  local_var i, bits;

  if (isnull(n))
    return NULL;

  # This will take out any unnecessary zero bytes
  n = bn_hex2raw(bn_raw2hex(n));

  bits = strlen(n) * 8;

  # Figure out how many most-significant bits are zero
  for (i = 7; i > 0; i--)
  {
    # If this bit is set, we've hit the first significant bit
    if (ord(n[0]) & (1 << i))
      break;
    else
      # This bit is not set, so we don't need that bit to represent 'n'
      bits--;
  }
  return bits;
}

##
# Performs EMSA-PSS verification.
#
# @param [msg:bytes]       The message we are checking the integrity of
# @param [em:bytes]        "Encoded Message", the result of RSA-decrypting the signature
# @param [embits:int]      The number of significant bits in the modulus
# @param [hash:funcref]    A hash function to use for hashing the message. Defaults to SHA1. -optional
# @param [mgf:funcref]     A Mask Generation Function. Defaults to MGF1. -optional
# @param [mgfhash:funcref] The hash function that the MGF should use. Defaults to `hash`. -optional
# @param [slen:int]        The length of the salt. Defaults to the length of `hash`. -optional
# @param [tf:bytes]        The trailer field. Defaults to '\xBC'. -optional
#
# @return [bool] Returns TRUE if the verification succeeded, FALSE otherwise.
#
# @remark
# http://tools.ietf.org/html/rfc3447#section-9.1.2
# All variable names and verbiage is taken directly from the RFC.  All variable
# names are lower-cased for consistency with our coding practices, however.
#
# @remark
# You must decrypt the signature first via `rsa_pss_decrypt_em` to obtain the
# EM (Encoded Message), which is then verified against the original message.
#
# @remark
# RSASSA-PSS has many configuration parameters: the hash function for
# fingerprinting messages, the "Mask Generation Function" (and its underlying
# hash function), the length of the random salt, and the "trailer field".
# There is one very common set of parameters used in the wild (the defaults
# from the standard); those are used as defaults here.
##
function rsa_pss_emsa_verify(msg, em, embits, hash, mgf, mgfhash, slen, tf)
{
  local_var mhash, hlen, emlen, leftmost, maskeddb, dbmask, db, h, hprime, salt, i;

  if (isnull(msg) || isnull(em))
    return FALSE;

  # The default from RFC 4055 and what OpenSSL chooses.
  if (isnull(hash))
    hash = @SHA1;

  # We boldy assume that all other MGF algorithms will let you to choose your
  # own hash algorithm, like MGF1 does.
  # This means any NASL implementation of a future MGF will need to accept a
  # "hash" function reference like rsa_pss_mgf1 does. If this doesn't make
  # sense in the future, do not hesitate to change this.
  if (isnull(mgf))
    mgf = @rsa_pss_mgf1;
  # It's recommended by RFC 4055 that MGF hash and message hash be the same.
  if (isnull(mgfhash))
    mgfhash = hash;

  # RFC 4055 recommends the salt length be equal to the digest length of the
  # chosen hash function
  if (isnull(slen))
    slen = strlen(hash(""));

  # The only value specifically mentioned in the standard, and the default
  # value that OpenSSL uses.
  if (isnull(tf))
    tf = '\xBC';

  mhash = hash(msg);
  hlen = strlen(hash(""));
  emlen = strlen(em);

  # Step 3: Ensure the EM is long enough. This is directly from the standard.
  if (emlen < hlen + slen + 2)
    return FALSE;

  # Step 4: Ensure the byte at the end of the EM is '\xBC'.
  if (em[emlen - 1] != tf)
    return FALSE;

  # Step 5: extract the hash and the "masked DB"
  maskeddb = substr(em, 0, emlen - hlen - 2);
  h = substr(em, emlen - hlen - 1, emlen - 2);

  # Step 6: Check that a few of the leftmost bits of maskeddb are all zero
  if (ord(maskeddb[0]) & (0xFF << (8 - ((emlen * 8) - embits))) != 0)
    return FALSE;

  # Step 7 and 8
  dbmask = mgf(seed:h, masklen:strlen(maskeddb), hash:mgfhash);
  db = xor(in1:maskeddb, in2:dbmask);

  # Step 9: The few bits that we checked were zero before masking, set them to zero
  db[0] = mkbyte(ord(db[0]) & (0xFF >> ((emlen * 8) - embits)));

  # Step 10: Check that all the non-salt bytes and non-pad bytes are zero,
  # and that the salt padding byte is one.
  # \x00\x00...\x00\x01[salt]
  leftmost = substr(db, 0, emlen - hlen - slen - 3);
  for (i = 0; i < strlen(leftmost); ++i)
  {
    if (leftmost[i] != '\x00')
      return FALSE;
  }
  if (db[emlen - hlen - slen - 2] != '\x01')
    return FALSE;

  # Step 11
  salt = substr(db, strlen(db) - slen, strlen(db));

  # Step 12 and 13
  # The leading 8 zero bytes is "padding1" from the documentation.
  hprime = hash(crap(data:'\x00', length:8) + mhash + salt);

  # Step 14: Final verification
  if (hprime != h)
    return FALSE;

  return TRUE;
}

##
# Debugging template for SSL functions and plugins. Formats debugging
# message and forwards to spad_log() via dbg::log(). Includes pid
# (and ppid if provided) to help troubleshoot STARTTLS functions.
#
# @param [src:string] The message source, e.g. "mssql_starttls" or
#                     "ssl_supported_ciphers.nasl"
# @param [msg:string] The message to log
# @param [ddata:data] The data to dump to hex/ascii and append
# @param [ppid:int]   The PID of the parent process (optional)
# @param [face:string] For STARTTLS functions, the direction the
#                      socket is facing. "p" for parent-facing,
#                      "t" for target-facing. Adds label to message.
# @param [lvl:int]    The debug log level. Optional: defaults to 1
#                     for messages and 3 for ddata.
#
# @return [NULL] Returns NULL.
##
function ssl_dbg(src, msg, ddata, ppid, face, lvl)
{
  if (!get_kb_item("global_settings/enable_plugin_debugging"))
    return NULL;

  if (isnull(lvl) || typeof(lvl) != "int")
    lvl = 1;

  # Start with pid
  var out = "(pid "+getpid()+") ";

  # Add parent pid, if provided
  if (ppid) out += "(ppid "+ppid+") ";

  # Add socket-facing direction (for starttls)
  if (face == "p") out += "Parent-facing: ";
  else if (face == "t") out += "Target-facing: ";

  # Add message and log
  out += msg;
  if(empty_or_null(ddata))
    return dbg::detailed_log(src:src, msg:out, lvl:lvl);

  return dbg::detailed_log(src:src, msg:out, lvl:lvl, msg_details:{"Data":{"lvl":3, "value":ddata}});
}

##
# Converts a DTLS record version to its TLS counterpart
#
# @param [dtlsver:word] The DTLS version number.
#
# @return [int] Returns the TLS record version counterpart.
##
function convert_dtls_ver_to_tls_ver(dtlsver)
{
  if(dtlsver == DTLS_10)
      return TLS_11;
  else if(dtlsver == DTLS_12)
      return TLS_12;

  #Let the input argument pass through if it is invalid.
  return dtlsver;
}
