##
# (C) Tenable Network Security, Inc.
#
# This script is released under one of the Tenable Script Licenses and may not
# be used from within scripts released under another license without the
# authorization from Tenable Network Security Inc.
#
#
# @NOGPL@
#
# cql_rows_kind_decoder.inc
#
# Revision: 1.3
#
# @include cql_binary_decoder.inc
# @include byte_func.inc
# @include spad_log_func.inc
##

object cql_rows_kind_decoder : cql_binary_decoder
{
  ##
  # Holds the column count that is parsed from the response.
  ##
  var columns_count = 0;
  
  ##
  # Contains the column specification metadata in an array.
  ##
  var col_spec = [];

  ##
  # Contains the response flag values in an array.
  ##
  var flags = {};

  ##
  # Contains the response row values in a list.
  ##
  var rows = make_nested_list();

  ##
  # Contains the keyspace that the query was executed in.
  ##
  var keyspace = NULL;

  ##
  # Contains the table the reponse rows were pulled from
  ##
  var table = NULL;
  
  ##
  # Parses the rows.
  #
  # @return NULL.
  ##
  public function parse()
  {
    parse_flags();
    columns_count = get_int();
    if(flags.HAS_MORE_PAGES) parse_paging_state();
    if(!flags.NO_METADATA) parse_metadata();
    parse_rows();
  }

  ##
  # Constructor.
  # Expects the raw row kind results to be passed in. Calls super() to set the blob member variable.
  #
  # @return NULL.
  ##
  private function cql_rows_kind_decoder() : super(_FCT_ANON_ARGS[0])
  {
    if(blob) 
      parse();
    else
      set_error('Row data is empty or was not passed to constructor.');
  }

  ##
  # Gets the flags.
  #
  # @return NULL.
  ##
  private function parse_flags()
  {
    var f = get_int();
    flags = {
      GLOBAL_TABLE_SPECS: (f >> 0) & 1,
      HAS_MORE_PAGES: (f >> 1) & 1,
      NO_METADATA: (f >> 2) & 1
    };
  }

  ##
  # Creates an error message if paging is detected.
  #
  # @return NULL.
  ##
  private function parse_paging_state()
  {
    if(flags.HAS_MORE_PAGES)
      set_error('The RESULT has multiple pages but paging is not supported. Use LIMIT in query.');
  }

  ##
  # Calls functions to parse the metadata.
  #
  # @return NULL.
  ##
  private function parse_metadata()
  {
    if(flags.GLOBAL_TABLE_SPECS) parse_global_table_spec_names();
    parse_col_spec();
  }

  ##
  # Gets the global table spec metadata.
  #
  # @return NULL.
  ##
  private function parse_global_table_spec_names()
  {
    keyspace = get_string16();
    table = get_string16();
  }

  ##
  # Gets column metadata (name, type)
  #
  # @return NULL.
  ##
  private function parse_col_spec()
  {
    for(var i = 0; i < columns_count; i++)
      parse_col_spec_i();
  }

  ##
  # Gets the metadata for a single column and adds it to 
  # the col_spec data structure.
  #
  # @return NULL.
  ##
  private function parse_col_spec_i()
  {
    var cs = {};

    if(!flags.GLOBAL_TABLE_SPECS)
    {
      cs.ksname = get_string16();
      cs.tablename = get_string16();
    }
    
    cs.name = get_string16();
    cs.type = parse_col_type();
    
    append_element(var:col_spec, value:cs);
  }

  ##
  # Returns the data type for the column from the metadata.
  #
  # @return int Column type. Maps to constants defined in cql.inc.
  ##
  private function parse_col_type()
  {
    var type = get_int16();
    
    if(type == CQL_MAP)
    {
      type = {collection: type};
      type.keytype = get_int16();
      type.valuetype = get_int16();
    }
    else if(type == CQL_LIST || type == CQL_SET)
    {
      type = {
        collection: type,
        type: get_int16()
      };
    }
    return type;
  }

  ##
  # Iterates over all rows of data and calls the function to parse the individual rows.
  #
  # @return NULL.
  ##
  private function parse_rows()
  {
    var rows_count = get_int();
    for(var i=0;i<rows_count;i++)
      parse_row_i();
  }

  ##
  # Gets a single row of data and places it in a list then.
  #
  # @return NULL.
  ##
  private function parse_row_i()
  {
    var i, row = [];
    for(i=0;i<columns_count;i++)
      append_element(var:row, value:parse_col_value(i:i));
    append_element(var:row, value:'_'); # Lists can't contain all NULL values or they will be truncated
    append_element(var:rows, value:row);
  }

  ##
  # Gets a column value from a row based on type.
  #
  # @return Either a simple data type or a collection.
  ##
  private function parse_col_value(i)
  {
    var len = get_int(), type = col_spec[i].type;
    
    if(len <= 0) return NULL;  # Col value is null if len = 0xff0xff0xff0xff

    if(typeof(type) == 'array')
      return parse_collection_col_value(type:type);
    else
      return parse_simple_col_value(type:type, len:len, i:i);
  }
  
  ##
  # Gets a column value for simple data types (read non-collection data types).
  #
  # @return Simple data type value.
  ##
  private function parse_simple_col_value(type, len, i)
  {
    # These types can be represented using Nasl native types
    if(type == CQL_ASCII)    return get_bytes(len:len);
    if(type == CQL_BLOB)     return get_bytes(len:len);
    if(type == CQL_BOOLEAN)  return get_bool();
    if(type == CQL_INT)      return get_int();
    if(type == CQL_UUID)     return get_uuid();
    if(type == CQL_VARCHAR)  return get_bytes(len:len);
    if(type == CQL_TIMEUUID) return get_uuid();
    if(type == CQL_INET)     return get_inet();
    if(type == CQL_DATE)     return get_date();
    
    # These types should use CAST(<col_name> AS text) in CQL Queries because
    # they cannot be represented using Nasl native types
    if(type == CQL_BIGINT)    set_type_error(col_name:col_spec[i].name);
    if(type == CQL_DECIMAL)   set_type_error(col_name:col_spec[i].name);
    if(type == CQL_DOUBLE)    set_type_error(col_name:col_spec[i].name);
    if(type == CQL_FLOAT)     set_type_error(col_name:col_spec[i].name);
    if(type == CQL_TIMESTAMP) set_type_error(col_name:col_spec[i].name);
    if(type == CQL_VARINT)    set_type_error(col_name:col_spec[i].name);
    if(type == CQL_TIME)      set_type_error(col_name:col_spec[i].name);
  }

  ##
  # Gets a column value for a collection data type.
  #
  # @return Collection data type value (list or array).
  ##
  private function parse_collection_col_value(type)
  {
    if(type.collection == CQL_SET) return get_set();
  }
  
  ##
  # Gets a set and returns it as a list.
  #
  # @return List of values from the set.
  ##
  private function get_set()
  {
    var i, set = [], num_items = get_int();
    
    for(i = 0;i < num_items; i++)
      append_element(var:set, value:get_bytes(len:get_int()));
    
    return set;
  }
}
