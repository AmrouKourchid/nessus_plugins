#TRUSTED 599f49d6c6bc22e1395b9c7ce3661c05a7242dbacd65e6ee7bcc2b494b60d9c7584a028c04444350efb46d90b1e6cf32badac7c8d8a37a7e5edfa94d98e5b20a18e68c688ba921dc7816600c8488bab6812c4ea401b1a89cd1c76cc55271918746904a32bc571cd35b99fcce5ed4a9f6ac335b67f95f024754753e136ce67a5302d6f7f0ccab7faea5cd743250f72fc7903f7d2e78adc544b7c5ba7fe25f7eae83268e1653f9e0f0048ad83f9934a6ce51b5b63dcb2f1d5c5d63b4b419b325e9b9e2e9a867082a5e14a7572ba66dc5f2151c048257db31210b37588981523f9685e2206389d7c482985776f2c9ae2e111cc4cb4b4a032f370b2d8d8f20a5204cf1c7fc456774d9b0af140c48d53614cbeb4d1156de7be4530568ad3070b84a5722dacf9f281ec5a3643f04f156ed1af06a2b1de4efb48cd84e15a7cd829d5b0cbc8e742f5c48e7fc7be6e1987bb587be8bea14bf87f1b461927ebdda97abc06e87ced8d01f2be43cde23be3bc27f15bf3a670c32d8215327dcb5d8095a2d043cb7ce9368d73507cd5fc532106d3a284f7d6d17bbc0d6241353b0304b7569a1d8fcd57ba66e3fe09f10971bd9794563a703563be2e55fb78e0637f4fb59ec6bd95fcbbbd831d605d70e5b8372321e532589afc6564523a1a39a5707e85a19bc0f32b4ba88cf06e251db848c774ca2f4c07f9b6b1e4c52eaaf997966faa7a6417b
#TRUST-RSA-SHA256 32a140bcfe8624296c5770c5cf0c99724ed9264588f0452ede8f2dc03e17956f3801be64ee51901efe501eaea0160311a4e2cbef56d54fdd339203d6c30c9568b00d0006be77e880e895007e8f8ea8931b5ea7f2ba0fbfdcf84854364bc64498561cdca527834b624d50851f522020944b0eb3572fa2e4b3f65efd09446fcde71d20d0e457d0089290d2100e60bc53cba89fcf2ed72aacebb4440dc75aadd51af05e83e4f0c38515c62f34875e3bd3888d0f675722e9418d903d837a1c7539d1835ff1e29a6875a6eff4d90caac951293268addd88067bb7cc73ac3eb643f38b18ea8da513d669ed7cdfeb4458398b94b8cfae0bebbb0d3d3f9997355bf5d98517486635acf4185500eb2f3fef2aec269a44a59480654cf33c5329807f4b5d4c9fee4d3a17074a5f1bb161df01e5c5e59d1d9ef82c2d3923f7bad635b3c7a96c9333f02f2380d067a1d91ef1996c54b4c125515fdb84b4824bd48d7a9e615a6e7054ac642d752f045a4c4858dd263bfc1b32f4fef29157b922b730dfd2f793778de2813a50d30100806dae46e1fccd89d297869a87407c3c1fed2351a394b51b68283271422cd0423ecb1bcdebc62922106a6000665ff71733c4809c730ced3217b5b8c9ab93d8e845d6a2e60407ff0066dee32b17eaadfd0526974bd6cf26389bb985612901f9b88ea6216d4cdb16ab1f875483cc5bbfd3c2b97fa0590a58b4
# -*- Fundamental -*-
#
# (C) Tenable Network Security, Inc.
#
# This script is released under one of the Tenable Script Licenses and may not
# be used from within scripts released under another license without the
# authorization from Tenable Network Security Inc.
#
#
# @NOGPL@
#
# crypto_func.static
# Revision: 1.8
#
#
global_var dh_pub, dh_priv;

#---------------------------------------------------------#
# DES encryption code                                     #
#---------------------------------------------------------#

global_var perm1 =
  make_list (57, 49, 41, 33, 25, 17,  9,
              1, 58, 50, 42, 34, 26, 18,
             10,  2, 59, 51, 43, 35, 27,
             19, 11,  3, 60, 52, 44, 36,
             63, 55, 47, 39, 31, 23, 15,
              7, 62, 54, 46, 38, 30, 22,
             14,  6, 61, 53, 45, 37, 29,
             21, 13,  5, 28, 20, 12,  4 );


global_var perm2 =
  make_list (14, 17, 11, 24,  1,  5,
              3, 28, 15,  6, 21, 10,
             23, 19, 12,  4, 26,  8,
             16,  7, 27, 20, 13,  2,
             41, 52, 31, 37, 47, 55,
             30, 40, 51, 45, 33, 48,
             44, 49, 39, 56, 34, 53,
             46, 42, 50, 36, 29, 32 );

global_var perm3 =
  make_list (58, 50, 42, 34, 26, 18, 10,  2,
             60, 52, 44, 36, 28, 20, 12,  4,
             62, 54, 46, 38, 30, 22, 14,  6,
             64, 56, 48, 40, 32, 24, 16,  8,
             57, 49, 41, 33, 25, 17,  9,  1,
             59, 51, 43, 35, 27, 19, 11,  3,
             61, 53, 45, 37, 29, 21, 13,  5,
             63, 55, 47, 39, 31, 23, 15,  7 );

global_var perm4 =
  make_list (32,  1,  2,  3,  4,  5,
              4,  5,  6,  7,  8,  9,
              8,  9, 10, 11, 12, 13,
             12, 13, 14, 15, 16, 17,
             16, 17, 18, 19, 20, 21,
             20, 21, 22, 23, 24, 25,
             24, 25, 26, 27, 28, 29,
             28, 29, 30, 31, 32,  1 );

global_var perm5 =
  make_list (16,  7, 20, 21,
             29, 12, 28, 17,
              1, 15, 23, 26,
              5, 18, 31, 10,
              2,  8, 24, 14,
             32, 27,  3,  9,
             19, 13, 30,  6,
             22, 11,  4, 25 );

global_var perm6 =
  make_list (40,  8, 48, 16, 56, 24, 64, 32,
             39,  7, 47, 15, 55, 23, 63, 31,
             38,  6, 46, 14, 54, 22, 62, 30,
             37,  5, 45, 13, 53, 21, 61, 29,
             36,  4, 44, 12, 52, 20, 60, 28,
             35,  3, 43, 11, 51, 19, 59, 27,
             34,  2, 42, 10, 50, 18, 58, 26,
             33,  1, 41,  9, 49, 17, 57, 25 );

global_var sc = make_list (1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1);

global_var sbox =
  make_list (14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7,
              0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8,
              4,  1, 14,  8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10,  5,  0,
             15, 12,  8,  2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0,  6, 13,

             15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10,
              3, 13,  4,  7, 15,  2,  8, 14, 12,  0,  1, 10,  6,  9, 11,  5,
              0, 14,  7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15,
             13,  8, 10,  1,  3, 15,  4,  2, 11,  6,  7, 12,  0,  5, 14,  9,

             10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8,
             13,  7,  0,  9,  3,  4,  6, 10,  2,  8,  5, 14, 12, 11, 15,  1,
             13,  6,  4,  9,  8, 15,  3,  0, 11,  1,  2, 12,  5, 10, 14,  7,
              1, 10, 13,  0,  6,  9,  8,  7,  4, 15, 14,  3, 11,  5,  2, 12,

              7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15,
             13,  8, 11,  5,  6, 15,  0,  3,  4,  7,  2, 12,  1, 10, 14,  9,
             10,  6,  9,  0, 12, 11,  7, 13, 15,  1,  3, 14,  5,  2,  8,  4,
              3, 15,  0,  6, 10,  1, 13,  8,  9,  4,  5, 11, 12,  7,  2, 14,

              2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9,
             14, 11,  2, 12,  4,  7, 13,  1,  5,  0, 15, 10,  3,  9,  8,  6,
              4,  2,  1, 11, 10, 13,  7,  8, 15,  9, 12,  5,  6,  3,  0, 14,
             11,  8, 12,  7,  1, 14,  2, 13,  6, 15,  0,  9, 10,  4,  5,  3,

             12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11,
             10, 15,  4,  2,  7, 12,  9,  5,  6,  1, 13, 14,  0, 11,  3,  8,
              9, 14, 15,  5,  2,  8, 12,  3,  7,  0,  4, 10,  1, 13, 11,  6,
              4,  3,  2, 12,  9,  5, 15, 10, 11, 14,  1,  7,  6,  0,  8, 13,

              4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1,
             13,  0, 11,  7,  4,  9,  1, 10, 14,  3,  5, 12,  2, 15,  8,  6,
              1,  4, 11, 13, 12,  3,  7, 14, 10, 15,  6,  8,  0,  5,  9,  2,
              6, 11, 13,  8,  1,  4, 10,  7,  9,  5,  0, 15, 14,  2,  3, 12,

             13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7,
              1, 15, 13,  8, 10,  3,  7,  4, 12,  5,  6, 11,  0, 14,  9,  2,
              7, 11,  4,  1,  9, 12, 14,  2,  0,  6, 10, 13, 15,  3,  5,  8,
              2,  1, 14,  7,  4, 10,  8, 13, 15, 12,  9,  0,  3,  5,  6, 11 );

#---------------------------------------------------------#
# Function    : raw_byte                                  #
# Description : Convert a byte to raw data                #
#---------------------------------------------------------#

function raw_byte (b)
{
 return raw_string (b);
}


#---------------------------------------------------------#
# Function    : raw_word                                  #
# Description : Convert a word to raw data                #
#---------------------------------------------------------#

function raw_word (w)
{
 return raw_string ( (w)     & 255,
                     (w>>8)  & 255 );
}


#---------------------------------------------------------#
# Function    : raw_dword                                 #
# Description : Convert a dword to raw data               #
#---------------------------------------------------------#

function raw_dword (d, be)
{
 if(isnull(be) || be == FALSE)
 {
  return raw_string ( (d)    & 255,
                     (d>>8)  & 255,
                     (d>>16) & 255,
                     (d>>24) & 255 );
 }
  return raw_string ((d>>24) & 255,
                     (d>>16) & 255,
                     (d>>8)  & 255,
                     (d)     & 255);
}

#---------------------------------------------------------#
# Function    : get_word                                  #
# Description : Extract a word from a blob                #
#---------------------------------------------------------#

function get_word(blob,pos)
{
 if (pos > (strlen (blob) - 2))
   return NULL;

 return ( ord(blob[pos]) + (ord(blob[pos+1]) << 8) );
}


#---------------------------------------------------------#
# Function    : get_dword                                 #
# Description : Extract a dword from a blob               #
#---------------------------------------------------------#

function get_dword(blob, pos)
{
 if (pos > (strlen(blob) - 4))
   return NULL;

 return ( ord(blob[pos]) +
          (ord(blob[pos+1]) << 8) +
          (ord(blob[pos+2]) << 16) +
          (ord(blob[pos+3]) << 24) );
}


#---------------------------------------------------------#
# Function    : get_byte                                  #
# Description : Extract a byte from a blob                #
#---------------------------------------------------------#

function get_byte (blob,pos)
{
 if (pos > (strlen (blob) - 1))
   return NULL;

 return ( ord(blob[pos]) );
}




function permute (in, p)
{
 local_var buf, i;

 buf = NULL;
 for (i = 0; i < strlen(p); i++)
    buf += in[ord(p[i]) - 1];

 return buf;
}

function lshift (d, count)
{
 local_var buf, i;

 buf = NULL;
 for (i = 0; i < strlen(d); i++)
   buf += d[(i+count)%strlen(d)];

 return buf;
} 

function xor (in1, in2)
{
 local_var buf, i;

 buf = NULL;
 for (i = 0; i < strlen(in2); i++)
   buf += raw_string (ord(in1[i]) ^ ord(in2[i]));

 return buf;
}


global_var _b, _er, _erk, _cb, _pcb, _l, _r, _r2, __buf;

_b = make_list(0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0);

_er = make_list(0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0);

_erk = make_list(0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0);

_cb = make_list(0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0);

_pcb = make_list(0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0);

_l = make_list(0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0);

_r = make_list(0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0);

_r2 = make_list(0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0);

__buf = make_list (
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0);

function des_encrypt (in, key, type)
{
 local_var i, j, k, c, d, cd, pd1, l, r, rl, pk1;
 local_var cb, pcb, r2, tmp, val, ki;
 local_var m, n;
 local_var cmpt, tmp1, tmp2, count;

 pk1 = c = d = cd = NULL;

 for (cmpt = 0; cmpt < 56; cmpt++)
   pk1 += key[perm1[cmpt] - 1];

 c = substr (pk1, 0, 27);
 d = substr (pk1, 28, 55);

 for (i = 0; i < 16; i++)
 {
  tmp1 = tmp2 = NULL;
  count = sc[i];
  for (cmpt = 0; cmpt < 28; cmpt++)
  {
    tmp1 += c[(cmpt+count)%28];
    tmp2 += d[(cmpt+count)%28];
  }

  c = tmp1;
  d = tmp2;

  cd = c + d;

  ki[i] = NULL;
  for (cmpt = 0; cmpt < 48; cmpt++)
    ki[i] += cd[perm2[cmpt] - 1];
 }

 for (cmpt = 0; cmpt < 64; cmpt++)
 {
  if (cmpt < 32)
    _l[cmpt] = in[perm3[cmpt] - 1];
  else
    _r[cmpt-32] = in[perm3[cmpt] - 1];
 }


 for (i = 0; i < 16; i++)
 {
  for (cmpt = 0; cmpt < 48; cmpt++)
     _er[cmpt] = _r[perm4[cmpt] - 1];

  if (type == 1)
  { 
    tmp2 = ki[i];
    for (cmpt = 0; cmpt < 48; cmpt++)
      _b[cmpt] = (_er[cmpt] ^ ord(tmp2[cmpt]));
  }
  else
  {
    tmp2 = ki[15-i];
    for (cmpt = 0; cmpt < 48; cmpt++)
      _b[cmpt] = (_er[cmpt] ^ ord(tmp2[cmpt]));
  }

  for (j = 0; j < 8; j++)
  {
   tmp2 = j*6;
   m = (_b[tmp2] << 1);
   m = m | (_b[tmp2 + 5]);

   n = (_b[tmp2 + 1] << 3);
   n = n | (_b[tmp2 + 2] << 2);
   n = n | (_b[tmp2 + 3] << 1);
   n = n | (_b[tmp2 + 4]);

   tmp1 = sbox [j*4*16 + m*16 + n];
   for (k = 0; k < 4; k++)
      if ((tmp1 & (1<<(3-k))) == 0)
        _b[tmp2 + k] = 0;
      else
        _b[tmp2 + k] = 1;
  }

  for (j=0; j<8; j++)
  {
   tmp2 = j*6;
   tmp1 = j*4;
   _cb[tmp1] = _b[tmp2];
   _cb[tmp1+1] = _b[tmp2+1];
   _cb[tmp1+2] = _b[tmp2+2];
   _cb[tmp1+3] = _b[tmp2+3];
  }

  for (cmpt = 0; cmpt < 32; cmpt++)
    _pcb[cmpt] = _cb[perm5[cmpt] - 1];

  for (cmpt = 0; cmpt < 32; cmpt++)
    _r2[cmpt] = (_l[cmpt] ^ _pcb[cmpt]);

  _l = _r;
  _r = _r2;
 }

 for (cmpt = 0; cmpt < 64; cmpt++)
 {
   tmp2 = perm6[cmpt]-1;
   if (tmp2 < 32)
     __buf[cmpt] = _r[tmp2];
   else
     __buf[cmpt] = _l[tmp2-32];
 }

 return __buf;
}


global_var _zero, _one, _inb;

_zero = raw_string(0);
_one = raw_string(1);

_inb = make_list(0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0);

function set_des_key (key)
{
 local_var keyb, i;

 keyb = NULL;

 for (i=0;i<64;i++)
 {

  if ((ord(key[i/8]) & (1<<(7-(i%8)))) == 0)
    keyb += _zero;
  else
    keyb += _one;
 }

 return keyb;
}


function str_to_key (str)
{
 local_var key, i;

 key = raw_string ( ((ord(str[0])>>1) << 1) ,
                    ((((ord(str[0])&0x01)<<6) | (ord(str[1])>>2)) << 1) ,
                    ((((ord(str[1])&0x03)<<5) | (ord(str[2])>>3)) << 1) ,
                    ((((ord(str[2])&0x07)<<4) | (ord(str[3])>>4)) << 1) ,
                    ((((ord(str[3])&0x0F)<<3) | (ord(str[4])>>5)) << 1) ,
                    ((((ord(str[4])&0x1F)<<2) | (ord(str[5])>>6)) << 1) ,
                    ((((ord(str[5])&0x3F)<<1) | (ord(str[6])>>7)) << 1) ,
                    ((ord(str[6])&0x7F) << 1) );

 return set_des_key(key:key);
}


function DES (in, key, _string, type)
{
 local_var inb, keyb, key2, outb, out, buf, i;

 inb = keyb= outb = buf = NULL;;

 if (isnull(_string) || (_string == TRUE))
   key2 = str_to_key (str:key);
 else
   key2 = key;

 for (i=0;i<64;i++)
 {
  if ((ord(in[i/8]) & (1<<(7-(i%8)))) == 0)
    _inb[i] = 0;
  else
    _inb[i] = 1;    
 }

 outb = des_encrypt(in:_inb, key:key2, type:type);

 out = make_list (0,0,0,0,0,0,0,0);

 for (i=0;i<64;i++) 
 {
  if (outb[i] == 1)
    out[i/8] = out[i/8] | (1<<(7-(i%8)));
 }

 for (i=0;i<8;i++)
 {
  buf += raw_string (out[i]);
 }

 return buf;
}





#---------------------------------------------------------#
# RC4 HMAC encryption code                                #
#---------------------------------------------------------#

global_var arcS, arcS2;

function arcfour_setkey (key)
{
 local_var i,j,temp;

 arcS = NULL;
 for (i=0; i < 256; i++)
 {
  arcS[i] = i;
  arcS2[i] = ord(key[i % strlen(key)]);
 }

 j = 0;

 for (i=0; i < 256; i++)
 {
  j = (j + arcS[i] + arcS2[i]) % 256;
  temp = arcS[i];
  arcS[i] = arcS[j];
  arcS[j] = temp;
 }
}


function ARCFOUR (data)
{
 local_var i,j,temp,t,k,output,l;

 output = NULL;
 i = j = 0;

 for (l=0; l < strlen(data); l++)
 {
  i = (i+1) % 256;
  j = (j + arcS[i]) % 256;
  temp = arcS[i];
  arcS[i] = arcS[j];
  arcS[j] = temp;
  t = (arcS[i] + arcS[j]) % 256;
  k = arcS[t];

  output += raw_string (k ^ ord(data[l]));
 }

 return output;
}


function rc4_hmac_string_to_key (string)
{
 # Must be unicode !!!
 return MD4 (string);
}


function rc4_hmac_checksum (key,type,data,real_key)
{
 local_var hmac, tmp, key2;

 hmac = HMAC_MD5 (key:key, data:"signaturekey"+raw_byte(b:0));
 tmp = MD5 (type+data);

 return HMAC_MD5 (key:hmac, data:tmp);
}


function rc4_hmac_encrypt (key,data,type,real_key)
{
 local_var hmac, checksum, conf_data, K3, random, key2, val1, i;

 if (isnull(real_key) || (real_key == FALSE))
 {
   # make sure password is unicode
   local_var pass;
   pass = NULL; for(i = 0; i < strlen(key); i++) pass += key[i] + '\x00';
   key2 = rc4_hmac_string_to_key (string:pass);
 }
 else
   key2 = key;

 random = NULL;

 hmac = HMAC_MD5 (key:key2, data:type);

 for (i=0; i < 8; i++)
    random += raw_string (rand() % 256);
 conf_data = random + data;

 checksum = HMAC_MD5 (key:hmac, data:conf_data);
 K3 = HMAC_MD5 (key:hmac, data:checksum);

 arcfour_setkey (key:K3);
 val1 = ARCFOUR (data:conf_data);

 return checksum + val1;
}


function rc4_hmac_decrypt (key,data,type,real_key)
{
 local_var hmac, checksum, checksum2, conf_data, K3, key2, val1;

 if (isnull(real_key) || (real_key == FALSE))
 {
   # make sure password is unicode
   local_var i, pass;
   pass = NULL; for(i = 0; i < strlen(key); i++) pass += key[i] + '\x00';
   key2 = rc4_hmac_string_to_key (string:pass);
 }
 else
   key2 = key;

 hmac = HMAC_MD5 (key:key2, data:type);

 checksum = substr(data,0,15);
 K3 = HMAC_MD5 (key:hmac, data:checksum);


 conf_data = substr (data,16,strlen(data)-1);
 arcfour_setkey (key:K3);
 val1 = ARCFOUR (data:conf_data);

 checksum2 = HMAC_MD5 (key:hmac, data:val1);

 if (checksum == checksum2)
   return substr(val1,8,strlen(val1)-1);
 else
   return NULL;
}


#function rc4_hmac_checksum (key,data,type)
#{
# ksign = HMAC_MD5;
#}


#---------------------------------------------------------#
# DES-cbc  encryption code                                #
#---------------------------------------------------------#


function xor8 (a,b)
{
 local_var tmp, i;

 tmp = NULL;

 for (i=0; i<strlen(a); i++)
   tmp += raw_byte (b:ord(a[i]) ^ ord(b[i]));

 return tmp;
}


function reverse(i)
{
 local_var tmp, val, j;

 tmp = 0;
 val = 0x80;
 for (j=1; j<8; j++)
 {
  if (ord(i) & val)
    tmp += (1 << j);
  val = val >> 1;
 }

 return raw_byte(b:tmp);
}


function reverse8 (s)
{
 local_var tmp, i;

 tmp = NULL;

 for (i=0; i<strlen(s); i++)
   tmp += reverse(i:s[strlen(s)-1-i]);

 return tmp;
}


function get_parity (i)
{
 local_var tmp, val, j;

 tmp = 0;
 val = 2;
 for (j=0; j<7; j++)
 {
   if (i & val)
     tmp++;
   val = (val << 1) % 256;
 }

 return (tmp%2);
}


function fixparity(s)
{
 local_var tmp, val, i;

 tmp = NULL;
 for (i=0; i<strlen(s);i++)
 {
  val = ord(s[i]);
  if (get_parity(i:val) == 0)
   val = (val & 0xFE) + 1 ;
  else
   val = val & 0xFE;

  tmp += raw_byte(b:val);
 }

 return tmp;
}

function removeMSBits(s)
{
 local_var tmp, i;

 tmp = NULL;
 for (i=0; i<strlen(s); i++)
 {
  tmp += raw_byte(b:ord(s[i]) << 1);
 }

 return tmp;
}


# Need to be done
function is_weak_key (key)
{
 return 0;
}


function des_cbc_checksum (key, data, iv)
{
 local_var tout0, tout1, tin0, tin1, i, tin, keyb, tmp;

 tout0 = get_dword(blob:iv, pos:0);
 tout1 = get_dword(blob:iv, pos:4);

 keyb = set_des_key (key:key);

 for (i=0; i<strlen(data); i+=8)
 {
  if (i+8<=strlen(data))
  {
   tin0 = get_dword(blob:data, pos:i);
   tin1 = get_dword(blob:data, pos:i+4);
  }
  else
  {
   tmp = substr(data,i,strlen(data)-1);
   tmp += crap(data:raw_byte(b:0), length:8-(strlen(tmp)%8));
   tin0 = get_dword(blob:tmp, pos:i);
   tin1 = get_dword(blob:tmp, pos:i+4);   
  }

  tin0 = tin0 ^ tout0;
  tin1 = tin1 ^ tout1;

  tin = raw_dword (d:tin0) + raw_dword(d:tin1);
  tin = DES (in:tin, key:keyb, type:1, _string:FALSE);
  tout0 = get_dword(blob:tin, pos:0);
  tout1 = get_dword(blob:tin, pos:4);
 }

 return raw_dword(d:tout0) + raw_dword(d:tout1);
}


function des_cbc_encrypt (data, key, iv, encrypt)
{
 local_var tin, tin0, tin1, tout0, tout1, out, i, xor0, xor1, keyb;

 keyb = set_des_key (key:key);

 out = NULL;
 if (encrypt == 1)
 {
  tout0 = get_dword(blob:iv, pos:0);
  tout1 = get_dword(blob:iv, pos:4);
  for (i=0; i<strlen(data); i+=8)
  {
   tin0 = get_dword(blob:data, pos:i);
   tin1 = get_dword(blob:data, pos:i+4);

   tin0 = tin0 ^ tout0;
   tin1 = tin1 ^ tout1;

   tin = raw_dword (d:tin0) + raw_dword(d:tin1);
   tin = DES (in:tin, key:keyb, type:1, _string:FALSE);
   tout0 = get_dword(blob:tin, pos:0);
   tout1 = get_dword(blob:tin, pos:4);
   out += tin;
  }
 }
 else
 {
  xor0 = get_dword(blob:iv, pos:0);
  xor1 = get_dword(blob:iv, pos:4);
  for (i=0; i<strlen(data); i+=8)
  {
   tin0 = get_dword(blob:data, pos:i);
   tin1 = get_dword(blob:data, pos:i+4);
   tin = raw_dword(d:tin0) + raw_dword(d:tin1);
   tin = DES (in:tin, key:keyb, type:0, _string:FALSE);
   tout0 = get_dword(blob:tin, pos:0) ^ xor0;
   tout1 = get_dword(blob:tin, pos:4) ^ xor1;
   out += raw_dword(d:tout0) + raw_dword(d:tout1);
   xor0 = tin0;
   xor1 = tin1;
  }
 }

 return out;
}


function des_cbc_string_to_key (_string,salt)
{
 local_var odd, s, tempkey, byteblock, i, j, key, fix_weak;

 fix_weak = raw_string(0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0);

 odd = 1;

 s = _string + salt;
 tempkey = raw_string (0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00);

 # pad on 8 bytes
 if (strlen(s) % 8)
   s = s + crap (data:raw_byte(b:0x00), length:8-(strlen(s)%8));

 for (i=0; i< strlen(s); i+=8)
 {
  byteblock = removeMSBits(s:substr(s,i,i+7));
  if (odd == 0)
  {
   odd = 1;
   byteblock = reverse8(s:byteblock);
  }
  else
   odd = 0;

  tempkey = xor8 (a:tempkey, b:byteblock);
 }

 tempkey = fixparity(s:tempkey);
 if (is_weak_key(key:key))
   key = xor8 (a:key, b:fix_weak);
 key = des_cbc_checksum(key:tempkey,data:s, iv:tempkey);
 key = fixparity(s:key);

 return key;
}


function des_cbc_md5_encrypt (data, key)
{
 local_var iv, confounder, i, hash, cksum, tmp;

 cksum = raw_string (0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);

 confounder = NULL;

 for (i=0; i<8; i++)
  confounder += raw_byte(b:rand()%256);

 tmp = data;
 if (strlen(data)%8)
   tmp += crap(data:raw_byte(b:0),length:8-(strlen(data)%8));

 hash = MD5 (confounder+cksum+tmp);

 iv = raw_string (0,0,0,0,0,0,0,0);

 return des_cbc_encrypt (data:confounder+hash+tmp, key:key, iv:iv, encrypt:1);
}



function des_cbc_md5_decrypt (data, key)
{
 local_var iv, confounder, cksum, decrypted, hash, msg, tohash;

 cksum = raw_string (0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);

 iv = raw_string (0,0,0,0,0,0,0,0);

 decrypted = des_cbc_encrypt (data:data, key:key, iv:iv, encrypt:0);
 if (strlen(decrypted) < 24)
   return NULL;

 msg = substr(decrypted,24,strlen(decrypted)-1);
 confounder = substr(decrypted, 0, 7);
 tohash = confounder+cksum+msg;

 hash = MD5 (tohash);

 cksum = substr(decrypted, 8, 23);

 if (hexstr(cksum) >!< hexstr(hash))
   return NULL;

 return msg;
}


function des_cbc_md5_checksum (data, key)
{
 local_var confounder, iv, i, enckey, tmp;

 iv = raw_string (0,0,0,0,0,0,0,0);

 enckey = xor8(a:key,b:raw_string(0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0));
 confounder = NULL;

 for (i=0; i<8; i++)
  confounder += raw_byte(b:rand()%256);

 return des_cbc_encrypt (data:confounder+MD5(confounder+data), key:enckey, iv:iv, encrypt:1);
}




#---------------------------------------------------------#
# LANMAN2.1 Challenge/Response                            #
#---------------------------------------------------------#


function LM_Hash (password)
{
 local_var len, pass, K1, K2, hash;

 len = strlen (password);
 if ( len > 14 ) len = 14;
 pass = substr (password, 0, len);

 while (strlen(pass) < 14)
   pass += raw_string (0);

 pass = toupper (pass);

 K1 = substr (pass, 0, 6);
 K2 = substr (pass, 7, 13);

 hash = DES (in:"KGS!@#$%", key:K1, type:1) + DES (in:"KGS!@#$%", key:K2, type:1);

 return hash;
}


function LM_Response (password, hash, challenge)
{
 local_var key1, key2, key3, response;

 response = NULL;

 if (isnull(hash))
   hash = LM_Hash (password:password);

 response[1] = substr (hash, 0, 7) + raw_string (0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00);

 hash += raw_string (0x00,0x00,0x00,0x00,0x00);

 key1 = substr (hash, 0, 6);
 key2 = substr (hash, 7, 13);
 key3 = substr (hash, 14, 20);

 response[0] = DES (in:challenge, key:key1, type:1) + DES (in:challenge, key:key2, type:1) + DES (in:challenge, key:key3, type:1);

 return response;
}



#---------------------------------------------------------#
# NTLM 0.12 Challenge/Response                            #
#---------------------------------------------------------#


function NTLM_Hash (password)
{
 if (password)
   return MD4 (password);
 else
   return raw_string(0x31, 0xd6, 0xcf, 0xe0, 0xd1, 0x6a, 0xe9, 0x31, 0xb7, 0x3c, 0x59, 0xd7, 0xe0, 0xc0, 0x89, 0xc0);
}

function NTLM_Response (password, hash, challenge)
{
 local_var key1, key2, key3, response;

 response = NULL;

 if (isnull(hash))
   hash = NTLM_Hash (password:password);

 response[1] = MD4 (hash);

 hash += raw_string (0x00,0x00,0x00,0x00,0x00);

 key1 = substr (hash, 0, 6);
 key2 = substr (hash, 7, 13);
 key3 = substr (hash, 14, 20);

 response[0] = DES (in:challenge, key:key1, type:1) + DES (in:challenge, key:key2, type:1) + DES (in:challenge, key:key3, type:1);

 return response;
}


function NTLMv2_Hash (password, login, hash, domain)
{
 local_var user, dest, data;

 if (isnull(hash))
   hash = NTLM_Hash (password:password);

 user = toupper (login);
 dest = domain;

 data = user + dest;
 hash = HMAC_MD5 (data:data, key:hash);

 return hash;
}


function unixtime_to_nttime64 (time)
{
 local_var high, low, add, tmp, tmp2, i, j, val, diff;

 tmp = raw_dword(d:time)+raw_dword(d:0);

 for (i=0; i<7; i++)
 {
  val = 0;
  tmp2 = NULL;
  for (j=0; j<8; j++)
  {
   tmp2 = tmp2 + raw_string((ord(tmp[j])*2+val)&0xFF);
   val = ((ord(tmp[j])*2+val)&0xFF00) >> 8;
  }
  tmp = tmp2;
 }

 for (i=0; i<7; i++)
 {
  val = 0;
  tmp2 = NULL;
  for (j=0; j<8; j++)
  {
   tmp2 = tmp2 + raw_string((ord(tmp[j])*5+val)&0xFF);
   val = ((ord(tmp[j])*5+val)&0xFF00) >> 8;
  }
  tmp = tmp2;
 }

 diff = raw_string (0x00,0x80,0x3e,0xd5,0xde,0xb1,0x9d,0x01);

 val = 0;
 tmp2 = NULL;
 for (j=0; j<8; j++)
 {
  tmp2 = tmp2 + raw_string((ord(tmp[j])+ord(diff[j])+val)&0xFF);
  val = ((ord(tmp[j])+ord(diff[j])+val)&0xFF00) >> 8;
 }
 tmp = tmp2;

 return tmp;
}


##
# Converts an ASCII string to a unicode string.  Returns NULL if the
# parameter is empty or NULL.
#
# @anonparam [first:string] An ASCII string.
# @return Returns a unicode string or NULL.
##
function mk_unicode_or_null()
{
  local_var data, len, i, out;
  data = _FCT_ANON_ARGS[0];

  out = NULL;
  len = strlen(data);

  for (i = 0; i < len; i++)
    out += data[i] + '\x00';

  return out;
}


function av_pair_put(id, value)
{
  local_var av, len;

  len = strlen(value);
  av = raw_string((id & 0xff),  (id >> 8)  & 0xff)   +  # attribute id
       raw_string((len & 0xff ), (len >> 8) & 0xff)  +  # attribute length
       value;                                           # attribute value

  return av; 
}
function av_pair_get(data, id, pos)
{
  local_var _id, dlen, len, value;

  dlen = strlen(data);

  # Default starting search position
  if(isnull(pos)) pos = 0; 
  repeat
  { 
    if(pos + 2 > dlen) return NULL; 
    _id  = get_word(blob: data, pos: pos); pos += 2;

    if(pos + 2 > dlen) return NULL;
    len = get_word(blob: data, pos: pos); pos += 2;
    if(pos + len > dlen) return NULL;

    value = substr(data, pos, pos + len - 1);
    pos += len;

    # If id is NULL, return the AV_PAIR @pos, providing a way to enumerate the AV_PAIR list   
    if(isnull(id) || id == _id) 
      return make_array('id', _id, 'value', value, 'next', pos); 

  }until(_id == 0); # MsvAvEOL

  # AV_PAIR not found
  return NULL; 
}

function NTLMv2_Response (password, hash, login, domain, challenge, sblob, service, forceip)
{
 local_var data, blob, hmac, resp, TimeStamp, blip, i, spn, av, thost; 

 resp = NULL;
 hash = NTLMv2_Hash (password:password, login:login, hash:hash, domain:domain);

 blip = NULL;

 for (i = 0; i < 8; i++)
    blip += raw_string (rand() % 256);

 #TimeStamp = raw_string (0x51,0xf4,0x44,0xb4,0x3a,0x44,0xc7,0x01) ; # To change !!
 TimeStamp = unixtime_to_nttime64(time:unixtime());

 thost = NULL;
 # If server sends CHALLENGE_MESSAGE.TargetInfo, try get to the FQDN or NETBIOS name of the target server 
 if( sblob)
 {
   # MsvAvDnsComputerName, MsvAvNbComputerName 
   foreach i (make_list(3, 1))
   {
      av = av_pair_get(data: sblob, id: i);
      if(av)
      { 
        thost = av['value']; 
        break;
      }
   } 
 } 

 # Use IP address only for smb2
 if (forceip)
 {
   thost = mk_unicode_or_null(get_host_ip());
 }

 # Server didn't send its FQDN or NETBIOS name in the CHALLENGE_MESSAGE, try to resolve it our way. 
 #
 # See if there is a NETBIOS name learned by other plugins 
 if(! thost)
 {
    thost = get_kb_item('SMB/name'); 

    # Try to get FQDN if NETBIOS name not found
    if(! thost || thost == get_host_ip())
    thost = get_host_name();

    thost = mk_unicode_or_null(thost);
 }

 # NTLMSSP can be used to authenticate to various network services; not limited to CIFS
 if(! service) service = 'cifs';
 spn = mk_unicode_or_null(service + '/') + thost;

 # Specify target SPN in the AV_PAIRs; MsvAvTargetName
 sblob = av_pair_put(id: 9, value: spn) + sblob;

 blob = raw_string ( 0x01,                    # Response Type Identification Number
                     0x01,                    # Maximum Response Type Identification Number
		     0x00, 0x00,              # Reserved
		     0X00, 0x00, 0x00, 0x00 ) # Reserved ?
	+
	TimeStamp
	+
	blip
	+
	raw_string (0x00,0x00,0x00,0x00)  # Unknown value
	+
	sblob
	+
	raw_string (0x00,0x00,0x00,0x00); # Unknown value

 data = challenge + blob;
 hmac = HMAC_MD5 (data:data, key:hash);
 resp[0] = hmac + blob;
 resp[1] = HMAC_MD5 (data:hmac, key:hash);

 return resp;
}


function LMv2_Response (password, login, hash, domain, challenge)
{
 local_var data, blob, hmac, resp, TimeStamp, blip, i;

 resp = NULL;
 hash = NTLMv2_Hash (password:password, login:login, hash:hash, domain:domain);

 blip = NULL;

 for (i = 0; i < 8; i++)
    blip += raw_string (rand() % 256);

 data = challenge + blip;
 hmac = HMAC_MD5 (data:data, key:hash);
 resp[0] = hmac + blip;
 resp[1] = HMAC_MD5 (data:hmac, key:hash);

 return resp;
}


global_var PRF_HMAC_SHA1 = 1;

##
# Converts a password to an intermediate key
#
# @param p password passed to the PBKDF2 function
# @param s salt passed to the PBKDF2 function
# @param c iterations passed to the PBKDF2 function
# @param dklen requested key length in bytes 
# @param prf Identifier of the Pseudo random function used in the PBKDF2 function; if not specfied, default to PRF_HMAC_SHA1
# @return derived key; NULL on error
# @remark
#   - See RFC 2898, section 5.2 for mote details
##
function pbkdf2(p, s, c, dklen, prf)
{
  local_var data,f, hlen, i, j, l, t, u;
  local_var supported_hashes, hmac;

  # Use HAMC_SHA1 as default PRF
  if(isnull(prf))
    prf = "SHA1";

  supported_hashes = {
    "MD2": [16, @HMAC_MD2],
    "MD5": [16, @HMAC_MD5],
    "SHA1": [20, @HMAC_SHA1],
    "SHA224": [28, @HMAC_SHA224],
    "SHA256": [32, @HMAC_SHA256],
    "SHA384": [48, @HMAC_SHA384],
    "SHA512": [64, @HMAC_SHA512],
    "RIPEMD160": [20, @HMAC_RIPEMD160]
  };

  if(!dklen || !c || !p || !s)
    return NULL;

  if(isnull(supported_hashes[prf]))
    return NULL;

  hlen = supported_hashes[prf][0];
  hmac = supported_hashes[prf][1];

  # Number of hLen-octet blocks in the derived key, rounding up
  # CEIL (dkLen / hLen)
  l = dklen / hlen;
  if (dklen % hlen) l++;

  #Less than the standard check because ... signed integers
  if(l > 0x7fffffff)
    return NULL;

  t = NULL;
  for(i = 1; i <= l; i++)
  {
    f = crap(data:'\x00', length: hlen);
    data = s + raw_string((i << 24) & 0xff, (i << 16) & 0xff, (i << 8) & 0xff, i & 0xff);
    for(j = 0; j < c; j++)
    {
      u = hmac(key:p, data:data);
      f = xor(in1:f, in2:u);
      data = u;
    }
   t += f;
  }

  return substr(t, 0, dklen -1);
}


##
# N-folds data  
#
# @param data data to fold
# @paran flen number of bytes to fold to 
# @return folded data
# @remark
#  - The n-fold algorithm is described in http://www.gnu.org/software/shishi/ides.pdf 
#
##
function nfold(data, flen)
{
  local_var buf, chunk, dlen, i, lcm, out;

  if(isnull(data)) return NULL;

  # Fold len not specified, return the original data
  if(isnull(flen)) return data;

  dlen = strlen(data);

  # Compute the least common multiple
  lcm = lcm(dlen, flen); 

  # Replicate input data to lcm length
  buf = NULL;
  for(i = 0; i < lcm /dlen; i++)
  {
    buf += data;
    data = rotr(data:data, step:13);
  }

  # Add chunks of flen
  out = crap(data:'\x00', length:flen);
  for(i = 0; i < lcm / flen; i++)
  {
    chunk = substr(buf, i * flen,  (i + 1) * flen - 1);
    out = ocadd(out, chunk);
  }

  return out; 
}

##
# Computes the least common mulitple of two numbers
#
# @anonparam number 1
# @anonparam number 2 
# @return the least common mutiple of two number; or NULL if there is an error.
##
function lcm()
{
  local_var a, b, m, t;

  a = _FCT_ANON_ARGS[0];
  b = _FCT_ANON_ARGS[1];

  if(isnull(a) || isnull(b)) return NULL;

  m = a * b;

  # ensure a >= b
  if(a < b)
  {
    t = a;
    a = b;
    b = t; 
  }

  # gcd(a,b)
  while(b !=0 )
  {
    t = b;
    b = a % b;
    a = t;
  }  

  # lcm(a,b) = (a * b)/gcd(a,b) 
  return (m / a); 
}

##
# Treats two buffers as big numbers and add them using ones complement arithmetic
# 
# @anonparam number1
# @anonparam number2
# @return sum of number1 and number2
#   
##
function ocadd()
{
  local_var a, alen, b, blen, c, i, out, t;

  a = _FCT_ANON_ARGS[0];
  b = _FCT_ANON_ARGS[1];

  if(! a) return b;
  if(! b) return a;

  alen = strlen(a);
  blen = strlen(b);

  # Left-pad the smaller buffer if the two buffers are not of same length
  if(alen > blen)
    b = crap(data:'\x00', length: alen - blen) + b;
  else if (alen < blen)
    a = crap(data:'\x00', length: blen - alen) + a;

  # Add two buffers byte by byte
  out = NULL;
  c = 0;
  for(i = strlen(a) - 1; i >= 0; i--)
  {
    t = ord(a[i]) + ord(b[i]) + c;
    c = (t > 0xff);
    out = raw_string(t) + out;
  }
  # Add back the carry bit
  if(c) out = ocadd(out, raw_string(0x01));

  return out;
}

##
# Gets one bit from a data buffer
#
# @anonparam data buffer
# @anonparam position of the bit 
# @return bit value, or NULL if there is an error.
#
##
function getbit()
{
  local_var byte, data, pos;

  data  = _FCT_ANON_ARGS[0];
  pos   = _FCT_ANON_ARGS[1];

  if(isnull(data) || isnull(pos)) return NULL;

  if(pos > strlen(data) * 8 - 1)
    return NULL; 

  # Get the byte where the bit is in
  byte = ord(data[pos / 8]);

  # Extract the bit
  return (byte >> (7 - pos % 8)) & 0x01;
}

##
# Sets a bit in a data buffer 
#
# @anonparam data buffer
# @anonparam position of the bit 
# @anonparam bit value to set
# @return modified data buffer; or NULL if there is an error
#
##
function setbit()
{
  local_var byte, data, pos, val;

  data  = _FCT_ANON_ARGS[0];
  pos   = _FCT_ANON_ARGS[1];
  val   = _FCT_ANON_ARGS[2];

  if(isnull(data) || isnull(pos) || isnull(val)) return NULL;

  if(pos > strlen(data) * 8 - 1)
    return NULL; 

  val = val & 0x01;

  # Get the byte where the bit should be in 
  byte = ord(data[pos / 8]);

  # Set the bit in the byte
  byte =  byte & (~(0x80 >> (pos % 8)));    # clear the bit
  byte =  byte | (val << (7 - (pos % 8)));  # set the bit according to its value 

  data[pos/8] = raw_string(byte);

  return data; 
}

##
# Rotates data to the right
#
# @param data data to rotate
# @param step number of bits to rotate
# @return rotated data
#
##
function rotr(data, step)
{
  local_var bitval, dlen, i, out, pos, t;

  if(isnull(data)) return NULL; 
  if(isnull(step)) step = 1; 
  dlen = strlen(data);
  out = crap(data:'\x00',length:dlen);
  for(i = 0; i < dlen * 8; i++)
  {
    bitval = getbit(data, i);
    pos = (i + step) % (dlen * 8);
    out = setbit(out, pos, bitval);  
  }
  return out; 
}

##
# Encrypts data using AES in CBC Ciphertext Stealing mode
# 
# @param data plaintext
# @param key encryption key
# @param iv initialization vector
# @return ret[0]  - encrypted data
#         ret[1]  - next IV  
#         return NULL on error 
# @remmark
#    - CBC ciphertext stealing is described in http://en.wikipedia.org/wiki/Ciphertext_stealing#CBC_ciphertext_stealing
##
function aes_cbc_cts_encrypt(data, key, iv)
{
  local_var blksz, cn, cn1, cn2, crypted, dlen, dn;
  local_var en1, keysize, m, p, pn, pn1, pos, ret, xn1;

  # Check params
  if(!data || !key || !iv) return NULL;

  keysize = strlen(key);
  if(keysize != 16 && keysize != 24 && keysize != 32)
    return NULL;

  blksz = 16;
  if(strlen(iv) != blksz) return NULL;

  dlen = strlen(data);

  # Pad plaintext to one block if needed
  if(dlen < blksz)
    data += crap(data:'\x00', length: blksz - dlen); 

  # Plain CBC if plaintext is exactly one block
  if(strlen(data) == blksz)
    return aes_cbc_encrypt(data:data, key:key, iv:iv);

  # Number of bytes in last block
  m = dlen % blksz;
  if (m == 0) m = blksz;

  # Last block of the plaintext
  pos = dlen - m;
  pn = substr(data, pos, pos + m - 1);

  # Second to last block of the plaintext
  pos -= blksz;
  pn1 = substr(data, pos, pos + blksz - 1);

  crypted = NULL;
  # Encrypt plaintext except for the last 2 blocks
  if( dlen > blksz + m)
  { 
    ret = aes_cbc_encrypt(data:substr(data, 0, pos - 1) , key:key, iv:iv);
    if(isnull(ret)) return NULL;

    cn2 = ret[1];
    crypted = ret[0];
  }
  # Plaintext is 2 blocks; use iv for cn2
  else cn2 = iv;

  # Chain and encrypt the second-to-last plaintext block 
  xn1 = xor(in1: pn1, in2: cn2);
  ret = aes_cbc_encrypt(data:xn1, key:key, iv:crap(data:'\x00',length: blksz)); 
  if(isnull(ret))   return NULL;
  en1 = ret[0];

  # m bytes of the encrypted second-to-last block is the last ciphertext block 
  cn = substr(en1, 0, m - 1);

  # Steal (blksz - m) bytes from the second-to-last block to form a complete last plaintext block
  p = pn + crap(data:'\x00', length: blksz - m);
  dn = xor(in1: en1, in2: p);

  # Encrypt the now complete, last plaintext block and make the output as the second-to-last ciphertext block
  ret = aes_cbc_encrypt(data:dn, key:key, iv:crap(data:'\x00',length: blksz)); 
  if(isnull(ret))   return NULL;
  cn1 = ret[0];

  # Append the last two, re-arranged ciphertext blocks 
  ret[0] = crypted + cn1 + cn;
  ret[1] = cn1; 

  return ret;

}

##
# Decrypts data using AES in CBC Ciphertext Stealing mode
# 
# @param data ciphertext
# @param key encryption key
# @param iv initialization vector
# @return ret[0]  - decrypted data
#         ret[1]  - next IV  
#         return NULL on error 
# @remmark
#    - CBC ciphertext stealing is described in http://en.wikipedia.org/wiki/Ciphertext_stealing#CBC_ciphertext_stealing
##
function aes_cbc_cts_decrypt(data, key, iv)
{
  local_var blksz, c, cn, cn1, cn2, decrypted, dlen, dn;
  local_var en1, keysize, m, pn, pn1, pos, ret, xn, xn1;

  # Check params
  if(! data || !key || !iv) return NULL;

  keysize = strlen(key);
  if(keysize != 16 && keysize != 24 && keysize != 32)
    return NULL; 

  blksz = 16;
  if(strlen(iv) != blksz) return NULL;

  dlen = strlen(data);

  # Ciphertext MUST be at least <blksz> bytes
  if(dlen < blksz) return NULL;

  # Plain CBC is used if ciphertext size if exactly one block 
  if(dlen == blksz)
    return aes_cbc_decrypt(data:data, key:key, iv:iv);

  # Number of bytes in last block
  m = dlen % blksz;
  if (m == 0) m = blksz;

  # Last block of the ciphertext
  pos = dlen - m;
  cn = substr(data, pos, pos + m - 1);

  # Second-to-last block of the ciphertext
  pos -= blksz;
  cn1 = substr(data, pos, pos + blksz - 1);


  decrypted = NULL;
  # Decrypt ciphertext except for the last 2 blocks
  if( dlen > blksz + m)
  { 
    ret = aes_cbc_decrypt(data:substr(data, 0, pos - 1) , key:key, iv:iv);
    if(isnull(ret)) return NULL;

    cn2 = ret[1];
    decrypted = ret[0];
  }
  # Ciphertext is 2 blocks; use iv for cn2
  else cn2 = iv;

  ret = aes_cbc_decrypt(data:cn1, key:key, iv:crap(data:'\x00',length: blksz)); 
  if(isnull(ret))   return NULL;
  dn = ret[0];
  c = cn + crap(data:'\x00', length: blksz - m);
  xn = xor(in1: dn, in2: c);
  pn = substr(xn, 0, m - 1);
  if(m < blksz ) 
    en1 = cn + substr(xn, m, blksz - 1);
  else
    en1 = cn;

  ret = aes_cbc_decrypt(data:en1, key:key, iv:crap(data:'\x00',length: blksz)); 
  if(isnull(ret))   return NULL;
  xn1 = ret[0];
  pn1 = xor(in1: xn1, in2: cn2);
  ret[0] = decrypted + pn1 + pn;
  ret[1] = cn1; 

  return ret;
}

#############################################################
# Functions to support computing UMAC
#   Message Authentication Code using Universal Hashing
#
#  https://tools.ietf.org/html/rfc4418
#############################################################

##
# Compute a MAC using universal hashing with an AES 128 cipher
# to generate pseudorandom keys and pads.
#
# @param <data>       The data to encrypt.
# @param <nonce>      A token unique to each derivation over the life
#                     of a key.
# @param <key>        An encryption key.
# @param <length:int> Length in bits of the tag to generate.
#
# @return A message authentication code
##
function umac_128(data, nonce, key, length)
{
  local_var tag = umac_uhash(message:data, key:key, taglen:length);
  local_var pad = umac_pad_derive(key:key, nonce:nonce, length:length);

  if(isnull(tag) || isnull(pad))
    return NULL;

  if(strlen(tag) != strlen(pad) || strlen(tag) != length)
    return NULL;

  local_var i;
  local_var result = '';
  for(i = 0; i < length; i+=4)
  {
    result += mkdword(getdword(blob:tag, pos:i) ^ getdword(blob:pad, pos:i));
  }

  return result;
}

##
# Compute the Universal Hash of a message given a key.
#
# @param <message:string> The message to hash.
# @param <key:string>     An encryption key used to generate a unique hash.
# @param <taglen:int>     The length of the desired hash, either 4, 8, 12 or 16 bytes.
#
# @return A universal hash of the message using the supplied key of the desired length.
##
function umac_uhash(message, key, taglen)
{
  local_var l1_iter_key, l2_iter_key, l3_iter_key1, l3_iter_key2;
  local_var i, k64;

  local_var iters = taglen / 4;
  local_var l1key = umac_key_derive(in_key:key, index:1, numbytes: 1024 + (16 * (iters - 1)));
  local_var l2key = umac_key_derive(in_key:key, index:2, numbytes: 24 * iters);
  local_var l3_key1 = umac_key_derive(in_key:key, index:3, numbytes: 64 * iters);
  local_var l3_key2 = umac_key_derive(in_key:key, index:4, numbytes: 4 * iters);

  local_var result = '';

  for(i = 0; i < iters; i++)
  {
    l1_iter_key = substr(l1key, i * 16, i * 16 + 1023);
    l2_iter_key = substr(l2key, i * 24, i * 24 + 23);
    l3_iter_key1 = substr(l3_key1, i * 64, i * 64 + 63);
    l3_iter_key2 = substr(l3_key2, i * 4, i * 4 + 3);

    local_var tag_segment = umac_l1(key:l1_iter_key, message:message);
    if(strlen(message) <= strlen(l1_iter_key))
    {
      tag_segment = crap(data:'\x00', length:8) + tag_segment;
    }
    else
    {
      k64 = make_int64(low:getdword(blob:l2_iter_key, pos: 4) & 0x01ffffff,
                       high:getdword(blob:l2_iter_key, pos: 0) & 0x01ffffff);

      tag_segment = umac_poly_64(key:k64, m_hash:tag_segment);
      tag_segment = mkdword(tag_segment[1]) + mkdword(tag_segment[0]);
      tag_segment = crap(data:'\x00', length: 16 - strlen(tag_segment)) + tag_segment;
    }

    tag_segment = umac_l3(in_key1:l3_iter_key1, in_key2:l3_iter_key2, l2hash:tag_segment);

    result += mkdword(tag_segment);
  }

  return result;
}

##
# Computes an NH hash over the message using the given key.
# Ref: RFC4418 Sec 5.2.2
# https://tools.ietf.org/html/rfc4418#page-13
#
# @param <message:string>  The message to hash
# @param <key:string>      The hash key
# @return Returns a string
##
function umac_nh(message, key)
{
  local_var t, result, i, m_plus_k, m_plus_k2, m1, m2, k1, k2;

  result = make_int64(low:0x00000000, high:0x00000000);
  t = strlen(message) / 4;
  i = 0;

  while(i < t)
  {
    m1 = getdword(blob:message, pos:i*4, order:BYTE_ORDER_LITTLE_ENDIAN);
    k1 = getdword(blob:key, pos:i*4);
    m2 = getdword(blob:message, pos:(i+4)*4, order:BYTE_ORDER_LITTLE_ENDIAN);
    k2 = getdword(blob:key, pos:(i+4)*4);
    m_plus_k = make_int64(low:m1 + k1, high:0x00000000);
    m_plus_k2 = make_int64(low:m2 + k2, high:0x00000000);
    result = add64(result, mult64(m_plus_k, m_plus_k2));

    m1 = getdword(blob:message, pos:(i+1)*4, order:BYTE_ORDER_LITTLE_ENDIAN);
    k1 = getdword(blob:key, pos:(i+1)*4);
    m2 = getdword(blob:message, pos:(i+5)*4, order:BYTE_ORDER_LITTLE_ENDIAN);
    k2 = getdword(blob:key, pos:(i+5)*4);
    m_plus_k = make_int64(low:m1 + k1, high:0x00000000);
    m_plus_k2 = make_int64(low:m2 + k2, high:0x00000000);
    result = add64(result, mult64(m_plus_k, m_plus_k2));

    m1 = getdword(blob:message, pos:(i+2)*4, order:BYTE_ORDER_LITTLE_ENDIAN);
    k1 = getdword(blob:key, pos:(i+2)*4);
    m2 = getdword(blob:message, pos:(i+6)*4, order:BYTE_ORDER_LITTLE_ENDIAN);
    k2 = getdword(blob:key, pos:(i+6)*4);
    m_plus_k = make_int64(low:m1 + k1, high:0x00000000);
    m_plus_k2 = make_int64(low:m2 + k2, high:0x00000000);
    result = add64(result, mult64(m_plus_k, m_plus_k2));

    m1 = getdword(blob:message, pos:(i+3)*4, order:BYTE_ORDER_LITTLE_ENDIAN);
    k1 = getdword(blob:key, pos:(i+3)*4);
    m2 = getdword(blob:message, pos:(i+7)*4, order:BYTE_ORDER_LITTLE_ENDIAN);
    k2 = getdword(blob:key, pos:(i+7)*4);
    m_plus_k = make_int64(low:m1 + k1, high:0x00000000);
    m_plus_k2 = make_int64(low:m2 + k2, high:0x00000000);
    result = add64(result, mult64(m_plus_k, m_plus_k2));

    i += 8;
  }

  return result;
}

##
# Compute a polynomial hash over a message using the supplied key.
#
# This is in support of umac-128-etm@openssh.com.  SSH packets above 32K should be
# broken up and individually hashed so we should not require the poly_128 variant.
#
# A direct adaptation from  umac.c:
#
#   Version 0.92 of draft-krovetz-umac-07.txt -- 2006 February 21
#
#   For a full description of UMAC message authentication see the UMAC
#   world-wide-web page at http://www.cs.ucdavis.edu/~rogaway/umac
#   Please report bugs and suggestions to the UMAC webpage.
#
#   Copyright (c) 1999-2006 Ted Krovetz
#
#  Permission to use, copy, modify, and distribute this software and
#  its documentation for any purpose and with or without fee, is hereby
#  granted provided that the above copyright notice appears in all copies
#  and in supporting documentation, and that the name of the copyright
#  holder not be used in advertising or publicity pertaining to
#  distribution of the software without specific, written prior permission.
#
#  Comments should be directed to Ted Krovetz (tdk@acm.org)
#
# @param <m_hash:string> A message to be hashed
# @param <key:string>    A key
#
# @return Returns an computed polynomial hash.
##
function umac_poly_64(m_hash, key)
{
  #2 ^ 64 - prime
  local_var offset = make_int64(low:59, high:0);

  local_var n = strlen(m_hash);
  local_var result = make_int64(low:0x00000001, high: 0x00000000);
  local_var i, x, t, data;
  for(i = 0; i < n; i += 8)
  {
    local_var key_lo = make_int64(low:key[0]);
    local_var key_hi = make_int64(low:key[1]);
    local_var res_lo = make_int64(low:result[0]);
    local_var res_hi = make_int64(low:result[1]);

    x = add64(mult64(key_hi, res_lo), mult64(key_lo, res_hi));

    result = add64(mult64(key_hi, res_hi), make_int64(low:x[1]));
    result = mult64(result, offset);
    result = add64(result, mult64(key_lo, res_lo));

    t = make_int64(high:x[0], low:0x00000000);
    result = add64(result, t);

    if(unsigned_lt64(result, t))
      result = add64(result, offset);

    data = make_int64(low:getdword(blob:m_hash, pos:i+4), high:getdword(blob:m_hash, pos:i));

    result = add64(result, data);

    if(unsigned_lt64(result, data))
      result = add64(result, offset);
  }

  return result;
}


##
# Compute the modulus of the input relative to P36, the highest
# 36-bit prime number without using division.
#
# @param <val:string> The input value.
# @return Returns the input value modulo P36
##
function mod_p36(val)
{
  local_var p36 = make_int64(high:0x0000000f, low: 0xfffffffb);
  local_var rem = rshift64(val, 36);
  val = make_int64(high:val[1] & 0x0000000f, low:val[0]);
  val = add64(val, mult64(rem, make_int64(low:5)));
  if(unsigned_gt64(val, p36))
    val = sub64(val, p36);

  return val;
}


##
# Compute a L3 Hash value for universal hashing.
# 
# @param <in_key1:string> The first key.
# @param <in_key2:string> The second key.
# @param <l2hash:string> The L2 Hash value.
#
# Returns the computed L3 Hash
##
function umac_l3(in_key1, in_key2, l2hash)
{
  local_var i, m_i, k_i;
  local_var result = make_int64(low:0);
  for(i = 0; i < 8; i++)
  {
    k_i = make_int64(high:getdword(blob:in_key1, pos:i * 8),
                     low:getdword(blob:in_key1, pos:i*8 + 4));
    m_i = make_int64(low:getword(blob:l2hash, pos:i*2));
    k_i = mod_p36(val:k_i);
    result = add64(result, mult64(m_i, k_i));
  }

  result = mod_p36(val:result);
  return result[0] ^ getdword(blob:in_key2, pos:0);
}


##
# Universal hashing key derivation (stretching).  Takes a hash
# key and generates a pseudo-random number from that hash using
# AES encryption.  Provides sufficient keying material for the
# universal hashing NH algorithm.
#
# @param <in_key:string> The provided key.
# @param <index:int> An additional specifier.
# @param <numbytes:int> The number of key bytes to produce.
# @return A pseudo-random hashing key.
##
function umac_key_derive(in_key, index, numbytes)
{
  local_var i, result, temp, data;

  #Block length for aes-128-ctr
  local_var block_len = 16;

  local_var n = numbytes / block_len;
  if(numbytes % block_len > 0)
    n++;

  result = '';
  local_var iv = crap(data:'\x00', length: block_len);
  data = crap(data:'\x00', length: block_len);

  for(i = 0; i < n; i++)
  {
    data[block_len - 9] = mkbyte(index);
    data[block_len - 1] = mkbyte(i + 1);
    temp = aes_cbc_encrypt(iv:iv, data:data, key:in_key);
    result = result + substr(temp[0], 0, block_len - 1);
  }

  return substr(result, 0, numbytes - 1);
}

##
# This function takes a key and a nonce and returns a pseudorandom pad
# for use with creating UMAC tags.
#
# @param <key:string> The key.
# @param <nonce:string> The nonce.  This should be different for every MAC tag.
# @param <length:int> The length of the desired pad.
# @return Returns a pseudo-random pad of <length> bytes.
##
function umac_pad_derive(key, nonce, length)
{
  local_var index, low_nonce;

  #Block length for aes-128-ctr
  local_var block_len = 16;
  local_var key_len = block_len;
  if(length > key_len)
    key_len = length;

  #Extract the low bits from the nonce.  Save and zero them.
  if(length <= 8)
  {
    low_nonce = getdword(blob:nonce, pos:4);
    index = low_nonce % (block_len / length);
    nonce = substr(nonce, 0, 3) + mkdword(low_nonce ^ index);
  }

  nonce = nonce + crap(data:'\x00', length:block_len - (strlen(nonce) % block_len));

  local_var result = umac_key_derive(in_key:key, index:0, numbytes:key_len);
  local_var iv = crap(data:'\x00', length: block_len);
  local_var tag = aes_cbc_encrypt(iv:iv, data:nonce, key:result);
  tag = tag[0];

  if(length <= 8)
    return substr(tag, index * length, index * length + (length - 1));

  return substr(tag, 0, length - 1);
}


##
# Performs a dword-wise big endian version of a big number as described
# in RFC-4418 for UMAC computation.
#
# @param <bignum:string> A big number in little-endian form.
# @return Returns a big-endian version of the input.
##
function umac_endian_swap(bignum)
{
  local_var n, i, w1, w2, w3, w4;

  #Only swap if little-endian
  if(get_byte_order() == BYTE_ORDER_BIG_ENDIAN)
    return bignum;

  #Prereq - bignum length is divisible by 4
  if(strlen(bignum) % 4 > 0)
    return NULL;

  n = strlen(bignum) / 4;

  for(i = 0; i < n; i++)
  {
    w1 = bignum[i * 4];
    w2 = bignum[i * 4 + 1];
    w3 = bignum[i * 4 + 2];
    w4 = bignum[i * 4 + 3];
    bignum[i * 4] = w4;
    bignum[i * 4 + 1] = w3;
    bignum[i * 4 + 2] = w2;
    bignum[i * 4 + 3] = w1;
  }

  return bignum;
}

##
# Computes the L1Hash described in RFC-4418 in support of Universal
# Hashing.
#
# @param <key:string>    A hash key.
# @param <message:string A message to hash.
# @return Returns the L1Hash of the message using the key.
##
function umac_l1(key, message)
{
  local_var t, i, start, end, result, m_i, ulen, mlen, y, pad, padlen;

  #Key must be 1024 bytes
  if(strlen(key) != 1024)
    return NULL;

  t = (strlen(message) + 1023) / 1024;
  mlen = strlen(message);
  padlen = 32 - (mlen % 32);
  pad = crap(data:'\x00', length:padlen);
  if(t == 0)
  {
    y = umac_nh(key:key, message:pad);
    return mkdword(y[1]) + mkdword(y[0]);
  }

  result = '';
  for(i = 0; i < t; i++)
  {
    start = 1024 * i;
    end = start + 1024;
    if(end > mlen)
    {
      end = mlen;
      m_i = substr(message, start, end - 1) + pad;
    }
    else
    {
      m_i = substr(message, start, end - 1);
    }

    ulen = make_int64(low:(end - start) * 8, high:0x00000000);
    m_i = umac_endian_swap(bignum:m_i);
    if(isnull(m_i))
      return NULL;

    y = add64(umac_nh(key:key, message:m_i), ulen);
    result += mkdword(y[1]) + mkdword(y[0]);
  }
  return result;
}

##
# Computes the HMAC-based Key Derivation Function Step 1: Extract described in RFC-5869
# using HMAC_SHA256
#
# @param <key:string>   input key material
# @param <salt:string>  optional salt value
# @return Returns pseudorandom key
##
function hkdf_extract(salt, key)
{
  if (isnull(salt))
    salt = mkbyte(0x00);

  return crypto_mac(type:"HMAC_SHA256", key:salt, data:key);
}

##
# Computes the HMAC-based Key Derivation Function Step 2: Expand described in RFC-5869
# using HMAC_SHA256
#
# @param <key:string>   key (typically output from HKDF-Extract)
# @param <info:string>  info
# @param <length:int>   length of output in octets
# @return Returns pseudorandom key of requested length
##
function hkdf_expand(key, info, length)
{
  local_var output, n, t, i, data;
  local_var hash_len = 32; # HMAC_SHA256

  # celing(length / hash_len)
  n = (length + hash_len - 1 ) / hash_len;

  t = "";

  for (i = 0; i < n; i++)
  {
    data = t + info + mkbyte(i+1);
    t = crypto_mac(type:"HMAC_SHA256", key:key, data:data);
    output += t;
  }

  output = substr(output, 0, length - 1);

  return output;
}

##
# Computes the HKDF-Expand-Label function described in RFC-8446
# using HMAC_SHA256
#
# @param <secret:string>  secret (typically key output from HKDF-Extract)
# @param <label:string>   label
# @param <context:string> context data
# @param <length:int>     length of output in octets
# @return Returns pseudorandom key of requested length
##
function hkdf_expand_label(secret, label, context, length)
{
  local_var info;

  info = mkword(length) + mkbyte(strlen(label) + 6) + "tls13 " + label + mkbyte(strlen(context)) + context;

  return hkdf_expand(key:secret, info:info, length:length);
}

####################################################################################
# RC2 functions and constants
#

##
# RC2 key expansion.  Takes a variable length input key and
# produces an expanded key consisting of 64 words.
#
# @param <key:bytes> The encryption key.
#
# @return Returns a 128 byte sequence that is the expanded key.
# @remark All word operations are little-endian with the LSB first.
##
function rc2_expand_key(key)
{
  var PITABLE =
      [
        0xd9, 0x78, 0xf9, 0xc4, 0x19, 0xdd, 0xb5, 0xed, 0x28, 0xe9, 0xfd, 0x79, 0x4a, 0xa0, 0xd8, 0x9d,
        0xc6, 0x7e, 0x37, 0x83, 0x2b, 0x76, 0x53, 0x8e, 0x62, 0x4c, 0x64, 0x88, 0x44, 0x8b, 0xfb, 0xa2,
        0x17, 0x9a, 0x59, 0xf5, 0x87, 0xb3, 0x4f, 0x13, 0x61, 0x45, 0x6d, 0x8d, 0x09, 0x81, 0x7d, 0x32,
        0xbd, 0x8f, 0x40, 0xeb, 0x86, 0xb7, 0x7b, 0x0b, 0xf0, 0x95, 0x21, 0x22, 0x5c, 0x6b, 0x4e, 0x82,
        0x54, 0xd6, 0x65, 0x93, 0xce, 0x60, 0xb2, 0x1c, 0x73, 0x56, 0xc0, 0x14, 0xa7, 0x8c, 0xf1, 0xdc,
        0x12, 0x75, 0xca, 0x1f, 0x3b, 0xbe, 0xe4, 0xd1, 0x42, 0x3d, 0xd4, 0x30, 0xa3, 0x3c, 0xb6, 0x26,
        0x6f, 0xbf, 0x0e, 0xda, 0x46, 0x69, 0x07, 0x57, 0x27, 0xf2, 0x1d, 0x9b, 0xbc, 0x94, 0x43, 0x03,
        0xf8, 0x11, 0xc7, 0xf6, 0x90, 0xef, 0x3e, 0xe7, 0x06, 0xc3, 0xd5, 0x2f, 0xc8, 0x66, 0x1e, 0xd7,
        0x08, 0xe8, 0xea, 0xde, 0x80, 0x52, 0xee, 0xf7, 0x84, 0xaa, 0x72, 0xac, 0x35, 0x4d, 0x6a, 0x2a,
        0x96, 0x1a, 0xd2, 0x71, 0x5a, 0x15, 0x49, 0x74, 0x4b, 0x9f, 0xd0, 0x5e, 0x04, 0x18, 0xa4, 0xec,
        0xc2, 0xe0, 0x41, 0x6e, 0x0f, 0x51, 0xcb, 0xcc, 0x24, 0x91, 0xaf, 0x50, 0xa1, 0xf4, 0x70, 0x39,
        0x99, 0x7c, 0x3a, 0x85, 0x23, 0xb8, 0xb4, 0x7a, 0xfc, 0x02, 0x36, 0x5b, 0x25, 0x55, 0x97, 0x31,
        0x2d, 0x5d, 0xfa, 0x98, 0xe3, 0x8a, 0x92, 0xae, 0x05, 0xdf, 0x29, 0x10, 0x67, 0x6c, 0xba, 0xc9,
        0xd3, 0x00, 0xe6, 0xcf, 0xe1, 0x9e, 0xa8, 0x2c, 0x63, 0x16, 0x01, 0x3f, 0x58, 0xe2, 0x89, 0xa9,
        0x0d, 0x38, 0x34, 0x1b, 0xab, 0x33, 0xff, 0xb0, 0xbb, 0x48, 0x0c, 0x5f, 0xb9, 0xb1, 0xcd, 0x2e,
        0xc5, 0xf3, 0xdb, 0x47, 0xe5, 0xa5, 0x9c, 0x77, 0x0a, 0xa6, 0x20, 0x68, 0xfe, 0x7f, 0xc1, 0xad
      ];

  var len = strlen(key);
  var bits = len * 8;
  var expanded_key = key;

  if(empty_or_null(key) || len > 128)
    return NULL;

  if(bits <= 0 || bits > 1024)
    bits = 1024;

  var d = ord(expanded_key[len - 1]);
  var j = 0;
  var x = 0;
  for(var i = len; i < 128; i++)
  {
    x = (ord(expanded_key[j]) + d) & 0xff;
    d = PITABLE[x];
    expanded_key += raw_string(d);
    j++;
  }

  j = ((bits + 7) >> 3) & 0xffff;
  i = 128 - j;
  var c = (0xff >> (-bits & 0x07)) & 0xffff;
  d = PITABLE[ord(expanded_key[i]) & c];
  expanded_key[i] = raw_string(d);

  while(i--)
  {
    d = PITABLE[ord(expanded_key[i + j]) ^ d];
    expanded_key[i] = raw_string(d);
  }

  return expanded_key;
}

##
# Reverse mix round for RC2 decrypt algorithm.
#
# @param <round:list[dword]> Round to reverse mix.
# @param <key:bytes>        Extended RC2 key.
# @param <j:integer>        An index
#
# @return Returns the reverse-mixed round.
##
function rc2_reverse_mix(round, key, j)
{
  var r0 = round[0] & 0xffff;
  var r1 = (round[0] >> 16) & 0xffff;
  var r2 = round[1] & 0xffff;
  var r3 = (round[1] >> 16) & 0xffff;

  var x = ((r3 << 11) | (r3 >> 5)) & 0xffff;
  var kj = get_word(blob:key, pos:j-1);
  r3 = (x - ((r0 & (~r2)) + (r1 & r2) + kj)) & 0xffff;

  x = ((r2 << 13) | (r2 >> 3)) & 0xffff;
  kj = get_word(blob:key, pos:j-3);
  r2 = (x - ((r3 & (~r1)) + (r0 & r1) + kj)) & 0xffff;

  x = ((r1 << 14) | (r1 >> 2)) & 0xffff;
  kj = get_word(blob:key, pos:j-5);
  r1 = (x - ((r2 & (~r0)) + (r3 & r0) + kj)) & 0xffff;

  x = ((r0 << 15) | (r0 >> 1)) & 0xffff;
  kj = get_word(blob:key, pos:j-7);
  r0 = (x - ((r1 & (~r3)) + (r2 & r3) + kj)) & 0xffff;

  round[0] = (r1 << 16 | r0);
  round[1] = (r3 << 16 | r2);

  return round;
}

##
# Reverse mash round for RC2 decrypt algorithm.
#
# @param <round:list[dword]> Round for reverse mash.
# @param <key:bytes>        Extended RC2 key.
#
# @return Returns the reverse-mashed round.
##
function rc2_reverse_mash(round, key)
{
  var r0 = round[0] & 0xffff;
  var r1 = (round[0] >> 16) & 0xffff;
  var r2 = round[1] & 0xffff;
  var r3 = (round[1] >> 16) & 0xffff;

  r3 = (r3 - get_word(blob:key, pos:(r2 & 63) * 2)) & 0xffff;
  r2 = (r2 - get_word(blob:key, pos:(r1 & 63) * 2)) & 0xffff;
  r1 = (r1 - get_word(blob:key, pos:(r0 & 63) * 2)) & 0xffff;
  r0 = (r0 - get_word(blob:key, pos:(r3 & 63) * 2)) & 0xffff;

  round[0] = (r1 << 16 | r0);
  round[1] = (r3 << 16 | r2);

  return round;
}


##
# Decrypts a block of RC2 ciphertext.
#
# @param <ciphertext:bytes> The ciphertext to decrypt.
# @param <key:bytes>        An expanded RC2 key (128 bytes);
#
# @return Returns a decrypted block.
##
function rc2_decrypt(ciphertext, key)
{
  var j = 127;

  ciphertext = rc2_reverse_mix(round:ciphertext, key:key, j:j);
  j -= 8;
  ciphertext = rc2_reverse_mix(round:ciphertext, key:key, j:j);
  j -= 8;
  ciphertext = rc2_reverse_mix(round:ciphertext, key:key, j:j);
  j -= 8;
  ciphertext = rc2_reverse_mix(round:ciphertext, key:key, j:j);
  j -= 8;
  ciphertext = rc2_reverse_mix(round:ciphertext, key:key, j:j);
  j -= 8;

  ciphertext = rc2_reverse_mash(round:ciphertext, key:key);

  ciphertext = rc2_reverse_mix(round:ciphertext, key:key, j:j);
  j -= 8;
  ciphertext = rc2_reverse_mix(round:ciphertext, key:key, j:j);
  j -= 8;
  ciphertext = rc2_reverse_mix(round:ciphertext, key:key, j:j);
  j -= 8;
  ciphertext = rc2_reverse_mix(round:ciphertext, key:key, j:j);
  j -= 8;
  ciphertext = rc2_reverse_mix(round:ciphertext, key:key, j:j);
  j -= 8;
  ciphertext = rc2_reverse_mix(round:ciphertext, key:key, j:j);
  j -= 8;

  ciphertext = rc2_reverse_mash(round:ciphertext, key:key);

  ciphertext = rc2_reverse_mix(round:ciphertext, key:key, j:j);
  j -= 8;
  ciphertext = rc2_reverse_mix(round:ciphertext, key:key, j:j);
  j -= 8;
  ciphertext = rc2_reverse_mix(round:ciphertext, key:key, j:j);
  j -= 8;
  ciphertext = rc2_reverse_mix(round:ciphertext, key:key, j:j);
  j -= 8;
  ciphertext = rc2_reverse_mix(round:ciphertext, key:key, j:j);
  j -= 8;

  return ciphertext;
}


##
# Decrypts the ciphertext using RC2 in CBC mode.
# 
# @param <ciphertext:bytes> The ciphertext to decrypt.
# @param <key:bytes>        The decryption key.
# @param <iv:bytes>         An initialization vector.
#
# @return Returns the decrypted ciphertext or NULL if there is an error.
##
function decrypt_rc2_cbc(ciphertext, key, iv)
{
  var expandedKey = rc2_expand_key(key:key);
  if(isnull(expandedKey) || strlen(iv) != 8)
    return NULL;

  var xor0 = get_dword(blob:iv, pos:0);
  var xor1 = get_dword(blob:iv, pos:4);

  var length = strlen(ciphertext);
  var blockCiphertext = [0, 0];
  var decryptedBlock;

  var result = '';

  for(var l = 0; l < length - 7; l += 8)
  {
    blockCiphertext[0] = get_dword(blob:ciphertext, pos:l);
    blockCiphertext[1] = get_dword(blob:ciphertext, pos:l + 4);

    decryptedBlock = rc2_decrypt(ciphertext:blockCiphertext, key:expandedKey);

    result += raw_dword(d:decryptedBlock[0] ^ xor0);
    result += raw_dword(d:decryptedBlock[1] ^ xor1);
    xor0 = blockCiphertext[0];
    xor1 = blockCiphertext[1];
  }

  if(l > length)
  {
    var resid = crap(data:'\x00', length:8);
    for(var i = l - 8; i < length; i++)
       resid[i - l + 8] = ciphertext[i];

    blockCiphertext[0] = get_dword(blob:resid, pos:0);
    blockCiphertext[1] = get_dword(blob:resid, pos:4);

    decryptedBlock = rc2_decrypt(ciphertext:blockCiphertext, key:expandedKey);

    result += raw_dword(d:decryptedBlock[0] ^ xor0);
    result += raw_dword(d:decryptedBlock[1] ^ xor1);
  }

  return [result];
}

##
# Computes a Diffie-Hellman public key given a generator, a prime
# modulus and a public key.  This wraps the dh_generate_key Nessus
# engine function to allow computation of public keys using a prime
# modulus smaller than the smallest prime modulus allowed by OpenSSL.
#
# @param [p:big number]          Prime Modulus
# @param [g:big number]          Generator
# @param [priv:big number]       Private Key
# @param [test_fallback:boolean] (Optional) Used to test the fallback method
#
# @return Returns the Diffie-Hellman public key computed from the supplied
#         parameters
##
function dh_generate_key_wrapper(p, g, priv, test_fallback)
{
  if(isnull(test_fallback))
    test_fallback = FALSE;

  #As of OpenSSL 3.0 dh_generate_key enforces a minimum 512-bit prime modulus.
  if(strlen(p) >= 64 && !test_fallback)
    return dh_generate_key(p:p, g:g, priv:priv);

  var res = bn_mod_exp(g, priv, p);
  if(ord(res[0]) & 0x80)
    return '\x00' + res;

  return res;
}


##
# Computes a Diffie-Hellman shared key given a generator, a prime modulus,
# a foreign public key, and a local key pair.  This wraps the dh_compute_key
# Nessus engine function to allow computation of shared keys using a
# prime modulus smaller than the smallest prime modulus allowed by OpenSSL.
# 
# @param [p:big number]             Prime Modulus
# @param [g:big number]             Generator
# @param [dh_server_pub:big number] A foreign public key.
# @param [pub_key:big number]       The local public key.
# @param [priv_key:big number]      The local private key.
# @param [test_fallback:boolean] (Optional) Used to test the fallback method
#
# @return Returns the Diffie-Hellman shared key computed from the supplied
#         parameters.
##
function dh_compute_key_wrapper(p, g, dh_server_pub, pub_key, priv_key, test_fallback)
{
  if(isnull(test_fallback))
    test_fallback = FALSE;

  #As of OpenSSL 3.0 dh_generate_key enforces a minimum 512-bit prime modulus.
  if(strlen(p) >= 64 && !test_fallback)
    return dh_compute_key(p:p, g:g, dh_server_pub:dh_server_pub, pub_key:pub_key, priv_key:priv_key);

  var res = bn_mod_exp(dh_server_pub, priv_key, p);
  if(ord(res[0]) & 0x80)
    return '\x00' + res;

  return res;
}

############################################################
#BLOWFISH - refactored from ssh1_func.inc
#

global_var PArray, SBoxes;
global_var bf_enc_iv, bf_dec_iv;
global_var _bf_dec_iv, _bf_enc_iv;

global_var NPASS = 16;

global_var bf_P = make_list (
  0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344,
  0xa4093822, 0x299f31d0, 0x082efa98, 0xec4e6c89,
  0x452821e6, 0x38d01377, 0xbe5466cf, 0x34e90c6c,
  0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5, 0xb5470917,
  0x9216d5d9, 0x8979fb1b
);

global_var bf_S = make_list (
  0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7,
  0xb8e1afed, 0x6a267e96, 0xba7c9045, 0xf12c7f99,
  0x24a19947, 0xb3916cf7, 0x0801f2e2, 0x858efc16,
  0x636920d8, 0x71574e69, 0xa458fea3, 0xf4933d7e,
  0x0d95748f, 0x728eb658, 0x718bcd58, 0x82154aee,
  0x7b54a41d, 0xc25a59b5, 0x9c30d539, 0x2af26013,
  0xc5d1b023, 0x286085f0, 0xca417918, 0xb8db38ef,
  0x8e79dcb0, 0x603a180e, 0x6c9e0e8b, 0xb01e8a3e,
  0xd71577c1, 0xbd314b27, 0x78af2fda, 0x55605c60,
  0xe65525f3, 0xaa55ab94, 0x57489862, 0x63e81440,
  0x55ca396a, 0x2aab10b6, 0xb4cc5c34, 0x1141e8ce,
  0xa15486af, 0x7c72e993, 0xb3ee1411, 0x636fbc2a,
  0x2ba9c55d, 0x741831f6, 0xce5c3e16, 0x9b87931e,
  0xafd6ba33, 0x6c24cf5c, 0x7a325381, 0x28958677,
  0x3b8f4898, 0x6b4bb9af, 0xc4bfe81b, 0x66282193,
  0x61d809cc, 0xfb21a991, 0x487cac60, 0x5dec8032,
  0xef845d5d, 0xe98575b1, 0xdc262302, 0xeb651b88,
  0x23893e81, 0xd396acc5, 0x0f6d6ff3, 0x83f44239,
  0x2e0b4482, 0xa4842004, 0x69c8f04a, 0x9e1f9b5e,
  0x21c66842, 0xf6e96c9a, 0x670c9c61, 0xabd388f0,
  0x6a51a0d2, 0xd8542f68, 0x960fa728, 0xab5133a3,
  0x6eef0b6c, 0x137a3be4, 0xba3bf050, 0x7efb2a98,
  0xa1f1651d, 0x39af0176, 0x66ca593e, 0x82430e88,
  0x8cee8619, 0x456f9fb4, 0x7d84a5c3, 0x3b8b5ebe,
  0xe06f75d8, 0x85c12073, 0x401a449f, 0x56c16aa6,
  0x4ed3aa62, 0x363f7706, 0x1bfedf72, 0x429b023d,
  0x37d0d724, 0xd00a1248, 0xdb0fead3, 0x49f1c09b,
  0x075372c9, 0x80991b7b, 0x25d479d8, 0xf6e8def7,
  0xe3fe501a, 0xb6794c3b, 0x976ce0bd, 0x04c006ba,
  0xc1a94fb6, 0x409f60c4, 0x5e5c9ec2, 0x196a2463,
  0x68fb6faf, 0x3e6c53b5, 0x1339b2eb, 0x3b52ec6f,
  0x6dfc511f, 0x9b30952c, 0xcc814544, 0xaf5ebd09,
  0xbee3d004, 0xde334afd, 0x660f2807, 0x192e4bb3,
  0xc0cba857, 0x45c8740f, 0xd20b5f39, 0xb9d3fbdb,
  0x5579c0bd, 0x1a60320a, 0xd6a100c6, 0x402c7279,
  0x679f25fe, 0xfb1fa3cc, 0x8ea5e9f8, 0xdb3222f8,
  0x3c7516df, 0xfd616b15, 0x2f501ec8, 0xad0552ab,
  0x323db5fa, 0xfd238760, 0x53317b48, 0x3e00df82,
  0x9e5c57bb, 0xca6f8ca0, 0x1a87562e, 0xdf1769db,
  0xd542a8f6, 0x287effc3, 0xac6732c6, 0x8c4f5573,
  0x695b27b0, 0xbbca58c8, 0xe1ffa35d, 0xb8f011a0,
  0x10fa3d98, 0xfd2183b8, 0x4afcb56c, 0x2dd1d35b,
  0x9a53e479, 0xb6f84565, 0xd28e49bc, 0x4bfb9790,
  0xe1ddf2da, 0xa4cb7e33, 0x62fb1341, 0xcee4c6e8,
  0xef20cada, 0x36774c01, 0xd07e9efe, 0x2bf11fb4,
  0x95dbda4d, 0xae909198, 0xeaad8e71, 0x6b93d5a0,
  0xd08ed1d0, 0xafc725e0, 0x8e3c5b2f, 0x8e7594b7,
  0x8ff6e2fb, 0xf2122b64, 0x8888b812, 0x900df01c,
  0x4fad5ea0, 0x688fc31c, 0xd1cff191, 0xb3a8c1ad,
  0x2f2f2218, 0xbe0e1777, 0xea752dfe, 0x8b021fa1,
  0xe5a0cc0f, 0xb56f74e8, 0x18acf3d6, 0xce89e299,
  0xb4a84fe0, 0xfd13e0b7, 0x7cc43b81, 0xd2ada8d9,
  0x165fa266, 0x80957705, 0x93cc7314, 0x211a1477,
  0xe6ad2065, 0x77b5fa86, 0xc75442f5, 0xfb9d35cf,
  0xebcdaf0c, 0x7b3e89a0, 0xd6411bd3, 0xae1e7e49,
  0x00250e2d, 0x2071b35e, 0x226800bb, 0x57b8e0af,
  0x2464369b, 0xf009b91e, 0x5563911d, 0x59dfa6aa,
  0x78c14389, 0xd95a537f, 0x207d5ba2, 0x02e5b9c5,
  0x83260376, 0x6295cfa9, 0x11c81968, 0x4e734a41,
  0xb3472dca, 0x7b14a94a, 0x1b510052, 0x9a532915,
  0xd60f573f, 0xbc9bc6e4, 0x2b60a476, 0x81e67400,
  0x08ba6fb5, 0x571be91f, 0xf296ec6b, 0x2a0dd915,
  0xb6636521, 0xe7b9f9b6, 0xff34052e, 0xc5855664,
  0x53b02d5d, 0xa99f8fa1, 0x08ba4799, 0x6e85076a,
  0x4b7a70e9, 0xb5b32944, 0xdb75092e, 0xc4192623,
  0xad6ea6b0, 0x49a7df7d, 0x9cee60b8, 0x8fedb266,
  0xecaa8c71, 0x699a17ff, 0x5664526c, 0xc2b19ee1,
  0x193602a5, 0x75094c29, 0xa0591340, 0xe4183a3e,
  0x3f54989a, 0x5b429d65, 0x6b8fe4d6, 0x99f73fd6,
  0xa1d29c07, 0xefe830f5, 0x4d2d38e6, 0xf0255dc1,
  0x4cdd2086, 0x8470eb26, 0x6382e9c6, 0x021ecc5e,
  0x09686b3f, 0x3ebaefc9, 0x3c971814, 0x6b6a70a1,
  0x687f3584, 0x52a0e286, 0xb79c5305, 0xaa500737,
  0x3e07841c, 0x7fdeae5c, 0x8e7d44ec, 0x5716f2b8,
  0xb03ada37, 0xf0500c0d, 0xf01c1f04, 0x0200b3ff,
  0xae0cf51a, 0x3cb574b2, 0x25837a58, 0xdc0921bd,
  0xd19113f9, 0x7ca92ff6, 0x94324773, 0x22f54701,
  0x3ae5e581, 0x37c2dadc, 0xc8b57634, 0x9af3dda7,
  0xa9446146, 0x0fd0030e, 0xecc8c73e, 0xa4751e41,
  0xe238cd99, 0x3bea0e2f, 0x3280bba1, 0x183eb331,
  0x4e548b38, 0x4f6db908, 0x6f420d03, 0xf60a04bf,
  0x2cb81290, 0x24977c79, 0x5679b072, 0xbcaf89af,
  0xde9a771f, 0xd9930810, 0xb38bae12, 0xdccf3f2e,
  0x5512721f, 0x2e6b7124, 0x501adde6, 0x9f84cd87,
  0x7a584718, 0x7408da17, 0xbc9f9abc, 0xe94b7d8c,
  0xec7aec3a, 0xdb851dfa, 0x63094366, 0xc464c3d2,
  0xef1c1847, 0x3215d908, 0xdd433b37, 0x24c2ba16,
  0x12a14d43, 0x2a65c451, 0x50940002, 0x133ae4dd,
  0x71dff89e, 0x10314e55, 0x81ac77d6, 0x5f11199b,
  0x043556f1, 0xd7a3c76b, 0x3c11183b, 0x5924a509,
  0xf28fe6ed, 0x97f1fbfa, 0x9ebabf2c, 0x1e153c6e,
  0x86e34570, 0xeae96fb1, 0x860e5e0a, 0x5a3e2ab3,
  0x771fe71c, 0x4e3d06fa, 0x2965dcb9, 0x99e71d0f,
  0x803e89d6, 0x5266c825, 0x2e4cc978, 0x9c10b36a,
  0xc6150eba, 0x94e2ea78, 0xa5fc3c53, 0x1e0a2df4,
  0xf2f74ea7, 0x361d2b3d, 0x1939260f, 0x19c27960,
  0x5223a708, 0xf71312b6, 0xebadfe6e, 0xeac31f66,
  0xe3bc4595, 0xa67bc883, 0xb17f37d1, 0x018cff28,
  0xc332ddef, 0xbe6c5aa5, 0x65582185, 0x68ab9802,
  0xeecea50f, 0xdb2f953b, 0x2aef7dad, 0x5b6e2f84,
  0x1521b628, 0x29076170, 0xecdd4775, 0x619f1510,
  0x13cca830, 0xeb61bd96, 0x0334fe1e, 0xaa0363cf,
  0xb5735c90, 0x4c70a239, 0xd59e9e0b, 0xcbaade14,
  0xeecc86bc, 0x60622ca7, 0x9cab5cab, 0xb2f3846e,
  0x648b1eaf, 0x19bdf0ca, 0xa02369b9, 0x655abb50,
  0x40685a32, 0x3c2ab4b3, 0x319ee9d5, 0xc021b8f7,
  0x9b540b19, 0x875fa099, 0x95f7997e, 0x623d7da8,
  0xf837889a, 0x97e32d77, 0x11ed935f, 0x16681281,
  0x0e358829, 0xc7e61fd6, 0x96dedfa1, 0x7858ba99,
  0x57f584a5, 0x1b227263, 0x9b83c3ff, 0x1ac24696,
  0xcdb30aeb, 0x532e3054, 0x8fd948e4, 0x6dbc3128,
  0x58ebf2ef, 0x34c6ffea, 0xfe28ed61, 0xee7c3c73,
  0x5d4a14d9, 0xe864b7e3, 0x42105d14, 0x203e13e0,
  0x45eee2b6, 0xa3aaabea, 0xdb6c4f15, 0xfacb4fd0,
  0xc742f442, 0xef6abbb5, 0x654f3b1d, 0x41cd2105,
  0xd81e799e, 0x86854dc7, 0xe44b476a, 0x3d816250,
  0xcf62a1f2, 0x5b8d2646, 0xfc8883a0, 0xc1c7b6a3,
  0x7f1524c3, 0x69cb7492, 0x47848a0b, 0x5692b285,
  0x095bbf00, 0xad19489d, 0x1462b174, 0x23820e00,
  0x58428d2a, 0x0c55f5ea, 0x1dadf43e, 0x233f7061,
  0x3372f092, 0x8d937e41, 0xd65fecf1, 0x6c223bdb,
  0x7cde3759, 0xcbee7460, 0x4085f2a7, 0xce77326e,
  0xa6078084, 0x19f8509e, 0xe8efd855, 0x61d99735,
  0xa969a7aa, 0xc50c06c2, 0x5a04abfc, 0x800bcadc,
  0x9e447a2e, 0xc3453484, 0xfdd56705, 0x0e1e9ec9,
  0xdb73dbd3, 0x105588cd, 0x675fda79, 0xe3674340,
  0xc5c43465, 0x713e38d8, 0x3d28f89e, 0xf16dff20,
  0x153e21e7, 0x8fb03d4a, 0xe6e39f2b, 0xdb83adf7,
  0xe93d5a68, 0x948140f7, 0xf64c261c, 0x94692934,
  0x411520f7, 0x7602d4f7, 0xbcf46b2e, 0xd4a20068,
  0xd4082471, 0x3320f46a, 0x43b7d4b7, 0x500061af,
  0x1e39f62e, 0x97244546, 0x14214f74, 0xbf8b8840,
  0x4d95fc1d, 0x96b591af, 0x70f4ddd3, 0x66a02f45,
  0xbfbc09ec, 0x03bd9785, 0x7fac6dd0, 0x31cb8504,
  0x96eb27b3, 0x55fd3941, 0xda2547e6, 0xabca0a9a,
  0x28507825, 0x530429f4, 0x0a2c86da, 0xe9b66dfb,
  0x68dc1462, 0xd7486900, 0x680ec0a4, 0x27a18dee,
  0x4f3ffea2, 0xe887ad8c, 0xb58ce006, 0x7af4d6b6,
  0xaace1e7c, 0xd3375fec, 0xce78a399, 0x406b2a42,
  0x20fe9e35, 0xd9f385b9, 0xee39d7ab, 0x3b124e8b,
  0x1dc9faf7, 0x4b6d1856, 0x26a36631, 0xeae397b2,
  0x3a6efa74, 0xdd5b4332, 0x6841e7f7, 0xca7820fb,
  0xfb0af54e, 0xd8feb397, 0x454056ac, 0xba489527,
  0x55533a3a, 0x20838d87, 0xfe6ba9b7, 0xd096954b,
  0x55a867bc, 0xa1159a58, 0xcca92963, 0x99e1db33,
  0xa62a4a56, 0x3f3125f9, 0x5ef47e1c, 0x9029317c,
  0xfdf8e802, 0x04272f70, 0x80bb155c, 0x05282ce3,
  0x95c11548, 0xe4c66d22, 0x48c1133f, 0xc70f86dc,
  0x07f9c9ee, 0x41041f0f, 0x404779a4, 0x5d886e17,
  0x325f51eb, 0xd59bc0d1, 0xf2bcc18f, 0x41113564,
  0x257b7834, 0x602a9c60, 0xdff8e8a3, 0x1f636c1b,
  0x0e12b4c2, 0x02e1329e, 0xaf664fd1, 0xcad18115,
  0x6b2395e0, 0x333e92e1, 0x3b240b62, 0xeebeb922,
  0x85b2a20e, 0xe6ba0d99, 0xde720c8c, 0x2da2f728,
  0xd0127845, 0x95b794fd, 0x647d0862, 0xe7ccf5f0,
  0x5449a36f, 0x877d48fa, 0xc39dfd27, 0xf33e8d1e,
  0x0a476341, 0x992eff74, 0x3a6f6eab, 0xf4f8fd37,
  0xa812dc60, 0xa1ebddf8, 0x991be14c, 0xdb6e6b0d,
  0xc67b5510, 0x6d672c37, 0x2765d43b, 0xdcd0e804,
  0xf1290dc7, 0xcc00ffa3, 0xb5390f92, 0x690fed0b,
  0x667b9ffb, 0xcedb7d9c, 0xa091cf0b, 0xd9155ea3,
  0xbb132f88, 0x515bad24, 0x7b9479bf, 0x763bd6eb,
  0x37392eb3, 0xcc115979, 0x8026e297, 0xf42e312d,
  0x6842ada7, 0xc66a2b3b, 0x12754ccc, 0x782ef11c,
  0x6a124237, 0xb79251e7, 0x06a1bbe6, 0x4bfb6350,
  0x1a6b1018, 0x11caedfa, 0x3d25bdd8, 0xe2e1c3c9,
  0x44421659, 0x0a121386, 0xd90cec6e, 0xd5abea2a,
  0x64af674e, 0xda86a85f, 0xbebfe988, 0x64e4c3fe,
  0x9dbc8057, 0xf0f7c086, 0x60787bf8, 0x6003604d,
  0xd1fd8346, 0xf6381fb0, 0x7745ae04, 0xd736fccc,
  0x83426b33, 0xf01eab71, 0xb0804187, 0x3c005e5f,
  0x77a057be, 0xbde8ae24, 0x55464299, 0xbf582e61,
  0x4e58f48f, 0xf2ddfda2, 0xf474ef38, 0x8789bdc2,
  0x5366f9c3, 0xc8b38e74, 0xb475f255, 0x46fcd9b9,
  0x7aeb2661, 0x8b1ddf84, 0x846a0e79, 0x915f95e2,
  0x466e598e, 0x20b45770, 0x8cd55591, 0xc902de4c,
  0xb90bace1, 0xbb8205d0, 0x11a86248, 0x7574a99e,
  0xb77f19b6, 0xe0a9dc09, 0x662d09a1, 0xc4324633,
  0xe85a1f02, 0x09f0be8c, 0x4a99a025, 0x1d6efe10,
  0x1ab93d1d, 0x0ba5a4df, 0xa186f20f, 0x2868f169,
  0xdcb7da83, 0x573906fe, 0xa1e2ce9b, 0x4fcd7f52,
  0x50115e01, 0xa70683fa, 0xa002b5c4, 0x0de6d027,
  0x9af88c27, 0x773f8641, 0xc3604c06, 0x61a806b5,
  0xf0177a28, 0xc0f586e0, 0x006058aa, 0x30dc7d62,
  0x11e69ed7, 0x2338ea63, 0x53c2dd94, 0xc2c21634,
  0xbbcbee56, 0x90bcb6de, 0xebfc7da1, 0xce591d76,
  0x6f05e409, 0x4b7c0188, 0x39720a3d, 0x7c927c24,
  0x86e3725f, 0x724d9db9, 0x1ac15bb4, 0xd39eb8fc,
  0xed545578, 0x08fca5b5, 0xd83d7cd3, 0x4dad0fc4,
  0x1e50ef5e, 0xb161e6f8, 0xa28514d9, 0x6c51133c,
  0x6fd5c7e7, 0x56e14ec4, 0x362abfce, 0xddc6c837,
  0xd79a3234, 0x92638212, 0x670efa8e, 0x406000e0,
  0x3a39ce37, 0xd3faf5cf, 0xabc27737, 0x5ac52d1b,
  0x5cb0679e, 0x4fa33742, 0xd3822740, 0x99bc9bbe,
  0xd5118e9d, 0xbf0f7315, 0xd62d1c7e, 0xc700c47b,
  0xb78c1b6b, 0x21a19045, 0xb26eb1be, 0x6a366eb4,
  0x5748ab2f, 0xbc946e79, 0xc6a376d2, 0x6549c2c8,
  0x530ff8ee, 0x468dde7d, 0xd5730a1d, 0x4cd04dc6,
  0x2939bbdb, 0xa9ba4650, 0xac9526e8, 0xbe5ee304,
  0xa1fad5f0, 0x6a2d519a, 0x63ef8ce2, 0x9a86ee22,
  0xc089c2b8, 0x43242ef6, 0xa51e03aa, 0x9cf2d0a4,
  0x83c061ba, 0x9be96a4d, 0x8fe51550, 0xba645bd6,
  0x2826a2f9, 0xa73a3ae1, 0x4ba99586, 0xef5562e9,
  0xc72fefd3, 0xf752f7da, 0x3f046f69, 0x77fa0a59,
  0x80e4a915, 0x87b08601, 0x9b09e6ad, 0x3b3ee593,
  0xe990fd5a, 0x9e34d797, 0x2cf0b7d9, 0x022b8b51,
  0x96d5ac3a, 0x017da67d, 0xd1cf3ed6, 0x7c7d2d28,
  0x1f9f25cf, 0xadf2b89b, 0x5ad6b472, 0x5a88f54c,
  0xe029ac71, 0xe019a5e6, 0x47b0acfd, 0xed93fa9b,
  0xe8d3c48d, 0x283b57cc, 0xf8d56629, 0x79132e28,
  0x785f0191, 0xed756055, 0xf7960e44, 0xe3d35e8c,
  0x15056dd4, 0x88f46dba, 0x03a16125, 0x0564f0bd,
  0xc3eb9e15, 0x3c9057a2, 0x97271aec, 0xa93a072a,
  0x1b3f6d9b, 0x1e6321f5, 0xf59c66fb, 0x26dcf319,
  0x7533d928, 0xb155fdf5, 0x03563482, 0x8aba3cbb,
  0x28517711, 0xc20ad9f8, 0xabcc5167, 0xccad925f,
  0x4de81751, 0x3830dc8e, 0x379d5862, 0x9320f991,
  0xea7a90c2, 0xfb3e7bce, 0x5121ce64, 0x774fbe32,
  0xa8b6e37e, 0xc3293d46, 0x48de5369, 0x6413e680,
  0xa2ae0810, 0xdd6db224, 0x69852dfd, 0x09072166,
  0xb39a460a, 0x6445c0dd, 0x586cdecf, 0x1c20c8ae,
  0x5bbef7dd, 0x1b588d40, 0xccd2017f, 0x6bb4e3bb,
  0xdda26a7e, 0x3a59ff45, 0x3e350a44, 0xbcb4cdd5,
  0x72eacea8, 0xfa6484bb, 0x8d6612ae, 0xbf3c6f47,
  0xd29be463, 0x542f5d9e, 0xaec2771b, 0xf64e6370,
  0x740e0d8d, 0xe75b1357, 0xf8721671, 0xaf537d5d,
  0x4040cb08, 0x4eb4e2cc, 0x34d2466a, 0x0115af84,
  0xe1b00428, 0x95983a1d, 0x06b89fb4, 0xce6ea048,
  0x6f3f3b82, 0x3520ab82, 0x011a1d4b, 0x277227f8,
  0x611560b1, 0xe7933fdc, 0xbb3a792b, 0x344525bd,
  0xa08839e1, 0x51ce794b, 0x2f32c9b7, 0xa01fbac9,
  0xe01cc87e, 0xbcc7d1f6, 0xcf0111c3, 0xa1e8aac7,
  0x1a908749, 0xd44fbd9a, 0xd0dadecb, 0xd50ada38,
  0x0339c32a, 0xc6913667, 0x8df9317c, 0xe0b12b4f,
  0xf79e59b7, 0x43f5bb3a, 0xf2d519ff, 0x27d9459c,
  0xbf97222c, 0x15e6fc2a, 0x0f91fc71, 0x9b941525,
  0xfae59361, 0xceb69ceb, 0xc2a86459, 0x12baa8d1,
  0xb6c1075e, 0xe3056a0c, 0x10d25065, 0xcb03a442,
  0xe0ec6e0e, 0x1698db3b, 0x4c98a0be, 0x3278e964,
  0x9f1f9532, 0xe0d392df, 0xd3a0342b, 0x8971f21e,
  0x1b0a7441, 0x4ba3348c, 0xc5be7120, 0xc37632d8,
  0xdf359f8d, 0x9b992f2e, 0xe60b6f47, 0x0fe3f11d,
  0xe54cda54, 0x1edad891, 0xce6279cf, 0xcd3e7e6f,
  0x1618b166, 0xfd2c1d05, 0x848fd2c5, 0xf6fb2299,
  0xf523f357, 0xa6327623, 0x93a83531, 0x56cccd02,
  0xacf08162, 0x5a75ebb5, 0x6e163697, 0x88d273cc,
  0xde966292, 0x81b949d0, 0x4c50901b, 0x71c65614,
  0xe6c6c7bd, 0x327a140a, 0x45e1d006, 0xc3f27b9a,
  0xc9aa53fd, 0x62a80f00, 0xbb25bfe2, 0x35bdd2f6,
  0x71126905, 0xb2040222, 0xb6cbcf7c, 0xcd769c2b,
  0x53113ec0, 0x1640e3d3, 0x38abbd60, 0x2547adf0,
  0xba38209c, 0xf746ce76, 0x77afa1c5, 0x20756060,
  0x85cbfe4e, 0x8ae88dd8, 0x7aaaf9b0, 0x4cf9aa7e,
  0x1948c25c, 0x02fb8a8c, 0x01c36ae4, 0xd6ebe1f9,
  0x90d4f869, 0xa65cdea0, 0x3f09252d, 0xc208e69f,
  0xb74e6132, 0xce77e25b, 0x578fdfe3, 0x3ac372e6
);

PArray = make_list(); PArray[17] = 0;
SBoxes = make_list(); SBoxes[4*256 - 1] = 0;


##
# Feistel Network function for Blowfish.
# https://en.wikipedia.org/wiki/Feistel_cipher
#
# @param [a:int] Parameter L sub n
# @param [b:int] Parameter R sub n
# @param [n:int] The round count
#
# @return Returns a single Feistel round.
##
function ROUND (a,b,n)
{
  return a ^
    (((SBoxes[(b >>> 24) & 0xFF] +
       SBoxes[0x100 + ((b >>> 16) & 0xFF)]) ^
       SBoxes[0x200 + ((b >>> 8) & 0xFF)]) +
       SBoxes[0x300 + (b & 0xFF)]) ^
    PArray[n];
}


##
# A single blowfish encryption step
#
# @param [data:int] A dword integer to encipher.
# @return Returns the conmputed value
##
function blowfish_encipher (data)
{
  local_var Xl, Xr;

  Xl = get_dword(blob:data, pos:0);
  Xr = get_dword(blob:data, pos:4);

  Xl = Xl ^ PArray[0];
  Xr = ROUND(a:Xr, b:Xl, n:1);
  Xl = ROUND(a:Xl, b:Xr, n:2);
  Xr = ROUND(a:Xr, b:Xl, n:3);
  Xl = ROUND(a:Xl, b:Xr, n:4);
  Xr = ROUND(a:Xr, b:Xl, n:5);
  Xl = ROUND(a:Xl, b:Xr, n:6);
  Xr = ROUND(a:Xr, b:Xl, n:7);
  Xl = ROUND(a:Xl, b:Xr, n:8);
  Xr = ROUND(a:Xr, b:Xl, n:9);
  Xl = ROUND(a:Xl, b:Xr, n:10);
  Xr = ROUND(a:Xr, b:Xl, n:11);
  Xl = ROUND(a:Xl, b:Xr, n:12);
  Xr = ROUND(a:Xr, b:Xl, n:13);
  Xl = ROUND(a:Xl, b:Xr, n:14);
  Xr = ROUND(a:Xr, b:Xl, n:15);
  Xl = ROUND(a:Xl, b:Xr, n:16);
  Xr = Xr ^ PArray[17];

  return raw_dword(d:Xr) + raw_dword(d:Xl);
}


##
# A single blowfish decryption step
#
# @param [data:int] A dword integer to encipher.
# @return Returns the conmputed value
##
function blowfish_decipher (data)
{
  local_var Xl, Xr;

  Xl = get_dword(blob:data, pos:0);
  Xr = get_dword(blob:data, pos:4);

  Xl = Xl ^ PArray[17];
  Xr = ROUND(a:Xr, b:Xl, n:16);
  Xl = ROUND(a:Xl, b:Xr, n:15);
  Xr = ROUND(a:Xr, b:Xl, n:14);
  Xl = ROUND(a:Xl, b:Xr, n:13);
  Xr = ROUND(a:Xr, b:Xl, n:12);
  Xl = ROUND(a:Xl, b:Xr, n:11);
  Xr = ROUND(a:Xr, b:Xl, n:10);
  Xl = ROUND(a:Xl, b:Xr, n:9);
  Xr = ROUND(a:Xr, b:Xl, n:8);
  Xl = ROUND(a:Xl, b:Xr, n:7);
  Xr = ROUND(a:Xr, b:Xl, n:6);
  Xl = ROUND(a:Xl, b:Xr, n:5);
  Xr = ROUND(a:Xr, b:Xl, n:4);
  Xl = ROUND(a:Xl, b:Xr, n:3);
  Xr = ROUND(a:Xr, b:Xl, n:2);
  Xl = ROUND(a:Xl, b:Xr, n:1);
  Xr = Xr ^ PArray[0];

  return raw_dword(d:Xr) + raw_dword(d:Xl);
}


##
# Initializes the Blowfish Feistel network
# based on the provided cipher key.
#
# @param [key:bytes] A cipher key for encryption/decryption
# @return Returns NULL.
##
function blowfish_initialize (key)
{
  local_var i, j, data, keybytes;

  _bf_enc_iv = _bf_dec_iv = crap(data:'\0', length:8);

  keybytes = strlen(key);

  for(i = 0; i < 18; i++)
  {
    PArray[i] = bf_P[i];
  }

  for(i = 0; i < 4; i++)
  {
    for(j = 0; j < 256; j++)
      SBoxes [i*256 + j] = bf_S [i*256 + j];
  }

  j = 0;
  for(i = 0; i < NPASS + 2; ++i)
  {
    data = (ord(key[j]) << 24) +
           (ord(key[(j+1) % keybytes]) << 16) +
           (ord(key[(j+2) % keybytes]) << 8) +
           ord(key[(j+3) % keybytes]) ;
    PArray[i] = PArray[i] ^ data;
    j = (j + 4) % keybytes;
  }

  data = raw_string (0,0,0,0,0,0,0,0);

  for(i = 0; i < NPASS + 2; i += 2)
  {
    data = blowfish_encipher(data:data);
    PArray[i] = get_dword(blob:data, pos:0);
    PArray[i + 1] = get_dword(blob:data, pos:4);
  }

  for(i = 0; i < 4; ++i)
  {
    for(j = 0; j < 256; j += 2)
    {
      data = blowfish_encipher(data:data);
      SBoxes[i*256 + j] = get_dword(blob:data, pos:0);
      SBoxes[i*256 + j + 1] = get_dword(blob:data, pos:4);
    }
  }
}


##
# Decrypts blowfish ciphertext using a Feistel
# network initialized initialized to the encryption
# key.
#
# @param [data:bytes] Blowfish ciphertext.
# @return Returns plaintext if the key was correct.
# @remark data length must be % 8
##
function blowfish_decrypt (data)
{
  local_var tmp, to_decrypt, i, iv, len, j, dec;

  tmp = NULL;

  iv = _bf_dec_iv;

  len = strlen(data);

  for(i = 0; i < len; i += 8)
  {
    to_decrypt = substr (data, i, i+7);

    dec = blowfish_decipher(data:to_decrypt);

    for(j = 0; j < 8; j++)
      dec[j] = raw_string(ord(dec[j]) ^ ord(iv[j]));

    tmp = tmp + dec;
    iv = to_decrypt;
  }

  _bf_dec_iv = iv;

  return tmp;
}


##
# Encrypts blowfish plaintext using a Feistel
# network initialized initialized to the encryption
# key.
#
# @param [data:bytes] Blowfish ciphertext.
# @return Returns ciphertext.
# @remark data length must be % 8
##
function blowfish_encrypt (data)
{
  local_var tmp, to_encrypt, i, iv, len, j;

  tmp = NULL;
  iv = _bf_enc_iv;

  len = strlen(data);

  for(i = 0;i < len; i += 8)
  {
    to_encrypt = substr (data, i, i+7);
    for(j = 0; j < 8; j++)
      to_encrypt[j] = raw_string(ord(to_encrypt[j]) ^ ord(iv[j]));

    iv = blowfish_encipher(data:to_encrypt);

    tmp += iv;
  }

  _bf_enc_iv = iv;

  return tmp;
}

##
# Implements PBKDF2 hash if the salt or message has leading zeros.  This is to
# work around a flaw in the nessus-engine starting with Nessus 7.2.0 and fixed
# in Nessus 8.2.0.  This is a naive implementation of
# https://tools.ietf.org/html/rfc2898`
#
# @param <message:binary string> The data to hash.
# @param <salt:binary string> The salt.
# @param <digest_str: string> Designates the hash function to use.
# @param <iters: int> The number of times to iterate.
# @param <keylen: int> The length of the result hash in bytes.
#
# @return A binary string that is the PBKDF2 hash of the message.
##
function pbkdf2_wrapper(message, salt, digest_str, iters, keylen)
{
  local_var result, result_blocks, i;

  if(isnull(salt) || strlen(salt) == 0)
  {
    dbg::detailed_log(lvl:1, src:FUNCTION_NAME, msg:"Salt is empty or null.");
    return NULL;
  }

  if(isnull(digest_str) || iters == 0)
  {
    dbg::detailed_log(lvl:1, src:FUNCTION_NAME, msg:"Bad digest: " + digest_str + " or bad iteration count: " + iters + ".");
    return NULL;
  }

  if(isnull(message))
    message = '';

  if(keylen == 0)
  {
    dbg::detailed_log(lvl:1, src:FUNCTION_NAME, msg:"An empty keylen was chosen.  Returning a blank string.");
    return '';
  }

  if((nasl_level() >= 70200 && salt[0] != '\x00') || nasl_level() >= 80200)
  {
    return crypto_hash(data:message, type:"PBKDF2",
                       options:{salt:salt, digest:digest_str, iteration:iters, keylen:keylen});
  }

  return pbkdf2(p:message, s:salt, c:iters, dklen:keylen, prf:digest_str);
}

